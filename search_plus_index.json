{"./":{"url":"./","title":"Introduction","keywords":"","body":"Leetcode 最近因为一些事情又开始刷题了，所以这个当作记录刷题笔记的网站吧。 powered by GitbookFile Modify: 2024-11-24 21:55:26 "},"codes/238/":{"url":"codes/238/","title":"238. Product of Array Except Self","keywords":"","body":"238. Product of Array Except Self Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) Solution 这个问题给出的提示 prefix 和 suffix ，那么根据这个提示我们可以得知这个题是需要前后遍历的算。并且该问题要求时间复杂度是 O(n) ，我们可以采取左右两边遍历的方法。 根据这个问题本身的要求，算出该数组所有数字的乘积，但是不包含当前数字。首先我们可以使用 prefix 从左到右遍历一下： nums: 1 2 3 4 pre: 1 1 2 6 我们可以观察到从左到右遍历的话， nums 中每个索引对应的数据是前面几个数字的乘积，这样的话我们可以得知从左到右的乘积是多少了。从右往左的时候，我们需要用当前数字乘以上一轮的结果，这样我们就能得到最后结果了。 prefix 记录的是从左到右的乘积， sufix 记录的是从右到左的乘积（不包含自身）。 class Solution { public: vector productExceptSelf(vector& nums) { auto ans = vector(nums.size(), 1); int prefix = 1; for (int i = 0; i = 0; i -- ) { ans[i] = suffix * ans[i]; suffix *= nums[i]; } return ans; } }; powered by GitbookFile Modify: 2024-11-24 22:00:17 "},"codes/268/":{"url":"codes/268/","title":"268. Missing Number","keywords":"","body":"268. Missing Number Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: n == nums.length 1 0 All the numbers of nums are unique. Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity? Solution 用hashmap就能解决。但空间复杂度是 O(n) 。如果想要在 O(1) 是的空间复杂度中完成，可以通过求和的方式来解决。 class Solution { public: int missingNumber(vector& nums) { int r_sum = 0; int a_sum = 0; for (int i = 0; i powered by GitbookFile Modify: 2024-11-24 22:00:01 "},"codes/287/":{"url":"codes/287/","title":"287. Find the Duplicate Number","keywords":"","body":"287. Find the Duplicate Number Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space. Example 1: Input: nums = [1,3,4,2,2] Output: 2 Example 2: Input: nums = [3,1,3,4,2] Output: 3 Example 3: Input: nums = [3,3,3,3,3] Output: 3 Constraints: 1 nums.length == n + 1 1 All the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up: How can we prove that at least one duplicate number must exist in nums? Can you solve the problem in linear runtime complexity? Solution S1. 可以使用 hashmap 的思路来解决这个问题，解决方法比较简单，但是不满足 O(1) space的要求。 class Solution { public: int findDuplicate(vector& nums) { auto maps = unordered_map(); for (int const& num : nums) { maps[num] += 1; if (maps[num] > 1) return num; } return -1; } }; S2. 使用快慢指针的方法来解决，因为题目中的要求其实已经声明了，数字不会超过数组长度，所以可以使用快慢指针的思路来找到cycle。 class Solution { public: int findDuplicate(vector& nums) { int slow = nums[0]; int fast = nums[0]; // Phase 1: Detect cycle do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = nums[0]; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; // The duplicate number } }; powered by GitbookFile Modify: 2024-11-24 22:01:52 "},"codes/645/":{"url":"codes/645/","title":"645. Set Mismatch","keywords":"","body":"645. Set Mismatch You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: Input: nums = [1,2,2,4] Output: [2,3] Example 2: Input: nums = [1,1] Output: [1,2] Constraints: 2 1 Solution hashmap 的解决思路 class Solution { public: vector findErrorNums(vector& nums) { auto res = vector(); int r_sum = nums.size() * (nums.size() + 1) / 2; auto maps = unordered_map(); for (int const& num : nums) { maps[num] += 1; if (maps[num] > 1) res.push_back(num); if (maps[num] == 1) { r_sum -= num; } } res.push_back(r_sum); return res; } }; powered by GitbookFile Modify: 2024-11-24 22:02:19 "}}