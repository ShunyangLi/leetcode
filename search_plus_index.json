{"./":{"url":"./","title":"Introduction","keywords":"","body":"Leetcode 最近因为一些事情又开始刷题了，所以这个当作记录刷题笔记的网站吧。 powered by GitbookFile Modify: 2024-11-24 21:55:26 "},"codes/238/":{"url":"codes/238/","title":"238. Product of Array Except Self","keywords":"","body":"238. Product of Array Except Self Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) Solution 这个问题给出的提示 prefix 和 suffix ，那么根据这个提示我们可以得知这个题是需要前后遍历的算。并且该问题要求时间复杂度是 O(n) ，我们可以采取左右两边遍历的方法。 根据这个问题本身的要求，算出该数组所有数字的乘积，但是不包含当前数字。首先我们可以使用 prefix 从左到右遍历一下： nums: 1 2 3 4 pre: 1 1 2 6 我们可以观察到从左到右遍历的话， nums 中每个索引对应的数据是前面几个数字的乘积，这样的话我们可以得知从左到右的乘积是多少了。从右往左的时候，我们需要用当前数字乘以上一轮的结果，这样我们就能得到最后结果了。 prefix 记录的是从左到右的乘积， sufix 记录的是从右到左的乘积（不包含自身）。 class Solution { public: vector productExceptSelf(vector& nums) { auto ans = vector(nums.size(), 1); int prefix = 1; for (int i = 0; i = 0; i -- ) { ans[i] = suffix * ans[i]; suffix *= nums[i]; } return ans; } }; powered by GitbookFile Modify: 2024-11-24 22:00:17 "},"codes/268/":{"url":"codes/268/","title":"268. Missing Number","keywords":"","body":"268. Missing Number Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: n == nums.length 1 0 All the numbers of nums are unique. Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity? Solution 用hashmap就能解决。但空间复杂度是 O(n) 。如果想要在 O(1) 是的空间复杂度中完成，可以通过求和的方式来解决。 class Solution { public: int missingNumber(vector& nums) { int r_sum = 0; int a_sum = 0; for (int i = 0; i powered by GitbookFile Modify: 2024-11-24 22:00:01 "},"codes/287/":{"url":"codes/287/","title":"287. Find the Duplicate Number","keywords":"","body":"287. Find the Duplicate Number Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space. Example 1: Input: nums = [1,3,4,2,2] Output: 2 Example 2: Input: nums = [3,1,3,4,2] Output: 3 Example 3: Input: nums = [3,3,3,3,3] Output: 3 Constraints: 1 nums.length == n + 1 1 All the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up: How can we prove that at least one duplicate number must exist in nums? Can you solve the problem in linear runtime complexity? Solution S1. 可以使用 hashmap 的思路来解决这个问题，解决方法比较简单，但是不满足 O(1) space的要求。 class Solution { public: int findDuplicate(vector& nums) { auto maps = unordered_map(); for (int const& num : nums) { maps[num] += 1; if (maps[num] > 1) return num; } return -1; } }; S2. 使用快慢指针的方法来解决，因为题目中的要求其实已经声明了，数字不会超过数组长度，所以可以使用快慢指针的思路来找到cycle。 class Solution { public: int findDuplicate(vector& nums) { int slow = nums[0]; int fast = nums[0]; // Phase 1: Detect cycle do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = nums[0]; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; // The duplicate number } }; powered by GitbookFile Modify: 2024-11-24 22:01:52 "},"codes/645/":{"url":"codes/645/","title":"645. Set Mismatch","keywords":"","body":"645. Set Mismatch You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: Input: nums = [1,2,2,4] Output: [2,3] Example 2: Input: nums = [1,1] Output: [1,2] Constraints: 2 1 Solution hashmap 的解决思路 class Solution { public: vector findErrorNums(vector& nums) { auto res = vector(); int r_sum = nums.size() * (nums.size() + 1) / 2; auto maps = unordered_map(); for (int const& num : nums) { maps[num] += 1; if (maps[num] > 1) res.push_back(num); if (maps[num] == 1) { r_sum -= num; } } res.push_back(r_sum); return res; } }; powered by GitbookFile Modify: 2024-11-24 22:02:19 "},"codes/739/":{"url":"codes/739/","title":"739. Daily Temperatures","keywords":"","body":"739. Daily Temperatures Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] Example 3: Input: temperatures = [30,60,90] Output: [1,1,0] Constraints: 1 30 Solution 这个是真是面试题，21年的时候面试的时候遇到了。可以采用 stack 数据结构的解决方法。当遍历当前温度的时候去判断 stack 里面的元素是否小于当前温度，如果小于的话则 pop ，最后结束循环的时候把当前温度添加到 stack 中，因为每个温度都要找到比当前大的温度。 class Solution { public: vector dailyTemperatures(vector& temperatures) { auto stack = std::vector>(); auto res = vector(temperatures.size(), 0); for (int i = 0; i val = stack.back(); if (val.first >= t) break; res[val.second] = i - val.second; stack.pop_back(); } stack.push_back(pair(t, i)); } return res; } }; powered by GitbookFile Modify: 2024-11-24 22:12:01 "},"codes/496/":{"url":"codes/496/","title":"496. Next Greater Element I","keywords":"","body":"496. Next Greater Element I The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 , find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1. Return an array ans of length nums1.length such that ans[i] is the next greater element as described above. Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. - 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. - 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3. - 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1. Constraints: 1 0 All integers in nums1 and nums2 are unique. All the integers of nums1 also appear in nums2. Follow up: Could you find an O(nums1.length + nums2.length) solution? Solution 和上面那个题思路差不多，只是每个element都是unique的，所以可以额外使用hashmap来方便运算。 class Solution { public: vector nextGreaterElement(vector& nums1, vector& nums2) { auto stack = vector(); auto maps = unordered_map(); auto res = vector(nums1.size(), -1); if (nums2.size() == 0) return res; stack.push_back(nums2[0]); maps[nums2[0]] = -1; for (int i = 1; i nums2[i]) break; maps[val] = nums2[i]; stack.pop_back(); } stack.push_back(nums2[i]); } for (int i = 0; i powered by GitbookFile Modify: 2024-11-24 22:16:13 "}}