{"./":{"url":"./","title":"Introduction","keywords":"","body":"Leetcode æœ€è¿‘å› ä¸ºä¸€äº›äº‹æƒ…åˆå¼€å§‹åˆ·é¢˜äº†ï¼Œæ‰€ä»¥è¿™ä¸ªå½“ä½œè®°å½•åˆ·é¢˜ç¬”è®°çš„ç½‘ç«™å§ã€‚ powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/uf/":{"url":"codes/uf/","title":"Union Find","keywords":"","body":"Union Find Union-Findï¼ˆåˆç§°å¹¶æŸ¥é›†ï¼‰æ˜¯ä¸€ç§å¸¸ç”¨çš„æ•°æ®ç»“æ„ï¼Œä¸»è¦ç”¨äºè§£å†³åŠ¨æ€è¿é€šæ€§é—®é¢˜ï¼Œæ¯”å¦‚åˆ¤æ–­æŸäº›å…ƒç´ æ˜¯å¦å±äºåŒä¸€ç»„ï¼Œæˆ–åˆå¹¶ä¸¤ä¸ªç»„ã€‚ åŸºæœ¬åŠŸèƒ½ Findï¼šæ‰¾åˆ°æŸä¸ªå…ƒç´ æ‰€å±ç»„çš„ä»£è¡¨å…ƒç´ ï¼ˆä¹Ÿå«æ ¹èŠ‚ç‚¹ï¼‰ã€‚ Unionï¼šå°†ä¸¤ä¸ªç»„åˆå¹¶æˆä¸€ä¸ªç»„ã€‚ å·¥ä½œåŸç† åˆå§‹åŒ–ï¼šæ¯ä¸ªå…ƒç´ è‡ªæˆä¸€ç»„ï¼Œparent[i] = iã€‚ Find æ“ä½œï¼š é€šè¿‡é€’å½’æˆ–è¿­ä»£æ‰¾åˆ°æŸä¸ªå…ƒç´ çš„æ ¹èŠ‚ç‚¹ã€‚ è·¯å¾„å‹ç¼©ä¼˜åŒ–ï¼šåœ¨æŸ¥æ‰¾æ—¶å°†è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ç›´æ¥æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼Œå‡å°‘åç»­æ“ä½œçš„æŸ¥æ‰¾æ·±åº¦ã€‚ Union æ“ä½œï¼š å°†ä¸¤ä¸ªç»„çš„æ ¹èŠ‚ç‚¹è¿æ¥ã€‚ æŒ‰ç§©åˆå¹¶ä¼˜åŒ–ï¼šå°†èŠ‚ç‚¹æ•°å°‘çš„æ ‘æŒ‚åˆ°èŠ‚ç‚¹æ•°å¤šçš„æ ‘ä¸Šï¼Œæˆ–æ ¹æ®æ·±åº¦å†³å®šå¦‚ä½•åˆå¹¶ï¼Œé¿å…æ ‘å˜å¾—è¿‡é«˜ã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i 0 åœ¨ Union-Find ä¸­ï¼Œæœ€å·®çš„æƒ…å†µå‘ç”Ÿåœ¨æ²¡æœ‰ä»»ä½•ä¼˜åŒ–æ—¶ï¼Œå½“æ‰€æœ‰å…ƒç´ å½¢æˆä¸€ä¸ªé“¾è¡¨ç»“æ„ï¼ŒæŸ¥è¯¢å¤æ‚åº¦ä¼šé€€åŒ–ä¸º O(n) å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚ Optimization è·¯å¾„å‹ç¼©ï¼š åœ¨ find æ“ä½œæ—¶ï¼Œå°†è®¿é—®è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹ç›´æ¥è¿æ¥åˆ°æ ¹èŠ‚ç‚¹ã€‚ å‹ç¼©åï¼ŒæŸ¥è¯¢æ ‘çš„é«˜åº¦è¶‹å‘äº O(log n) æˆ–æ›´ä½ (O(1))ã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i åœ¨ find æ–¹æ³•ä¸­ï¼š ä½¿ç”¨é€’å½’å®ç°è·¯å¾„å‹ç¼©ï¼šroot[x] = find(root[x]);ã€‚ è¿™ä¼šå°†èŠ‚ç‚¹ x çš„çˆ¶èŠ‚ç‚¹ç›´æ¥è®¾ç½®ä¸ºæ ¹èŠ‚ç‚¹ï¼Œä»è€Œå‡å°‘æ ‘çš„æ·±åº¦ã€‚ è¿™æ ·çš„è¯ä¸Šé¢å›¾ä¸­4, 3, 2, 1çš„rootéƒ½ä¼šç›´æ¥æŒ‡å‘0ã€‚è¿™æ ·çš„è¯æŸ¥è¯¢æ•ˆç‡ä¼šæå‡å¾ˆå¤šã€‚ powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/uf/648.html":{"url":"codes/uf/648.html","title":"684. Redundant Connection","keywords":"","body":"684. Redundant Connection In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input. Example 1: Input: edges = [[1,2],[1,3],[2,3]] Output: [2,3] Example 2: Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]] Output: [1,4] Solution è¿™ä¸ªé—®é¢˜è¿˜æ˜¯ç›´æ¥ç”¨union-findå°±è¡Œã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i findRedundantConnection(vector>& edges) { auto res = vector(); auto uf = UnionFind(edges.size() + 1); for (vector& edge : edges) { int u = edge[0], v = edge[1]; if (uf.is_connected(u, v)) { res.push_back(u); res.push_back(v); break; } uf.union_(u, v); } return res; } }; powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/uf/785.html":{"url":"codes/uf/785.html","title":"785. Is Graph Bipartite?","keywords":"","body":"785. Is Graph Bipartite? There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties: There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them. A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. Return true if and only if it is bipartite. Example 1: Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]] Output: false Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other. Example 2: Input: graph = [[1,3],[0,2],[1,3],[0,2]] Output: true Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}. Constraints: graph.length == n 1 0 0 graph[u] does not contain u. All the values of graph[u] are unique. If graph[u] contains v, then graph[v] contains u. Solution ä¹Ÿæ˜¯é€šè¿‡union-findç»“æ„æ¥å®ç°çš„ï¼Œä½†å€¼å¾—æ³¨æ„çš„æ˜¯ä½¿ç”¨çš„æ–¹æ³•ã€‚æ ¹æ®äºŒéƒ¨å›¾çš„ç‰¹æ€§graph[u]æ˜¯uç‚¹æ‰€æœ‰çš„é‚»å±…ï¼Œé‚£ä¹ˆè¿™äº›é‚»å±…åº”è¯¥æ˜¯å±äºåŒä¸€ä¸ªsetã€‚å¦‚æœæŠŠä»–ä»¬æ‰€æœ‰çš„é‚»å±…éƒ½è”é€šèµ·æ¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­uå’Œvæ˜¯å¦è”é€šå°±è¡Œï¼Œä¸è¿é€šåˆ™ä»£è¡¨åœ¨ä¸åŒçš„setã€‚ é€šè¿‡å°† graph[u][0] ä½œä¸ºåŸºå‡†ï¼Œå°è¯•æŠŠèŠ‚ç‚¹ u å’Œæ‰€æœ‰é‚»å±…åˆ†å…¥ä¸åŒçš„ç»„ã€‚å…³é”®æ˜¯ï¼Œå®ƒå®ç°äº†ä¸€ä¸ªç›¸å¯¹ç®€å•çš„â€œç»„ç®¡ç†â€é€»è¾‘ã€‚è‹¥å‡ºç°çŸ›ç›¾ï¼ˆu å’ŒæŸä¸ªé‚»å±…åœ¨åŒä¸€ç»„ï¼‰ï¼Œå³å¯ç›´æ¥è¿”å› falseã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i >& graph) { auto uf = UnionFind(graph.size()); for (int u = 0; u powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/uf/990.html":{"url":"codes/uf/990.html","title":"990. Satisfiability of Equality Equations","keywords":"","body":"990. Satisfiability of Equality Equations You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names. Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise. Example 1: Input: equations = [\"a==b\",\"b!=a\"] Output: false Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations. Example 2: Input: equations = [\"b==a\",\"a==b\"] Output: true Explanation: We could assign a = 1 and b = 1 to satisfy both equations. Solution å¯ä»¥æŠŠè¿™ä¸ªé—®é¢˜è€ƒè™‘æˆå›¾ç®—æ³•æ¥å¤„ç†ï¼Œæ¯”å¦‚a==bæˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ˜¯aå’Œbæ˜¯è”é€šçš„ã€‚æˆ‘ä»¬éœ€è¦å…ˆéå†æ‰€æœ‰==çš„stringï¼Œå¹¶ä¸”æŠŠä»–ä»¬connectåˆ°ä¸€èµ·ã€‚ç„¶åå»éå†!=çš„æ“ä½œï¼Œåˆ¤æ–­æ˜¯å¦è”é€šï¼Œå¦‚æœæ˜¯è”é€šä½†æ˜¯ç¬¦å·æ˜¯!=åˆ™è¿”å›falseã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i & equations) { auto uf = UnionFind(26); for (string const& s : equations) { if (s[1] == '=') { uf.union_(s[0] - 'a', s[3] - 'a'); } } for (string const& s : equations) { if (s[1] == '!') { if (uf.is_connected(s[0] - 'a', s[3] - 'a')) return false; } } return true; } }; powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/1/":{"url":"codes/1/","title":"1. Two Sum","keywords":"","body":"Two Sum Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. è¿™ä¹Ÿæ˜¯æˆ‘ç¬¬ä¸€æ¬¡é¢è¯•çš„ç¬¬ä¸€ä¸ªç®—æ³•ï¼Œå½“æ—¶æƒ³çš„æ–¹æ³•æ˜¯æœ€æš´åŠ›çš„æ–¹æ³•ï¼Œç›´æ¥ä¸¤ä¸ªå¾ªç¯å®Œäº‹ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ˜¯O(n2) O(n^{2}) O(nâ€‹2â€‹â€‹) ï¼Œé‚£æ˜¯ç›¸å½“çš„é«˜o(â•¥ï¹â•¥)oã€‚åæ¥æƒ³äº†ä¸€ä¸‹æ‰¾åˆ°äº†ä¸€ä¸ªç®€å•çš„æ–¹æ³•ï¼Œå½“æ—¶ç”±äºå¤ªç´§å¼ å†™çš„ä¸å¤ªå¥½ã€‚å½“æ—¶çš„é—®é¢˜æ–¹æ³•ä¹Ÿç¨å¾®æœ‰ç‚¹ä¸åŒï¼Œå½“æ—¶è¦æ±‚çš„æ˜¯æ‰¾åˆ°ç›¸å¯¹åº”çš„æ•°å­—ï¼Œä¸æ˜¯indexã€‚ å…ˆå›é¡¾ä¸€ä¸‹å½“æ—¶çš„ç®—æ³•ï¼š int[] another(int[] nums, int target) { int head = 0; int tail = 0; // sort it Arrays.sort(nums); while (true) { int value = nums[head] + nums[tail]; if (value == target) break; else if (value > target) tail -= 1; else head += 1; if (head == tail) break; } if (head != tail) return new int[] {nums[head], nums[tail]}; return null; } å½“æ—¶æƒ³åˆ°çš„æ˜¯ä¸¤å¤´åŒæ—¶éå†çš„æ–¹æ³•ï¼Œä½†æ˜¯æœ‰ä¸ªå‰æè¦æ±‚å°±æ˜¯listå¿…é¡»æ˜¯æ’è¿‡åºçš„ï¼Œå½“numsæ— é™å¤§æ—¶æ’åºæ‰€æ¶ˆè€—çš„æ—¶é—´å¯ä»¥å¿½ç•¥çš„ï¼Œè¿™ä¸ªæ–¹æ³•æœ‰ç‚¹ç±»ä¼¼äºbinary searchã€‚æˆ‘å½“æ—¶ä¹Ÿæƒ³è¿‡ç”¨HashMapï¼Œå¥½åƒå¤„äºä»€ä¹ˆåŸå› è¢«é¢è¯•å®˜å¦å®šäº†ï¼Œwhateverä¸é‡è¦çš„ã€‚ä¸é—²æ‰¯äº†ï¼Œæˆ‘ä»¬å¼€å§‹çœ‹è¿™é¢˜çš„æ¯”è¾ƒä¼˜åŒ–çš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(n)ã€‚ int[] twoSum(int[] nums, int target) { Map map = new HashMap<>(); for (int i = 0; i ç®—æ³•æ€è·¯ï¼š å› ä¸ºæ˜¯ç”¨çš„HashMapæ‰€ä»¥åœ¨æ£€æµ‹keyæ˜¯å¦containçš„è¯ä½¿ç”¨çš„æ˜¯hashçš„æ–¹æ³•ï¼Œæ‰€ä»¥å¤æ‚åº¦æ˜¯$O(1)$ ç¬¬7-11è¡Œï¼Œæ˜¯æ¥åˆ¤æ–­è¿™ä¸ªHashMapæ˜¯å¦åŒ…å«è¿™ä¸ªnumï¼Œå¦‚æœè¿™ä¸ªnumä¸åŒ…å«åœ¨HashMapé‡Œé¢ï¼Œç„¶åæŠŠè¯¥numå­˜åˆ°HashMapé‡Œé¢ï¼Œnumå½“åškeyï¼Œindexå½“åšvalueã€‚è¿™æ ·å°±ç›¸å½“äºæŠŠè®¿é—®è¿‡çš„numå’Œnumçš„indexå­˜åˆ°HashMapé‡Œé¢ï¼Œç„¶åå†éå†numsçš„æ—¶å€™å¾—å¯¹æ¯ä¸ªæ•°å¯ä»¥å¾—åˆ°ä¸€ä¸ªå·®å€¼ï¼Œç„¶ååˆ¤æ–­è¿™ä¸ªå·®å€¼æ˜¯å¦å­˜åœ¨HashMapé‡Œé¢ï¼Œå¦‚æœå­˜åœ¨å°±ä»£è¡¨å¾—åˆ°è¿™ä¸ªç»“æœäº†ï¼Œå¦‚æœä¸å­˜åœ¨å°±æŠŠè¿™ä¸ªnums[i]å­˜åˆ°HashMapã€‚ powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/2/":{"url":"codes/2/","title":"2. Add Two Numbers","keywords":"","body":"Add Two Numbers Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. ç®—æ³•æ€æƒ³ï¼š ä¸»è¦åº”è¯¥è€ƒè™‘ä¸€ä¸‹è¾¹ç•Œæƒ…å†µï¼š å½“sum>=10 ä¸¤ä¸ªé“¾è¡¨ä¸ä¸€æ ·é•¿ åœ¨æœ€åä¸€ä¸ªæ•°å­—ç›¸åŠ çš„æ—¶å€™sum>=10 ç¬¬6è¡Œçš„whileè¯­å¥å°±æ˜¯ä¸ºäº†ä¸¤æ¡é“¾è¡¨ä¸ä¸€æ ·é•¿åº¦ã€‚ç¬¬7-8è¡Œåˆ¤æ–­å¦‚æœè¯¥é“¾è¡¨ä¸ä¸ºnullå°±å–è¯¥valï¼Œä¸ç„¶çš„è¯å°±ä¸º0ï¼ˆä¸ºäº†ä¸å½±å“ä¸‹é¢çš„è®¡ç®—ï¼‰ã€‚int overflow = 0æ˜¯ä¸ºäº†è§£å†³å’Œè¶…è¿‡10çš„æƒ…å†µï¼Œç¬¬9è¡ŒæŠŠæº¢å‡ºçš„æ•°å­—å’Œv1ï¼Œv2ç›¸åŠ ï¼Œç„¶åæŠŠè¯¥ç»“æœå–ä½™å°±æ˜¯ç»“æœã€‚ç„¶åæŠŠoverflow = sum/10 å¾—åˆ°è¿›ä½æ•°ã€‚æ¯æ¬¡ç”Ÿæˆæ–°çš„æ•°å­—ä¹‹åç”Ÿæˆä¸€ä¸ªæ–°çš„nodeæ²¡ç„¶åé“¾æ¥èµ·æ¥ã€‚ä¸»è¦æ˜¯è€ƒè™‘ä¸åŒçš„è¾¹ç•Œæƒ…å†µã€‚ public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int overflow = 0; if (l1 == null && l2 == null) return null; ListNode new_node = new ListNode(); ListNode head = new_node; while (l1 != null || l2 != null) { int v1 = (l1 != null) ? l1.val : 0; int v2 = (l2 != null) ? l2.val : 0; int sum = v1+v2 + overflow; overflow = sum / 10; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; new_node.val = sum % 10; if (l1 != null || l2 != null) { new_node.next = new ListNode(); new_node = new_node.next; } } if (overflow > 0) { new_node.next = new ListNode(overflow % 10); } return head; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/3/":{"url":"codes/3/","title":"3. Longest Substring Without Repeating Characters","keywords":"","body":"Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. è§£é¢˜æ–¹æ³•&æ€è·¯ï¼š é¦–å…ˆè¯´ä¸‹é¢˜æ„ï¼Œæˆ‘åˆšå¼€å§‹æ˜¯æ²¡ç†è§£é¢˜æ„æ¥å¾—ï¼ˆæš´éœ²äº†è‡ªå·±çš„æ— çŸ¥â•®(â•¯â–½â•°)â•­ï¼‰ï¼Œé¢˜æ„å°±æ˜¯åŒ¹é…åˆ°æœ€é•¿çš„å­å­—ç¬¦ä¸²ï¼Œå¹¶ä¸”ä¸èƒ½é‡å¤ã€‚æ¯”å¦‚pwwkew å¯ä»¥åŒ¹é…åˆ°wke æœ€åä¸€ä¸ªwä¸å¯ä»¥è¢«åŒ¹é…åˆ°ï¼Œå› ä¸ºè¯¥å­å­—ç¬¦ä¸²å·²ç»åŒ…å«äº†ä¸€ä¸ªwã€‚ ç®—æ³•è§£æï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æš´åŠ›è§£æ³•ï¼šåŒå¾ªç¯ï¼ˆä½†æ˜¯ä¸æ¨è)ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨HashMapæ¥è§£å†³è¯¥é—®é¢˜ï¼Œå› ä¸ºHashMapæŸ¥è¯¢çš„æ—¶å€™åªéœ€è¦$O(1)$çš„æ—¶é—´å¤æ‚åº¦ã€‚ é¦–å…ˆå¯¹è¯¥å­—ç¬¦ä¸²è¿›è¡Œéå†ï¼Œå¦‚æœè¯¥å­—ç¬¦ä¸åœ¨HashMapé‡Œé¢ï¼Œåˆ™æŠŠè¯¥å­—ç¬¦æ·»åŠ åˆ°HashMapï¼Œå–maxï¼ˆHashMap length, ansï¼‰ å¦‚æœè¯¥å­—ç¬¦å·²ç»å‡ºç°åœ¨HashMapé‡Œé¢ï¼Œä»HashMapé‡Œé¢å»é™¤ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶åcurrent indexä¿æŒä¸å˜ï¼ˆä¼šå¯¹è¯¥indexè¿›è¡Œå†æ¬¡éå†ï¼‰ å¾ªç¯ æœ‰ç‚¹ç±»ä¼¼äºï¼šå½“ä¸€ä¸ªå­—ç¬¦ä¸åœ¨è¯¥HashMapï¼Œpushè¿›å»ï¼Œå¦‚æœå·²ç»åœ¨äº†ï¼Œpopå‡ºæ¥ã€‚ç„¶ååœ¨pushä¹‹åè®¡ç®—æœ€å¤§çš„é•¿åº¦æ˜¯å¤šå°‘ã€‚ï¼ˆè¿›å»ä¸€ä¸ªå¦‚æœå·²ç»å­˜åœ¨å°±popå‡ºæ¥ä¸€ä¸ªï¼Œå› ä¸ºé‡ç‚¹æ˜¯é•¿åº¦ï¼Œæ‰€ä»¥ä¸éœ€è¦å…³å¿ƒåˆ°åº•æ˜¯å“ªäº›å­—ç¬¦ï¼‰ã€‚ Pythonä¼ªä»£ç  def LongSubString(s): while i Javaè§£å†³æ–¹æ³•ï¼š import java.util.HashMap; import java.util.Map; public class LongestSubstring { public int lengthOfLongestSubstring(String s) { int ans = 0; int remove = 0; Map map = new HashMap<>(); for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/4/":{"url":"codes/4/","title":"4. Median of Two Sorted Arrays","keywords":"","body":"Median of two sorted array There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 æ²¡åŠæ³•å¤ªèœäº†æ‰¾ä¸åˆ°åˆé€‚çš„æ–¹æ³•æ¥å†™äº†ï¼Œæœ‰æƒ³è¿‡åˆ†å¼€å¾ªç¯ï¼Œä½†æ˜¯è¿™æ ·éœ€è¦æœ‰å¾ˆå¤šçš„åˆ¤æ–­æ¡ä»¶ï¼Œæ™šä¼šä¼šå†å°è¯•çš„ï¼Œç›®å‰å°±å¿«çš„æ–¹æ³•å°±æ˜¯åˆå¹¶arrayäº†ã€‚ public double findMedianSortedArrays(int[] nums1, int[] nums2) { List list = new LinkedList<>(); int l1 = 0, l2 = 0; while (l1 = nums1.length) { for (int i = l2; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/7/":{"url":"codes/7/","title":"7. Reverse Integer","keywords":"","body":"Reverse Integer reverse integer Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 æœ¬æ¥ä»¥ä¸ºè¿™ä¸ªé¢˜å¾ˆç®€å•ï¼Œä½¿ç”¨äº†æœ€ç®€å•çš„ç®—æ³•ï¼Œä½†æ˜¯å‘¢ï¼Œå‡ºç°äº†ä¸€ä¸ªæ•´å‹æº¢å‡ºçš„é—®é¢˜o(â•¥ï¹â•¥)oã€‚ å…ˆè§£æä¸€ä¸‹æ€è·¯å§ï¼š é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç”¨x%10æ¥å¾—åˆ°æœ€åä¸€ä¸ªæ•°å­—ï¼ˆå› ä¸ºæ•°å­—ä¸å¯èƒ½å¤§äº10ï¼‰ x/10æ˜¯æŠŠæœ€åä¸€ä½æ•°å»æ‰ reverse*10æ˜¯ä¸ºäº†æ•´ä½“å‘å·¦ç§»ä¸€ä½ï¼Œæ¯”å¦‚(44, 44*10 = 440)å¤šå‡ºä¸€ä¸ªç©ºä½ï¼Œç„¶ååŠ ä¸Šx%10çš„æ•°å­— public int reverse(int x) { int reverse = 0; while (x != 0) { int last_digit = x % 10; reverse = reverse * 10 + last_digit; x = x / 10; } return reverse ; } è¿™æ ·å¦‚æœæ•°å­—åŒºé—´åœ¨$[âˆ’2^{31}, 2^{31} âˆ’ 1]$çš„è¯é‚£ä¹ˆå°±ä¼šå‡ºç°æº¢å‡ºçš„é—®é¢˜äº†ï¼Œå¤§å®¶å¯ä»¥ä½¿ç”¨1534236469æ¥å°è¯•ä¸€ä¸‹ã€‚ æ‰€ä»¥è¿™æ—¶å€™æˆ‘ä»¬å°±éœ€è¦æ¥åšäº›åˆ¤æ–­äº†ï¼š å½“reverse > intMAX/10çš„æ—¶å€™æˆ‘ä»¬åŸºæœ¬ä¸Šå°±å¯ä»¥ç¡®å®šä»–ä¼šæº¢å‡ºäº†ï¼Œæ¯”å¦‚è¯´intMAX = 2147483647ï¼Œå‡è®¾æˆ‘ä»¬çš„reverse = 214748365 è¿™æ—¶å€™intMAX/10 =214748364ï¼Œreverse > intMAXã€‚è¿™æ—¶å€™å¦‚æœreverse * 10æˆ‘ä»¬ä¸ç®¡æœ€åä¸€ä¸ªæ•°å­—æ˜¯ä»€ä¹ˆäº†ï¼Œreverseå·²ç»è¶…å‡ºäº†intå–å€¼èŒƒå›´ã€‚ æ­£ç¡®ä»£ç ï¼š public int reverse(int x) { int reverse = 0; while (x != 0) { int last_digit = x % 10; if (reverse > Integer.MAX_VALUE / 10) return 0; if (reverse powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/8/":{"url":"codes/8/","title":"8. String to Integer (atoi)","keywords":"","body":"String to Integer (atoi) String to Integer (atoi) Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [âˆ’231, 231 âˆ’ 1]. If the numerical value is out of the range of representable values, INT_MAX (231 âˆ’ 1) or INT_MIN (âˆ’231) is returned. Example 1: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (âˆ’231) is returned. è¿™æ˜¯æˆ‘å†™LeetCodeä»¥æ¥submitæœ€å¤šçš„æ¬¡æ•°â•®(â•¯â–½â•°)â•­ï¼Œé‡Œé¢æ¡ä»¶çš„é™åˆ¶å’Œç¬¦å·çš„åˆ¤å®šå¤ªçƒ¦äº†ã€‚ç»™å¤§å®¶å†™ä¸€ä¸‹åˆ¤æ–­æ¡ä»¶ï¼š ç©ºæ ¼åªèƒ½å‡ºç°åœ¨æœ€å‰é¢ï¼Œä¸€æ—¦å‡ºç°äº†-+0-9è¿™äº›ç¬¦å·ï¼Œä¹‹åå†é‡åˆ°ç©ºæ ¼å°±è¦break -+ç¬¦å·è€ƒè™‘åˆ°ç¬¦å·çš„é—®é¢˜ åªèƒ½ä»¥æ•°å­—å¼€å¤´çš„æ‰èƒ½æå–æ•°å­—ï¼Œå¦‚æœä¸æ˜¯å°±return 0 è€ƒè™‘åˆ°æ•´å‹æº¢å‡ºçš„é—®é¢˜ å°±æ˜¯åˆ¤æ–­æ¡ä»¶æœ‰ç‚¹éº»çƒ¦ï¼Œå…¶ä»–çš„è¿˜å¥½ï¼Œæˆ‘å†™çš„æœ‰ç‚¹ä¹±ä¸ƒå…«ç³Ÿçš„ï¼Œè®²ç©¶çœ‹ä¸‹ã€‚ã€‚ã€‚å¦‚æœæœ‰å¥½çš„ideaå¯ä»¥å†™åœ¨commenté‡Œé¢ï¼Œæˆ‘ä¼šä¿®æ”¹çš„ã€‚ public int myAtoi(String str) { int res = 0; // + or - int operation = 1; if (str.equals(\"\"))return 0; boolean whitespace = true; boolean sign = true; for (int i = 0; i '9') break; whitespace = false; sign=false; if (res*operation > Integer.MAX_VALUE/10 || res*operation 0) return Integer.MAX_VALUE; else return Integer.MIN_VALUE; } if (res*operation == Integer.MAX_VALUE/10) if ((int)c-48 >= Integer.MAX_VALUE %10) return Integer.MAX_VALUE; if (res*operation == Integer.MIN_VALUE/10) if ((int)(c-48) * -1 powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/9/":{"url":"codes/9/","title":"9. Palindrome Number","keywords":"","body":"Palindrome Number palindrome number Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. å›æ–‡æ•°ä¹Ÿå°±æ˜¯è¯´è¯¥æ•°å­—ç­‰äºç¿»è½¬åçš„æ•°å­—ï¼Œnum = reverse(num)ã€‚é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç¡®å®šå¦‚æœè¯¥æ•°å­—æ˜¯è´Ÿæ•°ç›´æ¥falseå°±å¥½äº†ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸Šä¸€é¢˜çš„æ€è·¯ï¼ŒæŠŠæ•°å­—ç¿»è½¬ç„¶åçœ‹æ˜¯å¦ç›¸ç­‰ã€‚ä¹Ÿå¯ä»¥æŠŠè¾¹ç•Œæƒ…å†µè€ƒè™‘è¿›è¡Œã€‚ public boolean isPalindrome(int x) { if (x Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. é›†ä½“æ€è·¯ï¼š é‡‡ç”¨äº†å‚ç›´å¯¹æ¯”æ³•ã€‚æ¯”å¦‚ï¼š s1 = 'flower' s2 = 'flow' s3 = 'flight' æˆ‘ä»¬ç¬¬ä¸€å±‚å¾ªç¯æ˜¯è¡¨ç¤ºå½“å‰stringçš„index, i = 0; ç„¶åå¾—åˆ°ç¬¬ä¸€ä¸ªstringçš„ç¬¬iä¸ªchar ç¬¬äºŒä¸ªå¾ªç¯å¼ä¸ºäº†å’Œå‰©ä½™çš„stringæ¯”å¯¹ï¼Œ å¦‚æœiçš„å¤§å°ç­‰äºå½“å‰stringçš„é•¿åº¦ä¹Ÿå°±æ„å‘³ç€é‡åˆ°äº†ç»“æŸç‚¹ï¼Œæ¯”å¦‚å½“i=3çš„æ—¶å€™ï¼Œi = s2.lengthï¼Œä¹Ÿå°±æ„å‘³ç€æœ‰ç»“æŸç‚¹äº†ã€‚ c != strs[j].charAt(i) è¿™å°±è¯­å¥æ˜¯ä¸ºäº†åˆ¤æ–­å½“å‰stringçš„ç¬¬iä¸ªcharæ˜¯å¦å’Œç¬¬ä¸€ä¸ªç›¸ç­‰ï¼Œå¦‚æœä¸æƒ³å½“ä¹Ÿå°±æ„å‘³ç€å¯ä»¥è¿”å›iä¹‹å‰çš„æ•°æ® æœ€åä¸€è¡Œæ„å‘³ç€strs[0]æ˜¯æœ€çŸ­çš„å­—ç¬¦ä¸²ï¼Œè€Œä¸”strs[0]æ˜¯comm prefix public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; for (int i = 0; i ä¹Ÿå¯ä»¥è¯•ç€å¾—åˆ°æœ€çŸ­çš„stringï¼Œç„¶åè¿›è¡Œå¾ªç¯ï¼Œæ€è·¯å·®ä¸å¤šï¼š è¿™ç§æƒ…å†µå…¶å®æ²¡ä»€ä¹ˆå¿…è¦ï¼Œå› ä¸ºå¯èƒ½æ²¡å¾ªç¯ç»“æŸå°±returnäº†ã€‚ public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; int min = Integer.MAX_VALUE; int index = -1; // get the shortest string length for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/11/":{"url":"codes/11/","title":"11. Container With Most Water","keywords":"","body":"Container With Most Water Container With Most Water æœ¬æ¥è§‰å¾—æ˜¯è¦ç”¨åŠ¨æ€è§„åˆ’ï¼Œå¯æ˜¯çœ‹äº†å¤§ä½¬çš„ä»£ç å’Œideaç¬é—´è§‰å¾—è‡ªå·±çš„æ€è·¯æ˜¯é”™çš„ã€‚è¿™ä¸ªé¢˜å…¶å®å°±æ˜¯å˜ç›¸çš„æ±‚æœ€å¤§é¢ç§¯ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“é•¿æ–¹ä½“çš„é¢ç§¯æ˜¯é•¿*é«˜ï¼Œåœ¨éå†è¿™ä¸ªlistçš„æ—¶å€™é•¿åº¦æ˜¯ä¸€ç›´åœ¨å‡å°çš„ï¼Œå¦‚æœé•¿åº¦å˜å°æˆ‘ä»¬åªæœ‰æ‰¾åˆ°æ›´å¤§çš„é«˜åº¦æ‰èƒ½ä½¿é¢ç§¯æœ€å¤§ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä»ä¸¤å¤´åŒæ—¶å¼€å§‹éå†ï¼Œå¦‚æœleft é‚£ä¹ˆleftå‘å·¦ç§»ï¼Œå› ä¸ºæˆ‘ä»¬è¦æ‰¾åˆ°higher heightï¼Œå¦‚æœleft >= right rightå‘å·¦ç§»å°±è¡Œäº†ã€‚è¿™æ ·å°±ä¼šæ‰¾åˆ°æœ€å¤§çš„areaã€‚ psï¼šä¸æƒ³æƒ³å¤ªå¤æ‚ï¼Œè¯•ç€ä»æœ€åŸºæœ¬çš„ä¿¡æ¯å»æ¨æ–­ï¼Œæ¯”å¦‚è¿™ä¸ªé¢ç§¯ï¼Œå¦‚æœä¸€ä¸ªå˜é‡å˜ä¸‹ï¼Œé‚£å¦ä¸€ä¸ªå˜é‡åªæœ‰å˜å¤§æ‰èƒ½æ‰¾åˆ°æœ€å¤§çš„ã€‚ï¼ˆğŸ˜å­¦ä¹ åˆ°äº†ï¼‰ public int maxArea(int[] height) { int max = 0; int l = 0, r = height.length-1; while (l powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/13/":{"url":"codes/13/","title":"13. Roman to Integer","keywords":"","body":"Roman to Integer Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: \"III\" Output: 3 Example 2: Input: \"IV\" Output: 4 Example 3: Input: \"IX\" Output: 9 Example 4: Input: \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. å¥½åƒæ²¡ä»€ä¹ˆå¥½è¯´çš„å°±æ˜¯ç®€å•çš„å­—ç¬¦ä¸²æ“ä½œè€Œå·²ï¼š public int romanToInt(String s) { Map map = new HashMap<>(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int res = 0; for (int i = 0; i 0) { if (s.charAt(i-1) == 'I') res += map.get(c) - 2; else res += map.get(c); } else res += map.get(c); } else if (c == 'L' || c == 'C') { if (i > 0) { if (s.charAt(i-1) == 'X') res += map.get(c) - 20; else res += map.get(c); } else res += map.get(c); } else if (c == 'D' || c == 'M') { if (i > 0) { if (s.charAt(i-1) == 'C') res += map.get(c) - 200; else res += map.get(c); } else res += map.get(c); } else { res += map.get(c); } } return res; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/14/":{"url":"codes/14/","title":"14. Longest Common Prefix","keywords":"","body":"Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. é›†ä½“æ€è·¯ï¼š é‡‡ç”¨äº†å‚ç›´å¯¹æ¯”æ³•ã€‚æ¯”å¦‚ï¼š s1 = 'flower' s2 = 'flow' s3 = 'flight' æˆ‘ä»¬ç¬¬ä¸€å±‚å¾ªç¯æ˜¯è¡¨ç¤ºå½“å‰stringçš„index, i = 0; ç„¶åå¾—åˆ°ç¬¬ä¸€ä¸ªstringçš„ç¬¬iä¸ªchar ç¬¬äºŒä¸ªå¾ªç¯å¼ä¸ºäº†å’Œå‰©ä½™çš„stringæ¯”å¯¹ï¼Œ å¦‚æœiçš„å¤§å°ç­‰äºå½“å‰stringçš„é•¿åº¦ä¹Ÿå°±æ„å‘³ç€é‡åˆ°äº†ç»“æŸç‚¹ï¼Œæ¯”å¦‚å½“i=3çš„æ—¶å€™ï¼Œi = s2.lengthï¼Œä¹Ÿå°±æ„å‘³ç€æœ‰ç»“æŸç‚¹äº†ã€‚ c != strs[j].charAt(i) è¿™å°±è¯­å¥æ˜¯ä¸ºäº†åˆ¤æ–­å½“å‰stringçš„ç¬¬iä¸ªcharæ˜¯å¦å’Œç¬¬ä¸€ä¸ªç›¸ç­‰ï¼Œå¦‚æœä¸æƒ³å½“ä¹Ÿå°±æ„å‘³ç€å¯ä»¥è¿”å›iä¹‹å‰çš„æ•°æ® æœ€åä¸€è¡Œæ„å‘³ç€strs[0]æ˜¯æœ€çŸ­çš„å­—ç¬¦ä¸²ï¼Œè€Œä¸”strs[0]æ˜¯comm prefix public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; for (int i = 0; i ä¹Ÿå¯ä»¥è¯•ç€å¾—åˆ°æœ€çŸ­çš„stringï¼Œç„¶åè¿›è¡Œå¾ªç¯ï¼Œæ€è·¯å·®ä¸å¤šï¼š è¿™ç§æƒ…å†µå…¶å®æ²¡ä»€ä¹ˆå¿…è¦ï¼Œå› ä¸ºå¯èƒ½æ²¡å¾ªç¯ç»“æŸå°±returnäº†ã€‚ public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; int min = Integer.MAX_VALUE; int index = -1; // get the shortest string length for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/17/":{"url":"codes/17/","title":"17. Letter Combinations of a Phone Number","keywords":"","body":"Letter Combinations of a Phone Number Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. æ€è·¯1ï¼š æ¯ä¸ªæ•°å­—ä»£è¡¨å‡ ä¸ªç›¸å¯¹åº”çš„æ•°æ®ï¼ŒæŠŠè¿™äº›ä»£è¡¨çš„æ•°æ®è¿›è¡Œæ’åˆ—ç»„åˆã€‚è¿™ä¸ªç¬¬ä¸€ä¸ªæƒ³åˆ°çš„å°±æ˜¯loopï¼Œé€å±‚é€’è¿›ï¼Œå› ä¸ºå¦‚æœæ˜¯ä¸‰ä¸ªæ•°å­—çš„è¯ï¼Œå°±æ˜¯åªç»„åˆæˆä¸‰ä¸ªå­—æ¯çš„stringï¼Œå¯ä»¥å…ˆæŠŠ1ï¼Œ2ç»„åˆå¾—åˆ°çš„ç»“æœå»å’Œ3ç»„åˆã€‚è¿™æ ·å°±è¡Œäº†ï¼Œè¿˜æœ‰åˆ«çš„ç®—æ³•ã€‚ import java.util.*; public class LetterCombinationsofaPhoneNumber { private List letterCombinations(String digits) { List result = new LinkedList<>(); HashMap maps = new HashMap<>(); maps.put('2', \"abc\"); maps.put('3', \"def\"); maps.put('4', \"ghi\"); maps.put('5', \"jkl\"); maps.put('6', \"mno\"); maps.put('7', \"pqrs\"); maps.put('8', \"tuv\"); maps.put('9', \"wyxz\"); // å…ˆå®éªŒä¸€ä¸‹ç›¸ä¹˜çš„åŠæ³•ï¼Œå› ä¸ºè¿˜æœ‰å¾ˆå¤šå¥½çš„åŠæ³•ï¼Œä¸€ä¼šæ…¢æ…¢çœ‹ for (int i = 0; i (Arrays.asList(str.split(\"\")))); } return result; } private List mul(List s1, List s2) { if (s1.size() == 0 && s2.size() != 0) { return s2; } if (s1.size() != 0 && s2.size() == 0) { return s1; } List result = new LinkedList<>(); for (String value : s1) { for (String s : s2) { result.add(value + s); } } return result; } public static void main(String[] args) { LetterCombinationsofaPhoneNumber l = new LetterCombinationsofaPhoneNumber(); String str = \"23\"; List res = l.letterCombinations(str); for (String s : res) { System.out.println(s); } } } æ€è·¯2ï¼š æƒ³å­¦ä¹ ä¸€ä¸‹dfsçš„ç®—æ³•ã€‚ã€‚ã€‚å­¦ä¹ ä½¿ç”¨dfså’Œé€’å½’çš„æ–¹æ³•ï¼Œè¿™ä¸ªç®—æ³•çš„æ€è·¯å°±æ˜¯ç›´æ¥è®¿é—®åˆ°æœ€åº•å±‚çš„strï¼Œç„¶åéå†æœ€åº•å±‚çš„listï¼Œéå†å®Œä¹‹åè¿”å›åˆ°ä¸Šä¸€å±‚ï¼Œç„¶åå¯¹ä¸Šä¸€å±‚è¿›è¡Œéå†ï¼ŒåŒæ—¶è¿˜ä¼šä½¿ç”¨åˆ°æœ€åº•å±‚çš„å…ƒç´ ã€‚ã€‚ã€‚é€’å½’æœ‰ç‚¹ç»•ã€‚ã€‚ private List letterCombinations(String digits) { List result = new LinkedList<>(); if (digits == null || digits.length() == 0) return result; HashMap maps = new HashMap<>(); maps.put('2', \"abc\"); maps.put('3', \"def\"); maps.put('4', \"ghi\"); maps.put('5', \"jkl\"); maps.put('6', \"mno\"); maps.put('7', \"pqrs\"); maps.put('8', \"tuv\"); maps.put('9', \"wyxz\"); dfs(digits, 0, \"\", result, maps); return result; } public void dfs(String digits, int index, String temp, List res, HashMap maps) { if (index == digits.length()) { res.add(temp); return; } String t = maps.get(digits.charAt(index)); for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/19/":{"url":"codes/19/","title":"19. Remove Nth Node From End of List","keywords":"","body":"Remove Nth Node From End of List Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note: Given n will always be valid. Follow up: Could you do this in one pass? è§£æï¼š é¢˜æ„å°±æ˜¯åˆ é™¤å€’æ•°ç¬¬Nçš„èŠ‚ç‚¹ã€‚è¿™ä¸ªå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•æ¥è§£å†³ï¼Œå…ˆè®©å¿«çš„æŒ‡é’ˆç§»åŠ¨nä¸ªnodeï¼Œç„¶åæ…¢çš„æŒ‡é’ˆå¼€å§‹ç§»åŠ¨ã€‚è¿™æ ·å½“å¿«çš„æŒ‡é’ˆä¸ºnullçš„æ—¶å€™ï¼Œæ…¢çš„æŒ‡é’ˆåˆšå¥½å°±æ˜¯è¦åˆ é™¤çš„èŠ‚ç‚¹ã€‚ å…¶å®å¯ä»¥å½“fast.next == nullçš„æ—¶å€™å°±åœæ­¢ã€‚è¿™æ ·slow.next = slow.next.nextæ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºæˆ‘çš„ä»£ç ç”¨äº†curræ¥åˆ¤æ–­æ˜¯å¦ä¸ºnullï¼ˆåˆ é™¤çš„å…ƒç´ æ˜¯ä¸æ˜¯headï¼‰ public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode removeNthFromEnd(ListNode head, int n) { ListNode curr = null; ListNode slow = head; ListNode fast = head; while (fast != null) { if (n powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/20/":{"url":"codes/20/","title":"20. Valid Parentheses","keywords":"","body":"Valid Parentheses valid parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: \"()\" Output: true Example 2: Input: \"()[]{}\" Output: true Example 3: Input: \"(]\" Output: false Example 4: Input: \"([)]\" Output: false Example 5: Input: \"{[]}\" Output: true è§£é¢˜æ€è·¯ï¼š è¿™ä¸ªé¢˜æˆ‘ä½¿ç”¨äº†stackï¼ˆæ ˆï¼‰çš„æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚stackæ˜¯ä¸€ç§å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„ï¼Œæ‰€ä»¥æ›´åŠ é€‚åˆè¿™ç§é—®é¢˜ã€‚ æˆ‘ä»¬å…ˆæ¥åˆå§‹åŒ–ä¸€ä¸ªHashMapæ¥å­˜ç›¸å¯¹åº”çš„æ‹¬å· å…ˆåˆ¤æ–­è¯¥HashMapæ˜¯å¦å­˜åœ¨è¯¥å·¦æ‹¬å·ï¼Œå¦‚æœå­˜åœ¨å°±æŠŠå·¦æ‹¬å·pushåˆ°stacké‡Œé¢ï¼Œ å¦‚æœä¸å­˜åœ¨å…ˆåˆ¤æ–­stackæ˜¯å¦æœ‰æ•°æ®ï¼ˆå› ä¸ºä¸å­˜åœ¨çš„æƒ…å†µåªæœ‰è¯¥å­—ç¬¦æ˜¯å³æ‹¬å·çš„æƒ…å†µï¼‰ ç„¶åæ ¹æ®stack popå‡ºæ¥çš„ç»“æœåœ¨HashMapæ‰¾åˆ°ç›¸å¯¹åº”çš„å³æ‹¬å·ï¼Œç„¶ååˆ¤æ–­è¯¥å­—ç¬¦å’ŒHashMapé‡Œé¢çš„å³æ‹¬å·æ˜¯å¦åŒ¹é…ã€‚ public boolean isValid(String s) { Stack stack = new Stack(); Map map = new HashMap<>(); map.put('[', ']'); map.put('(', ')'); map.put('{', '}'); for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/21/":{"url":"codes/21/","title":"21. Merge Two Sorted Lists","keywords":"","body":"Merge Two Sorted Lists Merge two sorted lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 è¿™ä¸ªå¥½åƒæ²¡ä»€ä¹ˆè¯´çš„ï¼Œå°±ç›´æ¥å¯¹æ¯”å¤§å°ç„¶åmergeåœ¨ä¸€èµ·å°±è¡Œ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode head = new ListNode(); ListNode temp = head; while (l1 != null && l2 != null) { temp.next = new ListNode(); temp = temp.next; if (l1.val powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/22/":{"url":"codes/22/","title":"22. Generate Parentheses","keywords":"","body":"Generate Parentheses Generate Parentheses Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] è¿™ä¸ªé¢˜ä¸»è¦æ˜¯ä½¿ç”¨äº†é€’å½’çš„æ–¹æ³•ï¼Œé¦–å…ˆä¸€ç›´æ·»åŠ (ï¼Œç›´åˆ°æœ€æ·±åº¦nï¼Œå¦‚æœè¶…è¿‡nè‚¯å®šä¸åˆæ³•äº†ï¼Œå› ä¸ºå·¦å³æ‹¬å·æ˜¯ç›¸å¯¹åº”çš„ã€‚å½“å·¦æ‹¬å·è¾¾åˆ°æœ€æ·±åº¦çš„æ—¶å€™ï¼Œå¼€å§‹é€’å½’å³æ‹¬å·ï¼ŒåŒæ—¶å³æ‹¬å·çš„æ•°é‡åº”è¯¥å°äºå·¦æ‹¬å·ã€‚ä¼ªä»£ç : def find(left, right, depth, str, res): if str length == depth * 2: res.add(str) if left Javaä»£ç ï¼š import java.util.LinkedList; import java.util.List; public class GenerateParentheses { public List generateParenthesis(int n) { List list = new LinkedList<>(); if (n == 0) return list; dfs(0,0,n,list, \"\"); return list; } public void dfs(int close, int open, int depth, List res, String str) { if (str.length() == depth * 2) { res.add(str); return; } if (open res = ge.generateParenthesis(4); for (String str : res) { System.out.println(str); } } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/24/":{"url":"codes/24/","title":"24. Swap Nodes in Pairs","keywords":"","body":"Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list's nodes, only nodes itself may be changed. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. äº¤æ¢nodeçš„ä½ç½®ï¼Œä¸¤ä¸¤äº¤æ¢ï¼Œè¦è€ƒè™‘çš„é—®é¢˜æœ‰ä¸¤ä¸ªï¼Œlisté•¿åº¦ä¸ºoddçš„æ—¶å€™æ€ä¹ˆåŠï¼Œæ€ä¹ˆå»è¿›è¡Œloopã€‚ public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode curr = head; head = curr.next; ListNode last = null; while (curr != null && curr.next != null) { ListNode next = curr.next; ListNode temp = next.next; if (last != null) { last.next = curr.next; } next.next = curr; curr.next = null; last = curr; curr = temp; } if (curr != null && curr.next == null) last.next = curr; return head; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/26/":{"url":"codes/26/","title":"26. Remove Duplicates from Sorted Array","keywords":"","body":"Remove Duplicates from Sorted Array Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length. æœ€è·å–é•¿åº¦çš„åŒæ—¶éœ€è¦å¯¹arrayå†…éƒ¨æ•°æ®è¿›è¡Œä¿®æ”¹ï¼š é€šè¿‡æ¯æ¬¡è®°å½•numï¼Œå¦‚æœä¸ç›¸åŒçš„è¯ï¼Œå¯¹æ•°ç»„çš„å…¶å®ä½ç½®å¼€å§‹ä¿®æ”¹ï¼Œç„¶åcurræ˜¯æ­£åœ¨ä¿®æ”¹çš„indexã€‚ï¼ˆä¹Ÿä¼šéšç€iå¢åŠ è€Œå¢åŠ ï¼Œå¦‚æœæ‰€æœ‰æ•°å­—éƒ½ä¸ä¸€æ ·ï¼‰åªä¸è¿‡æ˜¯é‡æ–°èµ‹å€¼äº†ä¸€æ¬¡è€Œå·²ã€‚ public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int dup = nums[0]; int curr = 1; for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/27/":{"url":"codes/27/","title":"27. Remove Element","keywords":"","body":"Remove Element Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. è¿™ä¸ªå’Œå‰é¢é‚£ä¸ªremove duplicate numberæ˜¯ä¸€ä¸ªæ€è·¯ï¼š è¿™ä¸ªç®—æ³•å¾ˆç®€å•ï¼Œä½†æ˜¯æ•ˆç‡è´¼é«˜ã€‚å…¶å®å¾ˆå¥½ç†è§£ï¼Œå°±æ˜¯å½“è¿™ä¸ªæ•°å­—ä¸ç­‰äºvalçš„æ—¶å€™ï¼Œä¼šç”¨ä¹‹å‰çš„currï¼ˆéé‡å¤çš„æ•°å­—åæ ‡ï¼‰æ¥æ›¿æ¢å½“å‰çš„valã€‚ 3, 2, 2, 3 & val = 2 curr = 0 when i = 0, val != nums[i] num[curr++] = nums[i] -> nums[0] = nums[0] and curr = 1 now when i = 1, val == nums[i] continue when i = 2, val == nums[i] continue when i = 3, val != nums[i] num[curr++] = nums[i] -> nums[1] = nums[3] and curr = 2 now so nums = 3, 3, 2, 3 and curr = 2, we do not care index > 1 values, so we done public int removeElement(int[] nums, int val) { int curr = 0; for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/28/":{"url":"codes/28/","title":"28. Implement strStr()","keywords":"","body":"Implement strStr() Implement strStr() Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 è¿”å›è¦æ±‚çš„æ˜¯indexï¼Œæˆ‘è¿˜ä»¥ä¸ºæ˜¯é•¿åº¦ä¸€åº¦è¿·èŒ«ä¸ºå•¥ä¸å¯¹o(â•¥ï¹â•¥)oï¼Œä¸€ä¸ªforå°±èƒ½è§£å†³çš„é—®é¢˜ï¼Œæˆ‘ä»¬å…ˆå»needleçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶ååœ¨å¾ªç¯haystackçš„æ—¶å€™å¦‚æœé‡Œé¢æœ‰å­—ç¬¦å’Œneedleçš„ç¬¬ä¸€ä¸ªå­—ç¬¦åŒ¹é…äº†å°±ç”¨substringæ¥æ¥å–ç›¸å¯¹åº”çš„é•¿åº¦ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦å’Œneedleç›¸ç­‰ï¼ˆéœ€è¦åˆ¤æ–­indexçš„é•¿åº¦æ˜¯ä¸æ˜¯è¶…è¿‡äº†haystackçš„é•¿åº¦ï¼‰ã€‚ public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; char c = needle.charAt(0); for (int i = 0; i haystack.length()) return -1; if (haystack.substring(i, i+needle.length()).equals(needle)) return i; } } return -1; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/33/":{"url":"codes/33/","title":"33. Search in Rotated Sorted Array","keywords":"","body":"Search in Rotated Sorted Array Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 æ€è·¯ï¼Œå…ˆæŠŠåˆ†å‰²ç‚¹æ‰¾åˆ°ï¼Œå°±æ˜¯ä»å“ªä¸ªåœ°æ–¹æ¥åšçš„rotatedï¼Œæ¯”å¦‚[4,5,6,7,0,1,2]é‚£ä¹ˆåˆ†å‰²ç‚¹å°±æ˜¯index = 3çš„æ—¶å€™ï¼Œå› ä¸ºæ˜¯ä¸€ä¸ªé€’å¢çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥æƒ³æ‰¾åˆ°åˆ†å‰²ç‚¹å°±å¾ˆç®€å•ã€‚å†æ ¹æ®åˆ†å‰²ç‚¹åšä¸€ä¸ªbinary searchï¼Œå…ˆåˆ†æå‰åŠæ®µï¼Œå¦‚æœèƒ½æ‰¾åˆ°ç»“æœå°±returnï¼Œå¦‚æœæ‰¾ä¸åˆ°å°±æ‰¾ååŠæ®µçš„å†…å®¹ã€‚ public class SearchRotatedArray { public int search(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length - 1; int num = nums[0]; int mid = -1; for (int i = 1; i target) { right = temp_mid - 1; } else { left = temp_mid + 1; } } return -1; } public static void main(String[] args) { int[] nums = new int[] {4,5,6,7,0,1,2}; SearchRotatedArray s = new SearchRotatedArray(); int x = s.search(nums, 0); System.out.println(x); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/34/":{"url":"codes/34/","title":"34. Find First and Last Position of Element in Sorted Array","keywords":"","body":"Find First and Last Position of Element in Sorted Array Find First and Last Position of Element in Sorted Array Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] ä½¿ç”¨äº†ä¸€ä¸ª~äºŒåˆ†æŸ¥æ‰¾æ³•~ï¼Œå¤´å°¾éå†æ³•ï¼Œä¸è¿‡è²Œä¼¼æ—¶é—´å¤æ‚åº¦æœ‰ç‚¹é«˜ã€‚ã€‚æ²¡æœ‰åˆ«äººé‚£ä¹ˆå¿«ï¼ŒèŠ±äº†1msæ‰é€šè¿‡ã€‚ä¸€ä¼šå‡†å¤‡å»çœ‹çœ‹å¤§ç¥çš„æ€è·¯ï¼Œçœ‹çœ‹æœ‰æ²¡æœ‰å¥½çš„ideaã€‚ç¬¬23-28è¡Œçš„ä¸»è¦ä½œç”¨æ˜¯è€ƒè™‘åˆ°èµ·å§‹ä½ç½®å’Œç»“æŸä½ç½®åœ¨åŒä¸€ä¸ªåœ°æ–¹ï¼Œå½“å…¶ä¸­æœ‰ä»»ä½•ä¸€ä¸ªæ•°å­—ä¸æ˜¯-1çš„æ—¶å€™ï¼Œä»£è¡¨å·²ç»æ‰¾åˆ°è¿™ä¸ªæ•°å­—äº†ï¼Œä½†æ˜¯head==tailçš„æ—¶å€™å°±ä¼šç»“æŸå¾ªç¯äº†ï¼Œæ‰€ä»¥ä¼šè¿›è¡Œä¸€ä¸ªåˆ¤æ–­ã€‚ public int[] searchRange(int[] nums, int target) { if (nums.length == 0) return new int[] {-1, -1}; if (nums.length == 1)return (nums[0] == target) ? new int[] {0, 0}: new int[]{-1, -1}; int head = 0, tail = nums.length - 1; int[] range = new int[] {-1, -1}; while (head target) tail --; } if (head == tail) { if (range[0] == -1 || range[1] == -1) { range[0] = Math.max(range[0], range[1]); range[1] = Math.max(range[0], range[1]); } } return range; } åˆšå»çœ‹äº†ä¸€ä¸‹discussioné‡Œé¢ï¼Œç„¶åå‘ç°è‡ªå·±å†™çš„äºŒåˆ†æŸ¥æ‰¾ä¸å«äºŒåˆ†æŸ¥æ‰¾ï¼Œåªèƒ½ç®—æ˜¯ä¸€ä¸ªä¸¤å¤´éå†çš„å¾ªç¯ã€‚ç„¶åæ ¹æ®äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•å†™äº†ä¸€ä»½ï¼š public int[] searchRange(int[] nums, int target) { if (nums.length == 0) return new int[] {-1, -1}; int head = 0, tail = nums.length - 1; int[] range = new int[] {-1, -1}; while (head target) { tail = mid - 1; } else if (nums[mid] = mid) { if (nums[tail] == target) { range[1] = tail; break; } tail --; } break; } } return range; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/35/":{"url":"codes/35/","title":"35. Search Insert Position","keywords":"","body":"Search insert position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 å°±æ˜¯æ‰¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œç„¶åè¿”å›ç›¸å¯¹åº”çš„indexï¼Œæ²¡ä»€ä¹ˆéš¾åº¦ï¼š public int searchInsert(int[] nums, int target) { for (int i = 0; i = target) return i; } return nums.length; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/39/":{"url":"codes/39/","title":"39. Combination Sum","keywords":"","body":"39. Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] è¿™ä¸ªå¯ä»¥ä½¿ç”¨åˆ°å›æº¯ç®—æ³•çš„æ€æƒ³ï¼Œä»i - nums.lengthï¼Œæ¯ä¸ªéƒ½ä¼šé‡å¤ï¼Œæ¯”å¦‚å½“i=0çš„æ—¶å€™ï¼š 2,2,2,2 2,2,2,3 2,2,2,6 2,2,2,7 2,2,3 2,2,6 2,2,7 2,2 2,3 .... è¿™æ ·çš„ä¸€ä¸ªè§„å¾‹ã€‚ import java.util.*; public class CombinationSum { public List> combinationSum(int[] candidates, int target) { List> res = new LinkedList<>(); back_tracking(res, new ArrayList<>(), target, candidates, 0); return res; } // å›æº¯ç®—æ³• public void back_tracking(List> res, List temp, int target, int[] nums, int index) { if (target (temp)); else { for (int i = index; i > res = cs.combinationSum(nums, 7); for (List l : res) { System.out.println(Arrays.toString(l.toArray())); } } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/46/":{"url":"codes/46/","title":"46. Permutations","keywords":"","body":"46. Permutations Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] ä¹Ÿæ˜¯ä¸€ä¸ªå›æº¯ç®—æ³•ï¼Œéœ€è¦åŠ ä¸€ä¸ªé¢å¤–çš„æ¡ä»¶ï¼Œä¸èƒ½é‡å¤ï¼Œä¸è¿‡ä¹Ÿæ˜¯å›æº¯ç®—æ³•çš„ä¸€ä¸ªå¥—è·¯ã€‚ä¼ªä»£ç ï¼š result = [] def backtrack(path, select_list): if condition: result.add(path) return for list in select_list: make a select backtrack(path, select_list) drawback select import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.List; public class Permutations { public List> permute(int[] nums) { List> res = new LinkedList<>(); back_track(res, new ArrayList<>(), nums); return res; } public void back_track(List> res, List temp, int[] nums) { if (temp.size() == nums.length) { res.add(new ArrayList<>(temp)); return; } for (int i = 0; i > res = p.permute(nums); for (List l : res) { System.out.println(Arrays.toString(l.toArray())); } } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/48/":{"url":"codes/48/","title":"48. Rotate Image","keywords":"","body":"48. Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] emmmè¿™ä¸ªé¢˜æˆ‘ä½¿ç”¨äº†å¦ä¸€ä¸ªdouble arrayåº”è¯¥æ˜¯ä¸å’‹å¯¹ import java.util.Arrays; public class RotateImage { public void rotate(int[][] matrix) { int[][] res = new int[matrix.length][matrix[0].length]; for (int i = 0; i = 0; j --) { res[i][index++] = matrix[j][i]; } } for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/49/":{"url":"codes/49/","title":"49. Group Anagrams","keywords":"","body":"Group Anagrams Group Anagrams Given an array of strings, group anagrams together. Example: Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Output: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] Note: All inputs will be in lowercase. The order of your output does not matter. æŠŠä½¿ç”¨åŒä¸€ä¸ªå­—ç¬¦æ„æˆçš„stringæ”¾åˆ°ä¸€èµ·ã€‚é¦–å…ˆç¡®å®šæ˜¯ä½¿ç”¨HashMapï¼Œåœ¨éå†æ•°ç»„çš„æ—¶å€™å¯¹æ¯ä¸€ä¸ªstringå…ˆè¿›è¡Œsortä¸€ä¸‹ï¼ˆæˆ–è€…ç”¨hashçš„æ–¹æ³•ï¼Œæˆ‘ä¸‹é¢æœ‰å†™ï¼‰ï¼Œæ’è¿‡åºçš„stringå½“åškeyï¼Œå¦‚æœè¿˜æœ‰ç›¸åŒçš„æ•°æ®å°±æ¥ç€æ·»åŠ ï¼Œå¦‚æœæ²¡æœ‰è¯¥keyå°±åˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„ã€‚ import java.util.*; public class GroupAnagrams { public List> groupAnagrams(String[] strs) { List> list = new LinkedList<>(); HashMap> hashMap = new HashMap<>(); for (String str : strs) { hash(str); char[] temp_char = str.toCharArray(); Arrays.sort(temp_char); String key = Arrays.toString(temp_char).toString(); if (hashMap.containsKey(key)) { hashMap.get(key).add(str); } else { List temp = new LinkedList<>(); temp.add(str); hashMap.put(key, temp); } } for (String key : hashMap.keySet()) { list.add(hashMap.get(key)); } return list; } public void hash(String str) { int hash = 31; for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/50/":{"url":"codes/50/","title":"50. Pow(x, n)","keywords":"","body":"Pow(x, n) Pow(x, n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 x n is a 32-bit signed integer, within the range [âˆ’231, 231 âˆ’ 1] è¿™ä¸ªå°±æ˜¯ç®€å•çš„æ±‚ä¸€ä¸‹å¹³æ–¹ï¼Œç„¶åç»™ä¿ç•™5ä½å°æ•°å°±è¡Œäº†ï¼Œç”¨Pythonç®€å•çš„å†™äº†ä¸€æ³¢ class Solution(object): def myPow(self, x, n): \"\"\" :type x: float :type n: int :rtype: float \"\"\" x = x**n x = 2**32-1 if x >= 2**32-1 else x x = -2**32 if x powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/53/":{"url":"codes/53/","title":"53. Maximum Subarray","keywords":"","body":"Maximum Subarray Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. é¢˜æ„è§£æï¼šæ‰¾åˆ°å’Œæœ€å¤§çš„å­åºåˆ—ã€‚ ç®—æ³•è§£æï¼š å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥åšã€‚åˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„é•¿åº¦å’ŒåŸæ•°ç»„ä¸€æ ·ï¼Œå¦‚æœi-1çš„æ•°å­—å°äºé›¶å°±è¡¨ç¤ºè¿™å°±ä¸ç”¨éœ€è¦è¿›è¡ŒåŠ å’Œï¼Œå› ä¸ºåŠ è´Ÿæ•°å°±æ˜¯åœ¨å‡å°ï¼Œç„¶åæŠŠiå°±è¡Œèµ‹å€¼ã€‚åœ¨æ¯æ¬¡å¾ªç¯çš„æ—¶å€™æ‰¾åˆ°æœ€å¤§çš„å€¼å°±è¡Œï¼ˆmax,dp[i]å–æœ€å¤§çš„ï¼‰ã€‚dp[i]å­˜çš„ç»“æœï¼šå¦‚æœdp[i-1]å°äºé›¶é‚£å°±æ˜¯æœ¬èº«ï¼Œä¸ç„¶å°±æ˜¯dp[i-1] + num[i]åŠ ä¸Šå½“å‰æ•°å­—ã€‚ public int maxSubArray(int[] nums) { int max = nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i çœ‹äº†å¤§ä½¬çš„æ€è·¯ä¹‹åå‘ç°äº†æ–°å¤©åœ°ï¼Œå¯ä»¥èŠ‚çœä¸€äº›å†…å­˜ç©ºé—´ï¼Œé™ä½ç©ºé—´å¤æ‚åº¦ï¼š åªéœ€è¦ä¸¤ä¸ªç©ºé—´çš„ä½ç½®å°±è¡Œäº†ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦iå’Œi-1è¿™ä¸¤ä¸ªå‚æ•°ã€‚ public int maxSubArray(int[] nums) { int max = nums[0]; int[] temp = new int[2]; temp[0] = nums[0]; for (int i = 1; i = 0) { temp[i % 2] = temp[(i-1) % 2] + nums[i]; max = Math.max(temp[i%2], max); } else { temp[i % 2] = nums[i]; } } return max; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/58/":{"url":"codes/58/","title":"58. Length of Last Word","keywords":"","body":"58. Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word (last word means the last appearing word if we loop from left to right) in the string. If the last word does not exist, return 0. Note: A word is defined as a maximal substring consisting of non-space characters only. Example: Input: \"Hello World\" Output: 5 ç›´æ¥splitç„¶åå–æœ€åä¸€ä¸ªï¼Œç„¶åç›´æ¥è®¡ç®—length public class LengthofLastWord { public int lengthOfLastWord(String s) { if (s.equals(\"\")) return 0; String[] res = s.split(\" \"); if (res.length == 0) return 0; return res[res.length - 1].length(); } public static void main(String[] args) { String r = \"Hello world\"; LengthofLastWord l = new LengthofLastWord(); System.out.println(l.lengthOfLastWord(r)); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/61/":{"url":"codes/61/","title":"61. Rotate List","keywords":"","body":"61. Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL åšæ³•ç¨å¾®è ¢äº†ä¸€ç‚¹ï¼Œæˆ‘æ˜¯é€šè¿‡å…ˆè®¡ç®—é“¾è¡¨çš„é•¿åº¦ï¼Œç„¶åæŠŠk = k % lengthè¿™æ ·å°±å¯ä»¥å¾—åˆ°ç›¸å¯¹é“¾è¡¨æ¥è¯´çš„ç¬¬å‡ ä½ã€‚ç„¶åéå†é“¾è¡¨ï¼Œå½“èŠ‚ç‚¹çš„indexç­‰äºkçš„æ—¶å€™å¼€å§‹æŠŠkä¹‹åçš„nodeæ”¾åˆ°é“¾è¡¨çš„èµ·å§‹ä½ç½®ã€‚è¿™æ ·å°±å®Œæˆäº†rotate listã€‚ public class RotateList { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode rotateRight(ListNode head, int k) { if (head == null || head.next == null || k == 0) return head; ListNode curr = head; int length = length(curr); k = length - (k % length); if(k == length) return head; ListNode rota = find_rota(curr, k); ListNode temp = rota; while (temp.next != null) { temp = temp.next; } temp.next = head; head = rota; return head; } public ListNode find_rota(ListNode curr, int k) { while (k > 1) { curr = curr.next; k --; } ListNode node = curr.next; curr.next = null; return node; } public int length(ListNode node) { int length = 0; while (node != null) { node = node.next; length ++; } return length; } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(3); // ListNode l4 = new ListNode(4); // ListNode l5 = new ListNode(5); l1.next = l2; l2.next = l3; // l3.next = l4; // l4.next = l5; RotateList r = new RotateList(); r.rotateRight(l1, 2); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/66/":{"url":"codes/66/","title":"66. Plus One","keywords":"","body":"Plus One Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. ä¸€ä¸ªæ•°å­¦çš„é—®é¢˜ï¼Œåœ¨æœ€åé¢åŠ 1ï¼Œç„¶åå¦‚æœå¤§äº10ï¼Œé‚£ä¹ˆå‰é¢çš„æ•°å­—å°±éœ€è¦åŠ ä¸€ã€‚å¯ä»¥ç›´æ¥ä¸ç”¨åˆ†ç±»æ¥è®¨è®ºï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸€ä¸ªå¾ªç¯index ï¼Œindex = nums.length - 1è¿™æ ·æˆ‘ä»¬ä»æœ€åé¢å¼€å§‹åŠ 1ï¼Œoverflowæ˜¯ç”¨æ¥åˆ¤æ–­æ˜¯å¦æº¢å‡ºï¼Œåœ¨å¾ªç¯é‡Œé¢å¦‚æœæ²¡æœ‰æº¢å‡ºï¼Œå°±è¡¨ç¤ºå‰é¢æ•°å­—åŠ ä¸€çš„ç»“æœä¸å¤§äº10ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥breakã€‚è¿˜æœ‰ä¸€ç§å¦‚æœå¾ªç¯ç»“æŸäº†ä¾ç„¶æº¢å‡ºäº†ï¼Œè¿™æ—¶å€™æˆ‘ä»¬éœ€è¦åœ¨arrayé‡Œé¢å¤šåŠ ä¸€ä¸ªæ•°å­—åœ¨æœ€å‰é¢ã€‚ import java.util.Arrays; import java.util.stream.IntStream; public class PlusOne { public int[] plusOne(int[] digits) { int lens = digits.length - 1; int[] nums = digits.clone(); int overflow = 0; nums[lens] += 1; while (lens != -1) { // every time plus one nums[lens] += overflow; overflow = nums[lens] / 10; if (nums[lens] > 9) nums[lens] %= 10; lens --; // å½“ä¸æº¢å‡ºçš„æ—¶å€™å°±å¯ä»¥breakäº†ï¼Œå› ä¸ºä¸ä¼šè¿›ä½äº† if (overflow == 0) break; } // å¦‚æœå¾ªç¯ç»“æŸè¿˜æº¢å‡ºï¼Œè¯´æ˜è¿˜éœ€è¦å¤šå¼€è¾Ÿä¸€ä¸ªå†…å­˜ä½ç½®ã€‚ if (overflow != 0) { nums = IntStream.concat(Arrays.stream(new int[] {1}), Arrays.stream(nums)).toArray(); } return nums; } public static void main(String[] args) { int[] nums = new int[] {8,9}; PlusOne p = new PlusOne(); int[] res = p.plusOne(nums); System.out.println(Arrays.toString(res)); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/70/":{"url":"codes/70/","title":"70. Climbing Stairs","keywords":"","body":"Climbing Stairs Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step è¿™æ˜¯ä¸€ä¸ªå¾ˆç»å…¸çš„åŠ¨æ€è§„åˆ’çš„é—®é¢˜ã€‚ä¸€æ¬¡å¯ä»¥èµ°ä¸€é˜¶æ¥¼æ¢¯æˆ–è€…ä¸¤é˜¶æ¥¼æ¢¯ã€‚åœ¨ç¬¬ä¸€å±‚çš„æ—¶å€™è‚¯å®šåªèƒ½ä¸Šä¸€é˜¶ï¼Œç¬¬äºŒå±‚çš„æ—¶å€™å¯ä»¥æ˜¯1+1ï¼ˆè¿ç»­èµ°ä¸¤ä¸ªä¸€é˜¶ï¼‰æˆ–è€…2ï¼ˆç›´æ¥ä¸¤é˜¶ï¼‰æ‰€ä»¥æ˜¯ä¸¤ç§æ–¹æ³•ï¼Œç¬¬ä¸‰å±‚çš„æ—¶å€™å¯ä»¥æ˜¯1+1+1, 1+2, 2+1ä¸‰ç§æ–¹æ³•ã€‚æ‰€ä»¥å¯ä»¥çœ‹å‡º$f(n)=f(n-1)+f(n-2)$çš„ç®—æ³•ã€‚ public int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; int[] array = new int[n]; array[0] = 1; array[1] = 2; for (int i = 2; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/80/":{"url":"codes/80/","title":"80. Remove Duplicates from Sorted Array II","keywords":"","body":"80. Remove Duplicates from Sorted Array II Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Solution ä¸€å¼€å§‹ç†è§£é”™äº†ï¼Œä»¥ä¸ºåªè¦è¿”å›æ•°é‡å°±è¡Œï¼Œåé¢å‘ç°è¿˜éœ€è¦é¢å¤–çš„ä¿®æ”¹å†…å­˜æ•°æ®ã€‚å…¶å®è¿™ä¸ªé¢˜å¾ˆç®€å•ï¼Œåªéœ€è¦ç”¨åˆ°åŒæŒ‡é’ˆå°±è¡Œï¼Œæˆ–è€…å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•ï¼Œæ„æ€éƒ½æ˜¯å·®ä¸å¤šçš„ã€‚idxæŒ‡é’ˆè´Ÿè´£å»éå†numsæ•°æ®ï¼Œs_idxè´Ÿè´£è®°å½•æ›´æ–°å¼€å§‹çš„åæ ‡ã€‚ class Solution { public: int removeDuplicates(vector& nums) { int idx = 0, s_idx = 0, val = 0, cnt = 0; while (idx powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/82/":{"url":"codes/82/","title":"82. Remove Duplicates from Sorted List II","keywords":"","body":"82. Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5 Example 2: Input: 1->1->1->2->3 Output: 2->3 è¿™ä¸ªç¬¬83çš„è¿›é˜¶ç‰ˆã€‚åªè¦æ˜¯æœ‰é‡å¤çš„nodeéƒ½éœ€è¦åˆ é™¤æ‰ã€‚æˆ‘ä»¬éœ€è¦æœ‰ä¸€ä¸ªnodeï¼ˆlastï¼‰æ¥è®°å½•ä¸Šä¸€ä¸ªè®¿é—®çš„nodeï¼Œä¸€ä¸ªnodeï¼ˆcurrï¼‰æ¥å¾ªç¯ã€‚å¦‚æœcurr.val == curr.next.valå°±ä»£è¡¨ç€æœ‰é‡å¤çš„nodeäº†ï¼Œè¿™æ—¶å€™æ‰¾åˆ°æ‰€æœ‰é‡å¤çš„nodeï¼Œç„¶åå¾—åˆ°æœ€åä¸€ä¸ªé‡å¤nodeçš„nextï¼Œç„¶åä½¿ç”¨lasté“¾æ¥å°±è¡Œï¼Œä½†æ˜¯lastéœ€è¦åˆ¤æ–­æ˜¯å¦æ˜¯nullï¼Œå¦‚æœæ˜¯nullçš„è¯éœ€è¦è€ƒè™‘åˆ°headçš„æƒ…å†µã€‚ public class RemoveDuplicatesfromSortedListII { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; ListNode last = null; ListNode curr = head; while (curr.next != null) { if (curr.val == curr.next.val) { ListNode node = different(curr); if (last == null) { head = node; } else { last.next = node; } curr = node; if (curr == null) break; continue; } else { last = curr; } curr = curr.next; } return head; } public ListNode different(ListNode node) { ListNode last = node; while (node.next != null) { if (node.val != node.next.val) { return node.next; } last = node; node = node.next; } // å› ä¸ºæ˜¯node.next != null æ‰€ä»¥éœ€è¦åˆ¤æ–­æœ€åä¸€ä¸ªnodeæ˜¯ä¸æ˜¯å’Œå‰é¢çš„ç›¸ç­‰ if (last.val == node.val) return null; return node; } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(2); ListNode l4 = new ListNode(2); // ListNode l5 = new ListNode(5); l1.next = l2; l2.next = l3; l3.next = l4; // l4.next = l5; RemoveDuplicatesfromSortedListII r = new RemoveDuplicatesfromSortedListII(); r.deleteDuplicates(l1); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/83/":{"url":"codes/83/","title":"83. Remove Duplicates from Sorted List","keywords":"","body":"83. Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2 Example 2: Input: 1->1->2->3->3 Output: 1->2->3 åœ¨å·²ç»sortedçš„é“¾è¡¨é‡Œé¢å»é™¤é‡å¤çš„å€¼ï¼Œå¯ä»¥ä½¿ç”¨è¿ä¸ªæŒ‡é’ˆæ¥å®Œæˆï¼Œcurræ¥å‰è¿›ï¼Œtempæ¥é“¾æ¥ä¸ä¸€æ ·çš„å€¼ã€‚å½“temp.val != curr.valçš„æ—¶å€™ä»£è¡¨ä¸­é—´å·²ç»çœç•¥äº†åŒç±»é¡¹ï¼Œæ‰€ä»¥ç›´æ¥è®¾ç½®temp.next = currç„¶åæŠŠcurrèµ‹å€¼ç»™tempï¼ˆtemp = currï¼‰ã€‚ public class RemoveDuplicatesfromSortedList { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; ListNode curr = head.next; ListNode temp = head; while (curr != null) { if (temp.val != curr.val) { temp.next = curr; temp = curr; } curr = curr.next; } temp.next = null; return head; } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(1); ListNode l3 = new ListNode(2); l1.next = l2; l2.next = l3; l3.next = null; RemoveDuplicatesfromSortedList re = new RemoveDuplicatesfromSortedList(); ListNode head = re.deleteDuplicates(l1); while (head != null) { System.out.println(head.val); head = head.next; } } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/88/":{"url":"codes/88/","title":"88. Merge Sorted Array","keywords":"","body":"Merge Sorted Array Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] è¿™æ˜¯æˆ‘ä»Šå¤©é€›ç‰›å®¢çš„æ—¶å€™å‘ç°çš„ä¸€é“é¢˜ï¼Œç„¶åæƒ³äº†ä¸€ä¸‹ï¼ŒæŒ‰ç…§æˆ‘ç°åœ¨çš„æ€æƒ³å¥½åƒåªçŸ¥é“ç›´æ¥mergeç„¶åsortã€‚è¿˜æœ‰ä¸€ç§å°±æ˜¯æ­£åºæ’å…¥ï¼Œä½†æ˜¯æ¯ä¸ªelementéƒ½éœ€è¦åç§»ä¸€ä½ï¼Œä½†æ˜¯è¿™æ ·çš„æ•ˆç‡å¤ªä½äº†ï¼Œçœ‹äº†ç½‘ä¸Šçš„å¤§ç¥çš„ideaä¹‹åå°±å‘ç°äº†æ–°å¤§é™†ã€‚å› ä¸ºè¿™ä¸ªlistæ˜¯æ‹è¿‡åºçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±çŸ¥é“äº†æœ€åä¸€ä¸ªå…ƒç´ è‚¯å®šæ˜¯æœ€å¤§ã€‚é‚£ä¹ˆæˆ‘ä»¬ä¸ºä»€ä¹ˆä¸ä»åé¢å¾€å‰é¢å¾ªç¯å‘¢ï¼Œè¿™æ ·ä¸éœ€è¦å…ƒç´ ä»¥ä¸ºï¼Œåªéœ€è¦ç›´æ¥èµ‹å€¼å°±å¥½äº†ã€‚ public void merge(int[] nums1, int m, int[] nums2, int n) { // the last position of array int last = nums1.length - 1; m--; n--; while (m > 0 && n > 0) { if (nums1[m] > nums2[n]) nums1[last--] = nums1[m--]; else nums1[last--] = nums2[n--]; } while (m > 0) nums1[last--] = nums1[m--]; while (n > 0) nums1[last--] = nums2[n--]; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/92/":{"url":"codes/92/","title":"92. Reverse Linked List II","keywords":"","body":"92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 â‰¤ m â‰¤ n â‰¤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL ä»èµ·å§‹ç‚¹åˆ°ç»“æŸç‚¹è¿›è¡Œreverseã€‚é¦–å…ˆæ ¹æ®currçš„indexéå†åˆ°mçš„æ—¶å€™è®°å½•ä¸€ä¸‹è¯¥node startï¼Œç„¶ååŒæ—¶è®°å½•startå‰é¢çš„ä¸€ä¸ªnode preå› ä¸ºreverseç»“æŸè¿˜è¦æŠŠé“¾è¡¨é“¾æ¥èµ·æ¥ã€‚å½“indexéå†åˆ°nçš„æ—¶å€™è®°å½•è¯¥node endã€‚ç„¶åä½¿ç”¨é€’å½’è¿›è¡Œreverseã€‚ public class ReverseLinkedListII { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode reverseBetween(ListNode head, int m, int n) { if (m >= n || head == null || head.next == null) return head; int index = 1; ListNode curr = head; ListNode start = null; ListNode end = null; ListNode pre = null; while (curr != null) { if (index == m) start = curr; if (index == n) end = curr; if (start == null) pre = curr; curr = curr.next; ++index; } if (end == null || start == null) return head; ListNode rest = end.next; end.next = null; reverse(start, start.next); // ç°åœ¨enduåº”è¯¥æ˜¯head if (pre == null) head = end; else pre.next = end; start.next = rest; return head; } public void reverse(ListNode curr, ListNode next) { if (next == null) return; reverse(next, next.next); next.next = curr; curr.next = null; } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(3); ListNode l4 = new ListNode(4); l1.next = l2; l2.next = l3; l3.next = l4; ReverseLinkedListII r = new ReverseLinkedListII(); r.reverseBetween(l1, 1, 4); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/100/":{"url":"codes/100/","title":"100. Same Tree","keywords":"","body":"100. Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false æ€è·¯å°±æ˜¯å·¦å³ä¸¤è¾¹çš„nodeéƒ½ä¸€æ ·ã€‚ public class SameTree { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null && q == null) return true; if (p == null || q == null) return false; boolean left = isSameTree(p.left, q.left); boolean right = isSameTree(p.right, q.right); return p.val == q.val && (left && right); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/101/":{"url":"codes/101/","title":"101. Symmetric Tree","keywords":"","body":"101. Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3 å…¶å®æ˜¯å’Œä¸Šé¢é‚£é“é¢˜ä¸€ä¸ªç›¸åçš„æ€è·¯ï¼Œä¸Šé¢æ˜¯å·¦å³ç›¸ç­‰ï¼Œè¿™ä¸ªæ˜¯left = right, right = leftã€‚ public class SymmetricTree { public boolean isSymmetric(TreeNode root) { if (root == null) return true; return mirror(root.left, root.right); } // åˆ¤æ–­å·¦å³æ˜¯å¦ä¸€æ · public boolean mirror(TreeNode p, TreeNode q) { if (p == null && q == null) return true; if (p == null || q == null) return false; boolean left = mirror(p.left, q.right); boolean right = mirror(p.right, q.left); return p.val == q.val && (left && right); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/111/":{"url":"codes/111/","title":"111. Minimum Depth of Binary Tree","keywords":"","body":"111. Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its minimum depth = 2. å…³äºtreeçš„ç®—æ³•å¯ä»¥å»çœ‹æˆ‘å¦ä¸€ç¯‡æ–‡ç« https://shunyangli.github.io/2020/05/03/Algorithm/#more public class MinimumDepthofBinaryTree { public int minDepth(TreeNode root) { if (root == null) return 0; if (root.left == null && root.right == null) return 1; int left = minDepth(root.left); int right = minDepth(root.right); if (root.left == null) return 1 + right; if (root.right == null) return 1 + left; return Math.min(left, right) + 1; } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/112/":{"url":"codes/112/","title":"112. Path Sum","keywords":"","body":"112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22. public class PathSum { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) return false; if (root.left == null && root.right == null) return root.val == sum; boolean left = hasPathSum(root.left, sum - root.val); boolean right = hasPathSum(root.right, sum - root.val); return left | right; } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/121/":{"url":"codes/121/","title":"121. Best Time to Buy and Sell Stock","keywords":"","body":"Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. è¿™ä¸ªé¢˜çš„æ€è·¯ç¨å¾®ç®€å•ä¸€ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥æ‰¾åˆ°æœ€å°çš„ä¹°å…¥ä»·æ ¼ï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥æ ¹ç»åœ¨ä¹°å…¥ä»·æ ¼æœ€ä½çš„æ—¥æœŸä¹‹åï¼Œæ‰¾åˆ°å–å‡ºä»·æ ¼æœ€é«˜çš„ç‚¹ï¼Œè¿™æ ·æ”¶ç›Šå°±æ˜¯æœ€å¤§çš„ã€‚ public int maxProfit(int[] prices) { if (prices.length = 0) max = Math.max(max, price-stock); // æ‰¾åˆ°æœ€æ–°çš„æ”¶å…¥ stock = Math.min(stock, price); } return max; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/125/":{"url":"codes/125/","title":"125. Valid Palindrome","keywords":"","body":"125. Valid Palindrome Valid Palindrome: Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. This one is pretty easy, we just need to ignore the char which is not belong to a-z, 0-9. During the processing, we can use double pointer to do that. Set a index from the left and a index from the right. class Solution: def isPalindrome(self, s: str) -> bool: s = s.lower() start = 0 end = len(s) - 1 while start powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/127/":{"url":"codes/127/","title":"127. Word Ladder","keywords":"","body":"126. Word Ladder Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: 5 Explanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", return its length 5. è¯è¯­æ¥é¾™ï¼Œä¸€ä¸ªè€å¤–å¾ˆå–œæ¬¢çš„æ¸¸æˆï¼Œæˆ‘è§‰å¾—ä»–ä»¬çš„testæœ‰é—®é¢˜ã€‚ã€‚ã€‚è¿™ä¸ªæ•°é‡å°±å¾ˆå¥‡æ€ªï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯æŒ‰ç…§æˆ‘çš„æ–¹æ³•æ¥ï¼Œæˆ‘ä¸è§‰å¾—æˆ‘å†™é”™äº†ï¼Œä½¿ç”¨äº†ä¸€ä¸ªbfsçš„ç®—æ³•ï¼Œå› ä¸ºæ¯æ¬¡æ”¹å˜ä¸€ä¸ªå•è¯å…¶ä¸­çš„ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶ååˆ¤æ–­æ–°ç”Ÿæˆçš„å­—ç¬¦æ˜¯å¦åœ¨wordListä¹‹é—´ï¼Œç„¶åå†åˆ¤æ–­æ˜¯ä¸æ˜¯å·²ç»visitedè¿‡çš„ã€‚ import java.util.*; public class WordLadder { public int ladderLength(String beginWord, String endWord, List wordList) { int step = 0; if (!wordList.contains(endWord)) return step; Queue queue = new LinkedList<>(); queue.offer(beginWord); Set visited = new HashSet<>(); while (!queue.isEmpty()) { ++step; for (int x = 0; x list = new ArrayList( Arrays.asList(\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\") ); int res = w.ladderLength(\"hit\", \"cog\", list); System.out.println(res); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/136/":{"url":"codes/136/","title":"136. Single Number","keywords":"","body":"Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 åº†å¹¸ä¸€ä¸‹ç»ˆäºå¯ä»¥ç‹¬ç«‹æ€è€ƒå‡ºæ¥ä¸€äº›ç®€å•çš„ç®—æ³•äº†ã€‚è¿™ä¸ªé¢˜å…¶å®ç®—æ˜¯è¿˜OKçš„ï¼Œå¯ä»¥ä½¿ç”¨HashMapè§£å†³ï¼Œå› ä¸ºHashMapç›‘æµ‹keyçš„æ—¶å€™çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(1)$ï¼Œæ‰€ä»¥æ•´ä½“æ—¶é—´æ˜¯$O(n)$ã€‚åœ¨loopé‡Œé¢å»åˆ¤æ–­è¯¥æ•°å­—æ˜¯å¦å­˜åœ¨HashMapé‡Œé¢ï¼Œå¦‚æœä¸å­˜åœ¨å°±pushè¿›å»ï¼Œå¦‚æœå·²ç»å­˜åœ¨å°±åˆ é™¤ã€‚é‚£ä¹ˆæœ€åå‰©ä¸‹çš„é‚£ä¸ªå…ƒç´ è‚¯å®šæ˜¯singleï¼ˆå•èº«ç‹—ï¼‰ã€‚ public int singleNumber (int[] A) { // write code here Map map = new HashMap<>(); for (int value : A) { if (map.containsKey(value)) { map.remove(value); } else { map.put(value, value); } } return map.get(map.keySet().toArray()[0]); } Ps: åœ¨discussé‡Œé¢çœ‹åˆ°äº†ä¸€ä¸ªç‰¹åˆ«éªšçš„æ“ä½œã€‚ã€‚ã€‚çœŸçš„éªšæ“ä½œã€‚ã€‚ã€‚ ä½¿ç”¨äº†å¼‚æˆ–ï¼ˆexclusive ORç®€ç§°xorï¼‰è¿™ä¸ªæ¥åˆ¤æ–­çš„ï¼Œå¼‚æˆ–çš„è¯ç©ºé—´å¤æ‚åº¦åªæœ‰$O(1)$ã€‚ $1\\oplus0=1$ $1\\oplus1=1$ $0\\oplus0=0$ $0\\oplus1=1$ public int singleNumber(int[] nums) { int res = 0; for (int i = 0; i è¡Œå§ã€‚ã€‚ã€‚ç‰›é€¼ã€‚ã€‚ powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/141/":{"url":"codes/141/","title":"141. Linked List Cycle","keywords":"","body":"Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. ç®—æ³•æ€è·¯ï¼š ä¸€å¼€å§‹æƒ³åˆ°çš„æ˜¯ç”¨HashMapçš„æ–¹å¼æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯è¿™æ ·çš„è¯ç©ºé—´å¤æ‚åº¦å°±é«˜äº†å¾ˆå¤šå°±æ˜¯$O(n)$äº†ï¼Œç„¶åçœ‹äº†ä¸€ä¸‹å¤§ç¥ä»¬çš„è§£æ³•ï¼Œå°±æ˜¯åˆ©ç”¨å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•ï¼Œä¸¤ç§æˆ‘éƒ½è¯•äº†ä¸€ä¸‹ï¼š HashMapçš„æ–¹æ³• public boolean hasCycle(ListNode head) { Map map = new HashMap<>(); ListNode curr = head; while (curr != null) { if (map.containsKey(curr)) return true; else map.put(curr, 1); curr = curr.next; } return false; } å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³• è¿™æ ·æ•ˆç‡é«˜ï¼Œå†…å­˜å ç”¨å°‘ public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (slow == fast) return true; } return false; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/142/":{"url":"codes/142/","title":"142. Linked List Cycle II","keywords":"","body":"142. Linked List Cycle II Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. é¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯HashMapå“ˆå“ˆå“ˆå“ˆï¼Œç„¶åä»–è¦æ±‚è¯´ä¸ç”¨é¢å¤–çš„ç©ºé—´ï¼Œåœ¨ä¸å®ç”¨é¢å¤–çš„ç©ºé—´çš„æƒ…å†µä¸‹æƒ³åˆ°äº†é€’å½’+å¾ªç¯çš„æ–¹æ³•ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒé«˜ã€‚åœ¨å¾ªç¯çš„è¿‡ç¨‹ä¸­æ¯ä¸ªnodeéƒ½è¿›è¡Œä¸€ä¸ªæ£€æŸ¥ç¯çš„æ“ä½œï¼Œå¹¶ä¸”åˆ¤æ–­åœ¨ç¯é‡Œé¢æ˜¯ä¸æ˜¯ç­‰äºè¯¥æ•°å­—ï¼Œå¦‚æœä¸ç­‰äºçš„è¯å°±ä»£è¡¨ä¸æ˜¯ç¯çš„ä¸€ä¸ªnodeï¼Œå½“å‡ºç°ç¬¬ä¸€ä¸ªnodeå¹¶ä¸”æ˜¯åœ¨ç¯é‡Œé¢çš„nodeå°±ä»£è¡¨æ˜¯ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚æ„Ÿè§‰ç‰ºç‰²äº†æ—¶é—´æ¢æ¥äº†ç©ºé—´çš„ä¼˜åŒ–ã€‚ã€‚ã€‚ã€‚ã€‚ import java.util.HashMap; public class LinkedListCycleII { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } // hashmapçš„è§£å†³æ–¹æ³• // public ListNode detectCycle(ListNode head) { // HashMap map = new HashMap<>(); // // ListNode curr = head; // while (curr != null) { // if (map.containsKey(curr)) { // return curr; // } else { // map.put(curr, 1); // } // curr = curr.next; // } // // return null; // } public ListNode detectCycle(ListNode head) { if (head == null || head.next == null) return null; ListNode curr = head; while (curr.next != null) { ListNode temp = loop(curr.next, curr.next.next, curr); if (temp != null) return curr; curr = curr.next; } return null; } public ListNode loop(ListNode slow, ListNode fast, ListNode node) { if (slow == null || fast == null || slow.next == null || fast.next == null || fast.next.next == null) return null; if (slow == fast && slow == node) return slow; if (slow == fast) return null; return loop(slow.next, fast.next.next, node); } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(3); ListNode l4 = new ListNode(4); l1.next = l2; l2.next = l3; l3.next = l4; // l4.next = l2; LinkedListCycleII l = new LinkedListCycleII(); l.detectCycle(l1); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/144/":{"url":"codes/144/","title":"144. Binary Tree Preorder Traversal","keywords":"","body":"144. Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? å°±æ˜¯ä¸€ä¸ªå‰åºçš„éå†ï¼šæ ¹å·¦å³ import java.util.LinkedList; import java.util.List; public class BinaryTreePreorderTraversal { public List preorderTraversal(TreeNode root) { List res = new LinkedList<>(); traversal(root, res); return res; } public void traversal(TreeNode root, List res) { if (root == null) return; res.add(root.val); traversal(root.left, res); traversal(root.right, res); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/155/":{"url":"codes/155/","title":"155. Min Stack","keywords":"","body":"Min Stack Min Stack(https://leetcode.com/problems/min-stack/) Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example 1: Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 è¿™ä¸ªåªéœ€è¦çŸ¥é“stackæ˜¯å…ˆè¿›åå‡ºçš„åŸåˆ™å°±è¡Œã€‚ import java.util.Collections; import java.util.LinkedList; import java.util.List; public class MinStack { /** initialize your data structure here. */ private List list; private int lens; public MinStack() { this.list = new LinkedList<>(); this.lens = 0; } public void push(int x) { this.list.add(x); this.lens ++; } public void pop() { if (this.list.size() > 0) { this.lens --; this.list.remove(this.lens); } } public int top() { if (this.list.size() > 0) { return this.list.get(this.lens - 1); } return -1; } public int getMin() { return Collections.min(this.list); } public static void main(String[] args) { MinStack m = new MinStack(); m.push(-2); m.push(0); m.push(-3); System.out.println(m.getMin()); m.pop(); System.out.println(m.top()); // return 0 System.out.println(m.getMin()); // return -2 } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/160/":{"url":"codes/160/","title":"160. Intersection of Two Linked Lists","keywords":"","body":"Intersection of Two Linked Lists Intersection of Two Linked Lists ä¹Ÿç®—æ˜¯æˆ‘ç¬¬ä¸€æ¬¡é¢è¯•çš„ç¬¬ä¸€é“é¢˜ã€‚å½“æ—¶æƒ³çš„æ˜¯æš´åŠ›è§£å†³ï¼Œdoubleå¾ªç¯å“ˆå“ˆå“ˆã€‚è¿™æ¬¡å†™çš„æ—¶å€™æƒ³åˆ°äº†ä¸€ä¸ªæ–°çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨HashMapæ¥è§£å†³ï¼Œæœ€åçš„æƒ…å†µæ˜¯$O(n+m)$ï¼Œä¸è¿‡ä¹Ÿæ¯”$O(n^2)$å¥½ã€‚å…ˆæŠŠä¸€ä¸ªLinkListå…¨éƒ¨æ”¾åˆ°HashMapé‡Œé¢ï¼Œç„¶åå¾ªç¯ç¬¬äºŒä¸ªé“¾è¡¨ï¼Œçœ‹æ˜¯ä¸æ˜¯æœ‰ä¸€æ ·çš„nodeï¼Œå¦‚æœæœ‰å°±ç›´æ¥returnå½“å‰çš„nodeï¼Œå¦‚æœç›´åˆ°å¾ªç¯ç»“æŸè¿˜æ²¡æœ‰å°±return null public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode head = null; ListNode curr = headA; Map map = new HashMap<>(); while (curr != null) { map.put(curr, curr.val); curr = curr.next; } curr = headB; while (curr != null) { if (map.containsKey(curr)) { head = curr; break; } curr = curr.next; } return head; } åœ¨é¢è¯•çš„æ—¶å€™é¢è¯•å®˜ä¹Ÿç»™æˆ‘è¯´äº†å¦ä¸€ç§è§£æ³•ï¼Œå°±æ˜¯å‡è®¾å·²çŸ¥ä¸¤æ¡é“¾è¡¨çš„é•¿åº¦ï¼Œç„¶åå…ˆæŠŠä¸¤æ¡é“¾è¡¨æˆªå–åˆ°ä¸€æ ·çš„é•¿åº¦ï¼Œç„¶åä¸€ä¸ªå¾ªç¯å°±èƒ½æ‰¾åˆ°ç›¸å¯¹åº”çš„ç»“æœã€‚è¿™ä¸ªæˆ‘è§‰å¾—æ—¶é—´å¤æ‚åº¦æ¯”æˆ‘çš„è¦é«˜ï¼Œå°±æ²¡å†™ã€‚ powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/162/":{"url":"codes/162/","title":"162. Find Peak Element","keywords":"","body":"162. Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] â‰  nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -âˆ. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Follow up: Your solution should be in logarithmic complexity. å¯ä»¥é‡‡ç”¨ä¸€ä¸ªäºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºå·²çŸ¥peak numberæ˜¯ nums[i] > nums[i+1]ä¹Ÿå°±æ˜¯è¯´å¦‚æœåœ¨arrayé‡Œé¢å‡ºç°ä¸€ä¸ªé™åºå°±ä»£è¡¨ç€æ˜¯peak numberã€‚è¿™æ ·çš„è¯å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œå¦‚æœnums[mid] > nums[mid+1]å°±ä»£è¡¨è¯¥æ•°å­—å°±æ˜¯peak numberï¼Œä½†æ˜¯ä¹‹å‰çš„å¯ä»¥è¿˜æœ‰ç›¸å¯¹åº”çš„peak numberï¼Œæ‰€ä»¥å°±æ˜¯search(nums, left, mid)ã€‚ ps: ä¹Ÿæœ‰ä¸€ç§O(n)çš„æ–¹æ³•æ¥æŸ¥æ‰¾ã€‚ public class FindPeakElement { // public int findPeakElement(int[] nums) { // for (int i = 0; i nums[i+1]) return i; // } // // return nums.length-1; // } public int findPeakElement(int[] nums) { return search(nums, 0, nums.length - 1); } public int search(int[] nums, int left, int right) { if (left == right) return left; int mid = (left + right) / 2; if (nums[mid] > nums[mid+1]) return search(nums, left, mid); return search(nums, mid+1, right); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/169/":{"url":"codes/169/","title":"169. Majority Element","keywords":"","body":"Majority Element Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2 æ–¹æ³•1ï¼šhashmap çœ‹åˆ°è¿™ä¸€ç±»çš„é¢˜ï¼Œæœ€å…ˆæƒ³åˆ°çš„å°±æ˜¯ä½¿ç”¨HashMapæ¥è§£å†³è¿™ä¸ªè®¡æ•°çš„é—®é¢˜ï¼Œå½“è®¡æ•°çš„ç»“æœ> nums.leng/2çš„æ—¶å€™å¯ä»¥ç›´æ¥returnå°±å¥½äº†ï¼Œå‡†æ²¡é”™ public int majorityElement(int[] nums) { if (nums.length map = new HashMap<>(); for (int i = 0; i = nums.length/2) return nums[i]; map.put(nums[i], map.get(nums[i]) + 1); } else { map.put(nums[i], 1); } } return -1; } æ–¹æ³•2ï¼šæ’åº ç„¶åçœ‹äº†ä¸€ä¸‹å®˜æ–¹çš„è§£æ³•ï¼Œå°±æ˜¯å…ˆsortä¸€ä¸‹ï¼Œå¦‚æœè¯¥æ•°å­—çš„ä¸ªæ•°å¤§äºæ€»arrayé•¿åº¦çš„ä¸€èˆ¬ä¹Ÿå°±æ„å‘³ç€sortå®Œä¹‹åå–ä¸­é—´é‚£ä¸ªæ•°å­—å‡†æ²¡é”™ã€‚ã€‚ã€‚é‚£ä¹ˆç®€å•çš„æ–¹æ³•å’‹å°±æ²¡æƒ³åˆ°å‘¢o(â•¥ï¹â•¥)o public int majorityElement(int[] nums) { if (nums.length == 0) return -1; Arrays.sort(nums); return nums[nums.length/2]; } æ–¹æ³•3ï¼šæ‘©å°”æŠ•ç¥¨æ³•ï¼ˆæœ€ä½³æ–¹æ³•ï¼‰ æ€è·¯ï¼š æ‘©å°”æŠ•ç¥¨æ³•é€šè¿‡ç»´æŠ¤ä¸€ä¸ªâ€œå€™é€‰äººâ€å’Œâ€œè®¡æ•°å™¨â€æ¥ç¡®å®šå¤šæ•°å…ƒç´ ï¼š éå†æ•°ç»„æ—¶ï¼Œå¦‚æœå½“å‰è®¡æ•°å™¨ä¸º0ï¼Œåˆ™å°†å½“å‰å…ƒç´ è®¾ä¸ºå€™é€‰äººï¼Œå¹¶å°†è®¡æ•°å™¨è®¾ç½®ä¸º1ã€‚ å¦‚æœå½“å‰å…ƒç´ ç­‰äºå€™é€‰äººï¼Œè®¡æ•°å™¨åŠ 1ï¼›å¦åˆ™ï¼Œè®¡æ•°å™¨å‡1ã€‚ æœ€åå‰©ä¸‹çš„å€™é€‰äººå³ä¸ºå¤šæ•°å…ƒç´ ã€‚ å¤æ‚åº¦ï¼š æ—¶é—´å¤æ‚åº¦ï¼šO(n)O(n)O(n)ï¼Œåªéœ€ä¸€æ¬¡éå†ã€‚ ç©ºé—´å¤æ‚åº¦ï¼šO(1)O(1)O(1)ã€‚ Pythonå®ç°ï¼š class Solution { public: int majorityElement(vector& nums) { int cand = nums[0], cnt = 0; for (int num : nums) { if (cnt == 0) cand = num; cnt += (cand == num) ? 1 : -1; } return cand; } }; powered by GitbookFile Modify: 2024-11-29 16:24:52 "},"codes/189/":{"url":"codes/189/","title":"189. Rotate Array","keywords":"","body":"Rotate Array Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Follow up: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] å°±æ˜¯æ ¹æ®kçš„ä¸ªæ•°ï¼Œæ¯ä¸ªelementå‘åç§»åŠ¨kä½ï¼Œè¶…å‡ºarrayçš„è¯åœ¨arrayçš„å¼€å¤´ç»§ç»­ã€‚ åˆšå¼€å§‹è¯•äº†å¥½å‡ ç§æ–¹æ³•ï¼Œä½†æ˜¯éƒ½ä¸æ˜¯ç‰¹åˆ«ç†æƒ³ï¼Œçœ‹äº†ä¸€ä¸‹discussionï¼Œå­¦åˆ°äº†ã€‚è¿™ä¸ªç¿»è½¬é“¾è¡¨å®é™…æ˜¯æœ‰è§„å¾‹çš„ï¼Œå…ˆæŠŠæ•´ä¸ªarray reverseä¸€ä¸‹ï¼Œç„¶åå†æŠŠ0-kreverseï¼Œç„¶åæŠŠk-endreverseä¸€ä¸‹å°±å¯ä»¥å¾—åˆ°æœ€ç»ˆçš„ç»“æœã€‚ã€‚ã€‚å¾ˆç¥å¥‡çš„è§„å¾‹ã€‚ã€‚ã€‚ import java.util.Arrays; /** * è¿™ä¸ªæƒ³æ³•æ˜¯åœ¨leetcodeé‚£è¾¹çœ‹åˆ°çš„ï¼Œå…¶å·¥ä½œåŸç†å°±æ˜¯å…ˆreverseä¸€ä¸‹ * ç„¶ååœ¨å¯¹å‰kä¸ªè¿›è¡Œreverseï¼Œç„¶åå¯¹k-lenå†reverse * è¿™æ ·å°±èƒ½å¾—åˆ°ç»“æœäº† */ public class RotateArray { public void rotate(int[] nums, int k) { if (nums.length powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/202/":{"url":"codes/202/","title":"202. Happy Number","keywords":"","body":"Happy Number Happy Number Write an algorithm to determine if a number n is \"happy\". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Return True if n is a happy number, and False if not. Example: Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 è¾“å…¥ä¸€ä¸ªæ•°å­—ï¼Œç„¶åæŠŠæ•°å­—åˆ†å¼€ï¼Œç„¶åå¹³æ–¹ç›¸åŠ ã€‚æ¯”å¦‚19 = 1^2 + 9^2å¾—å‡ºçš„æ•°å­—å†ç»§ç»­è¿›è¡Œä¸€æ ·çš„æ“ä½œï¼Œä¸€ç›´ç®€åŒ–åˆ°è¯¥æ•°å­—åˆ°ä¸ªä½æ•°ï¼Œå¦‚æœè¯¥æ•°å­—ç­‰äº1æˆ–è€…7çš„æ—¶å€™ï¼Œå°±å¯ä»¥return trueï¼Œå¦åˆ™çš„è¯å°±return false import java.util.LinkedList; import java.util.List; public class HappyNumber { public boolean isHappy(int n) { if (n == 1) return true; int sum = n; List list = new LinkedList<>(); while (true) { list = split(sum); sum = 0; for (Integer i : list) { sum += Math.pow(i, 2); } if (sum == 1 || sum == 7) { return true; } if (sum split(int n) { List list = new LinkedList<>(); while (n != 0) { list.add(n % 10); n = n / 10; } return list; } public static void main(String[] args) { HappyNumber hp = new HappyNumber(); System.out.println(hp.isHappy(19)); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/205/":{"url":"codes/205/","title":"205. Isomorphic Strings","keywords":"","body":"205. Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Example 1: Input: s = \"egg\", t = \"add\" Output: true Explanation: The strings s and t can be made identical by: Mapping 'e' to 'a'. Mapping 'g' to 'd'. Example 2: Input: s = \"foo\", t = \"bar\" Output: false Explanation: The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'. Example 3: Input: s = \"paper\", t = \"title\" Output: true Constraints: 1 t.length == s.length s and t consist of any valid ascii character. Solution æ²¡å•¥å¤ªå¤šæŠ€å·§ï¼Œç›´æ¥hashmapã€‚ class Solution { public: bool isIsomorphic(string s, string t) { if (s.size() != t.size()) return false; auto maps = vector(128, -1); auto maped = vector(128, 0); for (int i = 0; i (s[i]); int t_ = static_cast(t[i]); if (maps[s_] == -1) { if (maped[t_]) return false; maps[s_] = t_; maped[t_] = 1; } else { if (maps[s_] != t_) return false; } } return true; } }; powered by GitbookFile Modify: 2024-11-30 22:42:12 "},"codes/206/":{"url":"codes/206/","title":"206. Reverse Linked List","keywords":"","body":"Reverse Linked List Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL ç¿»è½¬é“¾è¡¨å¯ä»¥å¾ªç¯å®ç°ï¼Œä¹Ÿå¯ä»¥ç”¨é€’å½’å®ç°ã€‚ public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode curr = head; ListNode next = head.next; ListNode temp = null; curr.next = null; while (next != null) { temp = next.next; next.next = curr; curr = next; next = temp; } return curr; } ç„¶åé€’å½’çš„è¯å°±åˆšå¼€å§‹çœ‹å¯èƒ½ä¸æ˜¯ç‰¹åˆ«å¥½ç†è§£çš„ã€‚æ€»æ„Ÿè§‰é‡åˆ°é€’å½’å°±æœ‰ç‚¹æ‡µé€¼çš„æ„Ÿè§‰ã€‚ã€‚ã€‚ public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/209/":{"url":"codes/209/","title":"209. Minimum Size Subarray Sum","keywords":"","body":"209. Minimum Size Subarray Sum Minimum Size Subarray Sum: Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example: Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Brute Force The basic approach is to use two loops to solve that. The time complexity of this approach is $O(N^2)$. It will cause time limit exceeded. class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -> int: length = 9999 for i in range(0, len(nums)): res = nums[i] if res >= target: length = 1 continue for j in range(i + 1, len(nums)): res += nums[j] if res >= target: length = min(length, j - i + 1) break return length if length != 9999 else 0 Advance Approach To solve this issue, we can use Sliding Window to solve this issue. This method is similar to the double pointer. The index the left index of this array. When the sum between i and index is greater or equal to the target, then advance i and index to find other positions that sum is greater or equal to the target. The basic idea of sliding windows is shown in the Figure. class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -> int: index = 0 res = 0 min_len = 99999999 for i in range(0, len(nums)): res += nums[i] while res >= target: length = i - index + 1 min_len = min(length, min_len) res -= nums[index] index += 1 return min_len if min_len != 99999999 else 0 powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/216/":{"url":"codes/216/","title":"216. Combination Sum III","keywords":"","body":"216. Combination Sum III Combination Sum III: Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. For example: Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. This question is pretty similar with the previous one, just add one more constrain (sum = n). class Solution: def combinationSum3(self, k: int, n: int) -> List[List[int]]: def combine(k, n, index, path, result): if len(path) == k: if sum(path) == n: result.append([i for i in path]) return path for i in range(index, 10): path.append(i) combine(k, n, i + 1, path, result) path.pop() return result return combine(k, n, 1, [], []) powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/217/":{"url":"codes/217/","title":"217. Contains Duplicate","keywords":"","body":"Contains Duplicate Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true è¿™ä¸ªé¢˜ç”¨ç®€å•çš„HashMapåšå°±è¡Œï¼Œæˆ–è€…ç”¨hashsetï¼Œæˆ‘è¿™ç”¨çš„æ˜¯hashsetã€‚ import java.util.Arrays; import java.util.HashSet; public class ContainsDuplicate { public boolean containsDuplicate(int[] nums) { HashSet hashSet = new HashSet(); for (int num : nums) { hashSet.add(num); } return nums.length != hashSet.size(); } public static void main(String[] args) { int[] nums = new int[]{1,2,3, 1}; ContainsDuplicate cd = new ContainsDuplicate(); System.out.println(cd.containsDuplicate(nums)); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/219/":{"url":"codes/219/","title":"219. Contains Duplicate II","keywords":"","body":"219. Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: Input: nums = [1,2,3,1], k = 3 Output: true Example 2: Input: nums = [1,0,1,1], k = 1 Output: true Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false æœ¬æ¥æƒ³çš„æ˜¯ç›´æ¥ç”¨forå¾ªç¯ï¼Œæ ¹æ®å½“å‰æ•°å­—ç„¶åå‘åèµ°kä½ï¼Œçœ‹kä½ä»¥å†…æœ‰æ²¡æœ‰å’Œnums[i]ç›¸åŒçš„æ•°å­—ï¼Œä½†æ˜¯è²Œä¼¼bugæœ‰ç‚¹å¤šï¼Œæ”¾å¼ƒäº†ã€‚ã€‚æ”¹ç”¨HashMapäº†ï¼Œkeyå­˜nums[i]ï¼Œvalueå­˜ç›¸å¯¹åº”çš„indexã€‚å¦‚æœHashMapå·²ç»æœ‰è¯¥keyåˆ™å¯ä»¥è®¡ç®—HashMapé‡Œé¢å­˜çš„indexå’Œå½“å‰içš„å·®å€¼ï¼Œå¦‚æœå°äºç­‰äºKå°±å¯ä»¥ç›´æ¥è¿”å›äº†ã€‚ import java.util.HashMap; import java.util.Map; public class ContainsDuplicateII { // æ”¾å¼ƒäº†æˆ‘ä½¿ç”¨hashmapæ¥å†™å¥½å§ã€‚ã€‚ã€‚ public boolean containsNearbyDuplicate(int[] nums, int k) { Map map = new HashMap<>(); for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/232/":{"url":"codes/232/","title":"232. Implement Queue using Stacks","keywords":"","body":"232. Implement Queue using Stacks Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations. Example 1: Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false Constraints: 1 At most 100 calls will be made to push, pop, peek, and empty. All the calls to pop and peek are valid. Solution Queueçš„åŸç†æ˜¯å…ˆè¿›å…ˆå‡ºï¼ŒStackçš„åŸç†æ˜¯å…ˆè¿›åå‡ºã€‚æ‰€ä»¥queue.top()å°±æ˜¯stackæœ€åº•å±‚çš„å…ƒç´ ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªstackæ¥å®Œæˆè¯¥ä»»åŠ¡ã€‚ class MyQueue { private: stack s1, s2; public: MyQueue() { s1 = stack(); s2 = stack(); } void push(int x) { s1.push(x); } int pop() { while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } int val = s2.top(); s2.pop(); while (!s2.empty()) { s1.push(s2.top()); s2.pop(); } return val; } int peek() { while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } int val = s2.top(); while (!s2.empty()) { s1.push(s2.top()); s2.pop(); } return val; } bool empty() { return s1.empty() && s2.empty(); } }; powered by GitbookFile Modify: 2024-11-27 17:06:18 "},"codes/234/":{"url":"codes/234/","title":"234. Palindrome Linked List","keywords":"","body":"Palindrome Linked List Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space? æ€è·¯ï¼š æœ¬æ¥æƒ³çš„æ˜¯ç”¨é€’å½’çš„æ–¹æ³•ç®—ä¸€ä¸‹å’Œï¼Œå¦‚æœæ˜¯å›æ–‡çš„è¯ç»“æœåº”è¯¥æ˜¯ä¸€æ ·çš„ï¼Œæƒ³æ³•å¾ˆç¾å¥½ï¼Œç°å®å¾ˆæ®‹é…·ã€‚ã€‚ã€‚LeetCodeå®˜æ–¹åº”è¯¥ä¹Ÿè€ƒè™‘åˆ°è¿™ä¸ªé—®é¢˜äº†ï¼Œå¦‚æœç®—sumçš„è¯ä¼šå¯¼è‡´æ•´å‹æº¢å‡ºçš„é—®é¢˜ã€‚ã€‚ã€‚ã€‚ä¸è¿‡ä¹Ÿç®—æ˜¯ä¸€ä¸ªæ€è·¯å§ã€‚o(â•¥ï¹â•¥)o public boolean isPalindrome(ListNode head) { if (head == null) return false; if (head.next == null) return true; long [] nums = new long[]{0, 0}; recur(head,nums); return nums[0] == nums[1]; } public void recur(ListNode curr, long[] nums) { if (curr == null) return ; nums[0] = nums[0]*10 + curr.val; recur(curr.next, nums); nums[1] = nums[1]*10 + curr.val; } æœ€è¿‘é‡åˆ°çš„é¢˜ä¸æ˜¯é€’å½’å°±æ˜¯åŠ¨æ€è§„åˆ’ã€‚ã€‚ã€‚çœ‹æ¥è¿™å—æœ‰ç‚¹è–„å¼±ï¼Œæœ‰æ—¶é—´è¦å¤šç»ƒä¹ ä¸€ä¸‹ã€‚ã€‚çœ‹äº†discussioné‡Œé¢ï¼Œæœ‰ä¸ªå¤§ç¥å†™çš„ä¹Ÿæ˜¯é€’å½’çš„æ–¹æ³•ï¼Œç±»ä¼¼äºå…ˆæŠŠç¬¬ä¸€ä¸ªæŒ‡é’ˆèµ°åˆ°ç»“å°¾ï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆæŒ‡å‘headï¼Œç„¶åå¯¹æ¯”æ˜¯ä¸æ˜¯ä¸€æ ·ã€‚æ„Ÿè§‰å¾ˆç‰›é€¼ã€‚ã€‚ä¸è¿‡é€’å½’è²Œä¼¼èŠ±è´¹æ—¶é—´æœ‰ç‚¹ä¹…ã€‚ boolean flag = true; public boolean isPalindrome(ListNode head) { recur(head, head); return flag; } public ListNode recur(ListNode p1, ListNode p2) { if (p1 == null) return p2; ListNode node = recur(p1.next, p2); if (node.val != p1.val) flag = false; return node.next; } Ps: è¿˜æœ‰ä¸€ç§å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•ã€‚ã€‚å°±æ˜¯èµ°åˆ°ä¸­é—´ï¼Œç„¶åæŠŠä¸¤æ¡é“¾è¡¨åˆ†å¼€å¯¹æ¯”å°±è¡Œäº†ï¼Œä½†æ˜¯æ„Ÿè§‰æœ‰ç‚¹éº»çƒ¦ï¼Œè¿˜æ˜¯ä¸å†™äº†ã€‚ã€‚ã€‚ powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/238/":{"url":"codes/238/","title":"238. Product of Array Except Self","keywords":"","body":"238. Product of Array Except Self Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) Solution è¿™ä¸ªé—®é¢˜ç»™å‡ºçš„æç¤º prefix å’Œ suffix ï¼Œé‚£ä¹ˆæ ¹æ®è¿™ä¸ªæç¤ºæˆ‘ä»¬å¯ä»¥å¾—çŸ¥è¿™ä¸ªé¢˜æ˜¯éœ€è¦å‰åéå†çš„ç®—ã€‚å¹¶ä¸”è¯¥é—®é¢˜è¦æ±‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n) ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡å–å·¦å³ä¸¤è¾¹éå†çš„æ–¹æ³•ã€‚ æ ¹æ®è¿™ä¸ªé—®é¢˜æœ¬èº«çš„è¦æ±‚ï¼Œç®—å‡ºè¯¥æ•°ç»„æ‰€æœ‰æ•°å­—çš„ä¹˜ç§¯ï¼Œä½†æ˜¯ä¸åŒ…å«å½“å‰æ•°å­—ã€‚é¦–å…ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ prefix ä»å·¦åˆ°å³éå†ä¸€ä¸‹ï¼š nums: 1 2 3 4 pre: 1 1 2 6 æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ä»å·¦åˆ°å³éå†çš„è¯ï¼Œ nums ä¸­æ¯ä¸ªç´¢å¼•å¯¹åº”çš„æ•°æ®æ˜¯å‰é¢å‡ ä¸ªæ•°å­—çš„ä¹˜ç§¯ï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å¯ä»¥å¾—çŸ¥ä»å·¦åˆ°å³çš„ä¹˜ç§¯æ˜¯å¤šå°‘äº†ã€‚ä»å³å¾€å·¦çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦ç”¨å½“å‰æ•°å­—ä¹˜ä»¥ä¸Šä¸€è½®çš„ç»“æœï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¾—åˆ°æœ€åç»“æœäº†ã€‚ prefix è®°å½•çš„æ˜¯ä»å·¦åˆ°å³çš„ä¹˜ç§¯ï¼Œ sufix è®°å½•çš„æ˜¯ä»å³åˆ°å·¦çš„ä¹˜ç§¯ï¼ˆä¸åŒ…å«è‡ªèº«ï¼‰ã€‚ class Solution { public: vector productExceptSelf(vector& nums) { auto ans = vector(nums.size(), 1); int prefix = 1; for (int i = 0; i = 0; i -- ) { ans[i] = suffix * ans[i]; suffix *= nums[i]; } return ans; } }; powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/242/":{"url":"codes/242/","title":"242. Valid Anagram","keywords":"","body":"242. Valid Anagram Given two strings s and t, return true if t is an anagram of s, and false otherwise. Input: s = \"anagram\", t = \"nagaram\" Output: true Input: s = \"rat\", t = \"car\" Output: false Brute Force This issue can be solved by using two loop. But the time complexity is $O(N)$. In addition, it also can be done through sort algorithm, to check whether same. But it is too complex. Here we did not code for this approache. Advance Approach We can use hashmap to record that how many times they appeared in the string. Therefore, the time complexity is $O(N)$. class Solution: def isAnagram(self, s: str, t: str) -> bool: if len(s) != len(t): return False data = {} for i in s: if i not in data: data[i] = 1 else: data[i] += 1 for i in t: if i not in data: return False else: if data[i] == 0: return False else: data[i] -= 1 for key, val in data.items(): if data[key] != 0: return False return True powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/268/":{"url":"codes/268/","title":"268. Missing Number","keywords":"","body":"268. Missing Number Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: n == nums.length 1 0 All the numbers of nums are unique. Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity? Solution ç”¨hashmapå°±èƒ½è§£å†³ã€‚ä½†ç©ºé—´å¤æ‚åº¦æ˜¯ O(n) ã€‚å¦‚æœæƒ³è¦åœ¨ O(1) æ˜¯çš„ç©ºé—´å¤æ‚åº¦ä¸­å®Œæˆï¼Œå¯ä»¥é€šè¿‡æ±‚å’Œçš„æ–¹å¼æ¥è§£å†³ã€‚ class Solution { public: int missingNumber(vector& nums) { int r_sum = 0; int a_sum = 0; for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/283/":{"url":"codes/283/","title":"283. Move Zeroes","keywords":"","body":"Move Zeroes Move Zeroes Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. ä¸€å¼€å§‹çœ‹åˆ°è¿™ä¸ªæƒ³äº†ä¸€ä¸‹åŒæŒ‡é’ˆï¼Œä¸€ä¸ªä»å¤´å¼€å§‹ä¸€ä¸ªä»å°¾éƒ¨å¼€å§‹ï¼Œè¿™æ ·è™½ç„¶å¯ä»¥æŠŠ0éƒ½æ”¾åˆ°åé¢ï¼Œä½†æ˜¯è¿™æ ·å°±ä¸æ˜¯é¡ºåºæ¥çš„äº†ã€‚ã€‚ã€‚çœ‹äº†ä¸€ä¸‹å¤§ä½¬æ€è·¯ï¼Œä¹Ÿæ˜¯åŒæŒ‡é’ˆï¼ˆæ–¹æ³•æ€è·¯æ²¡é”™å¯¹å§ï¼‰ï¼Œåªä¸è¿‡è¿™ä¸ªåŒæŒ‡é’ˆéƒ½æ˜¯ä»å¤´å¼€å§‹çš„ã€‚å…ˆè®¾ç½®ä¸€ä¸ª0çš„æŒ‡é’ˆzero=-1å› ä¸ºæˆ‘ä»¬ä¸€å¼€å§‹ä¸çŸ¥é“0çš„ä½ç½®åœ¨é‚£ï¼Œç„¶åå¼€å§‹å¾ªç¯ï¼Œå¦‚æœè¯¥æ•°å­—ä¸º0å¯ä»¥å¯¹zeroè¿›è¡Œèµ‹å€¼äº†ï¼ˆzero == -1ï¼‰ï¼Œå½“zero != -1è¯´æ˜ä¹‹å‰å·²ç»æœ‰äº†0çš„æ•°å­—ã€‚ç„¶åå¦‚æœè¯¥æ•°å­—ä¸ç­‰äº0çš„æ—¶å€™è¡¨ç¤ºå¯ä»¥å¯¹ä¹‹å‰çš„zeroçš„indexè¿›è¡Œæ›¿æ¢ï¼Œå‰ææ˜¯zero != -1ï¼Œç„¶ååˆ¤æ–­zeroå’Œiçš„ä½ç½®ï¼Œå¦‚æœiæ˜¯zeroçš„nextè¯´æ˜æ˜¯åªæœ‰ä¸€ä¸ªzeroï¼Œä¸ç„¶çš„è¯å°±ä»£è¡¨zeroåé¢è¿˜æ˜¯ä¸€ä¸ª0çš„æ•°å­—ï¼Œæ‰€ä»¥è¿™æ—¶å€™zero++å°±è¡Œã€‚ public void moveZeroes(int[] nums) { int zero = -1; for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/287/":{"url":"codes/287/","title":"287. Find the Duplicate Number","keywords":"","body":"287. Find the Duplicate Number Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space. Example 1: Input: nums = [1,3,4,2,2] Output: 2 Example 2: Input: nums = [3,1,3,4,2] Output: 3 Example 3: Input: nums = [3,3,3,3,3] Output: 3 Constraints: 1 nums.length == n + 1 1 All the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up: How can we prove that at least one duplicate number must exist in nums? Can you solve the problem in linear runtime complexity? Solution S1. å¯ä»¥ä½¿ç”¨ hashmap çš„æ€è·¯æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè§£å†³æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œä½†æ˜¯ä¸æ»¡è¶³ O(1) spaceçš„è¦æ±‚ã€‚ class Solution { public: int findDuplicate(vector& nums) { auto maps = unordered_map(); for (int const& num : nums) { maps[num] += 1; if (maps[num] > 1) return num; } return -1; } }; S2. ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•æ¥è§£å†³ï¼Œå› ä¸ºé¢˜ç›®ä¸­çš„è¦æ±‚å…¶å®å·²ç»å£°æ˜äº†ï¼Œæ•°å­—ä¸ä¼šè¶…è¿‡æ•°ç»„é•¿åº¦ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆçš„æ€è·¯æ¥æ‰¾åˆ°cycleã€‚ class Solution { public: int findDuplicate(vector& nums) { int slow = nums[0]; int fast = nums[0]; // Phase 1: Detect cycle do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = nums[0]; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; // The duplicate number } }; powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/344/":{"url":"codes/344/","title":"344. Reverse String","keywords":"","body":"344. Reverse String Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. Example 1: Input: [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] æ„Ÿè§‰æ²¡æœ‰ä»€ä¹ˆæŠ€æœ¯å«é‡ï¼Œå°±ç›´æ¥reverseå°±è¡Œã€‚ import java.util.Arrays; public class ReverseString { public void reverseString(char[] s) { int left = 0; int right = s.length - 1; while (left powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/347/":{"url":"codes/347/","title":"347. Top K Frequent Elements","keywords":"","body":"347. Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 â‰¤ k â‰¤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. It's guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique. You can return the answer in any order. ç”¨HashMapå¯ä»¥è§£å†³ï¼Œä½†æ˜¯å› ä¸ºJavaå¯¹HashMapæœ‰ç‚¹ç‚¹ä¸å¤ªå‹å–„ï¼Œæˆ‘æ”¹æˆPythonäº†ï¼Œå› ä¸ºå¯ä»¥è‡ªå®šä¹‰sort å­—å…¸ï¼Œè¿™æ ·å¯ä»¥æ ¹æ®ç»“æœæ’åºäº†ã€‚ã€‚ã€‚ class Solution: def topKFrequent(self, nums, k): frequence = {} for value in nums: if value in frequence: frequence[value] += 1 else: frequence[value] = 1 frequence = sorted(frequence.items(), key=lambda x: x[1], reverse=True) index = 0 res = [] for t in frequence: index += 1 res.append(t[0]) if index == k: break return res powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/350/":{"url":"codes/350/","title":"350. Intersection of Two Arrays II","keywords":"","body":"Intersection of Two Arrays II Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. è¿™ä¸ªé¢˜å°±ç¨å¾®ç®€å•ä¸€ç‚¹äº†ï¼Œå¯ä»¥ç”¨HashMapæ¥è®°å½•num1çš„å…ƒç´ ï¼Œvalueæ¥å­˜æ•°å­—å‡ºç°çš„æ¬¡æ•°ã€‚è¿™æ ·åœ¨éå†num2çš„æ—¶å€™å°±å¯ä»¥ç›´æ¥åˆ¤æ–­äº†ã€‚ã€‚ã€‚åˆšå¼€å§‹æƒ³åˆ°è¿‡arrayçš„ç”¨æ³•ï¼Œä½†æ˜¯å› ä¸ºkeyæ˜¯å•ä¸€çš„ï¼Œé»˜é»˜è¢«æˆ‘æ”¾å¼ƒäº†ï¼ˆæˆ‘å°±æ˜¯å‚»é€¼ã€‚ã€‚ã€‚ï¼‰ï¼Œçœ‹äº†ä¸€ä¸‹discussionæç„¶å¤§æ‚Ÿã€‚ã€‚ã€‚ import javax.swing.*; import java.util.*; /** * Input: nums1 = [1,2,2,1], nums2 = [2,2] * Output: [2,2] * æ²¡å•¥æ€è·¯ï¼Œ å‚»é€¼äº†ï¼Œæƒ³ç€å¯ä»¥ç”¨hashmapä½†æ˜¯ï¼Œæƒ³åˆ°hashmapçš„keyåªèƒ½å­˜ä¸€ä¸ªvalue * ä½†æ˜¯valueå¯ä»¥è¡¨ç¤ºæ•°é‡å•Š * å‚»é€¼ * */ public class Intersection { public int[] intersect(int[] nums1, int[] nums2) { HashMap maps = new HashMap<>(); ArrayList res = new ArrayList(); for (Integer num : nums1) { if (maps.containsKey(num)) { maps.put(num, maps.get(num) + 1); } else { maps.put(num, 1); } } for (Integer num : nums2) { if (maps.containsKey(num)) { res.add(num); if (maps.get(num) == 1) maps.remove(num); else maps.put(num, maps.get(num) - 1); } } int[] result = new int[res.size()]; for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/380/":{"url":"codes/380/","title":"380. Insert Delete GetRandom O(1)","keywords":"","body":"380. Insert Delete GetRandom O(1) Implement the RandomizedSet class: RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity. Example 1: Input [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2] Explanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Constraints: -231 At most 2 * ``105 calls will be made to insert, remove, and getRandom. There will be at least one element in the data structure when getRandom is called. Solution é€šè¿‡ä½¿ç”¨hashmapå’Œvectoræ¥å®ç°ï¼Œhashmapæ¥è®°å½•æ•°å­—åœ¨vectorä¸­indexçš„ä½ç½®ã€‚å½“éœ€è¦removeçš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæœ€åè¯¥æ•°å­—æ”¾åˆ°vectorçš„æœ«å°¾ï¼Œç„¶ååˆ é™¤æ‰æœ€åä¸€ä¸ªæ•°å­—ï¼Œè¿™æ ·çš„è¯å°±åªéœ€è¦O(1)çš„å¤æ‚åº¦ã€‚removeçš„æ—¶å€™åªéœ€è¦æ›´æ–°indexä½ç½®å°±è¡Œã€‚ class RandomizedSet { private: unordered_map maps; vector vec; std::mt19937 gen; public: RandomizedSet() : gen(std::random_device{}()) {} bool insert(int val) { if (maps.count(val)) return false; maps[val] = vec.size(); vec.push_back(val); return true; } bool remove(int val) { auto it = maps.find(val); if (it == maps.end()) return false; int idx = it->second; int last = vec.back(); vec[idx] = last; maps[last] = idx; vec.pop_back(); maps.erase(it); return true; } int getRandom() { std::uniform_int_distribution<> dis(0, vec.size() - 1); return vec[dis(gen)]; } }; powered by GitbookFile Modify: 2024-11-29 20:46:37 "},"codes/387/":{"url":"codes/387/","title":"387. First Unique Character in a String","keywords":"","body":"387. First Unique Character in a String Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1. Examples: s = \"leetcode\" return 0. s = \"loveleetcode\", return 2. ä½¿ç”¨äº†HashMapçš„æ–¹æ³•ï¼Œå½“å­—ç¬¦åªå‡ºç°ä¸€æ¬¡å°±è®¾ç½®keyä¸ºå½“å‰charï¼Œvalueè®¾ç½®ä¸ºindexï¼Œå¦‚æœå‡ºç°è¶…è¿‡ä¸€æ¬¡ï¼Œå°±æ ‡è®°valueæ˜¯MAXã€‚ç­›é€‰HashMapé‡Œé¢valueä¸æ˜¯MAXï¼Œå¹¶ä¸”è¿”å›å°±è¡Œäº†ã€‚ import java.util.Collections; import java.util.HashMap; public class FirstUnique { public int firstUniqChar(String s) { HashMap map = new HashMap<>(); for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/389/":{"url":"codes/389/","title":"389. Find the Difference","keywords":"","body":"389. Find the Difference You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t. Example 1: Input: s = \"abcd\", t = \"abcde\" Output: \"e\" Explanation: 'e' is the letter that was added. Example 2: Input: s = \"\", t = \"y\" Output: \"y\" Constraints: 0 t.length == s.length + 1 s and t consist of lowercase English letters. Solution é—®å°±æ˜¯hashmapã€‚ class Solution: def findTheDifference(self, s: str, t: str) -> str: maps1 = {} maps2 = {} for x in s: if x not in maps1: maps1[x] = 1 else: maps1[x] += 1 for x in t: if x not in maps1: return x if x not in maps2: maps2[x] = 1 else: maps2[x] += 1 for x in s: if maps1[x] != maps2[x]: return x return None powered by GitbookFile Modify: 2024-11-30 17:57:14 "},"codes/448/":{"url":"codes/448/","title":"448. Find All Numbers Disappeared in an Array","keywords":"","body":"Find All Numbers Disappeared in an Array Find All Numbers Disappeared in an Array Given an array of integers where 1 â‰¤ a[i] â‰¤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1] Output: [5,6] é¢˜è§£ï¼šæ•°ç»„é•¿åº¦1-nï¼Œè¦åˆ¤æ–­æ•°ç»„é‡Œé¢å‡ºç°çš„æ•°å­—æ˜¯ä¸æ˜¯åœ¨1-nä¹‹é—´ï¼Œå¦‚æœå°‘äº†å“ªä¸ªæ•°å­—å°±ç»™è¡¥ä¸Šã€‚ æ¯”å¦‚ï¼š[2,2]æ•°ç»„é•¿åº¦1-2ï¼Œé‚£ä¹ˆæ”¹æ•°ç»„å°‘äº†1ã€‚ solution 1ï¼š åˆšå¼€å§‹è€ƒè™‘çš„æ˜¯å…ˆsortä¸€ä¸‹ï¼Œç„¶ååˆ¤æ–­indexåœ¨0ï¼Œæœ«å°¾å’Œä¸­é—´çš„æƒ…å†µè¿›è¡Œè¡¥å…¨ï¼Œä½†æ˜¯è²Œä¼¼æœ‰ç‚¹æµªè´¹æ—¶é—´äº†ã€‚ã€‚æ‰€ä»¥æ—¶é—´å¤æ‚åº¦æœ‰ç‚¹é«˜$O(nlog_{n} + n)$ã€‚ä¸è¿‡ä¹Ÿç®—æ˜¯ä¸€ç§æ–¹æ³•å¯¹å§ã€‚ã€‚ã€‚o(â•¥ï¹â•¥)o public List findDisappearedNumbers(int[] nums) { List dis = new LinkedList<>(); if (nums.length == 0) return dis; Arrays.sort(nums); int num = nums[0]; while (num > 1) { num --; dis.add(num); } num = nums[0]; for (int i = 1; i solution 2ï¼š çœ‹äº†ä¸€ä¸‹discussionæ„Ÿè§‰ä»–ä»¬å†™çš„æ–¹æ³•å±Œçˆ†äº†ã€‚ã€‚ã€‚å› ä¸ºæ•°ç»„é‡Œé¢çš„æ•°å­—æ˜¯åœ¨æ•°ç»„é•¿åº¦1-nä¹‹å†…çš„ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥åšä¸€ä¸ªæŒ‡ç¤ºå™¨çš„æ ¼å¼ï¼ŒæŠŠæ•°ç»„é‡Œé¢æ¯ä¸ªæ•°å­—æ‰€å¯¹åº”çš„åæ ‡å˜æˆè´Ÿæ•°ï¼Œç„¶åå†å¯»æ‰¾ä¸€ä¸ªarrayé‡Œé¢å“ªäº›æ˜¯è´Ÿæ•°ã€‚å¾ˆæ¬¢å–œã€‚ã€‚ public List findDisappearedNumbers(int[] nums) { List dis = new LinkedList<>(); if (nums.length == 0) return dis; for (int i = 0; i 0) { nums[index] = -nums[index]; } } for (int i = 0; i 0) dis.add(i + 1); return dis; } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/496/":{"url":"codes/496/","title":"496. Next Greater Element I","keywords":"","body":"496. Next Greater Element I The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 , find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1. Return an array ans of length nums1.length such that ans[i] is the next greater element as described above. Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. - 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. - 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3. - 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1. Constraints: 1 0 All integers in nums1 and nums2 are unique. All the integers of nums1 also appear in nums2. Follow up: Could you find an O(nums1.length + nums2.length) solution? Solution å’Œä¸Šé¢é‚£ä¸ªé¢˜æ€è·¯å·®ä¸å¤šï¼Œåªæ˜¯æ¯ä¸ªelementéƒ½æ˜¯uniqueçš„ï¼Œæ‰€ä»¥å¯ä»¥é¢å¤–ä½¿ç”¨hashmapæ¥æ–¹ä¾¿è¿ç®—ã€‚ class Solution { public: vector nextGreaterElement(vector& nums1, vector& nums2) { auto stack = vector(); auto maps = unordered_map(); auto res = vector(nums1.size(), -1); if (nums2.size() == 0) return res; stack.push_back(nums2[0]); maps[nums2[0]] = -1; for (int i = 1; i nums2[i]) break; maps[val] = nums2[i]; stack.pop_back(); } stack.push_back(nums2[i]); } for (int i = 0; i powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/645/":{"url":"codes/645/","title":"645. Set Mismatch","keywords":"","body":"645. Set Mismatch You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: Input: nums = [1,2,2,4] Output: [2,3] Example 2: Input: nums = [1,1] Output: [1,2] Constraints: 2 1 Solution hashmap çš„è§£å†³æ€è·¯ class Solution { public: vector findErrorNums(vector& nums) { auto res = vector(); int r_sum = nums.size() * (nums.size() + 1) / 2; auto maps = unordered_map(); for (int const& num : nums) { maps[num] += 1; if (maps[num] > 1) res.push_back(num); if (maps[num] == 1) { r_sum -= num; } } res.push_back(r_sum); return res; } }; powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/704/":{"url":"codes/704/","title":"704. Binary Search","keywords":"","body":"704. Binary Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1. Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 æ ‡å‡†çš„äºŒåˆ†æŸ¥æ‰¾æ³•ï¼ˆåªèƒ½ç”¨åœ¨æ’è¿‡åºçš„listé‡Œé¢ï¼‰ã€‚æœ‰ä¸€ä¸ªç®—æ³•è®²è§£ï¼š public class BinarySearch { public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left target) right = mid - 1; else left = mid + 1; } return -1; } public static void main(String[] args) { int[] nums = new int[] {-1,0,3,5,9,12}; BinarySearch bs = new BinarySearch(); int res = bs.search(nums, 9); System.out.println(res); } } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/739/":{"url":"codes/739/","title":"739. Daily Temperatures","keywords":"","body":"739. Daily Temperatures Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] Example 3: Input: temperatures = [30,60,90] Output: [1,1,0] Constraints: 1 30 Solution Temperature: [73, 74, 75, 71, 69, 72, 76, 73] stack = [] res = [0, 0, 0, 0, 0, 0, 0, 0] 1. index = 0 stack = [(0, 73)] 2. index = 1 74 > 73, pop (0, 73) and set res[0] = index - 0 stack = [(1, 74)] res = [1, 0, 0, 0, 0, 0, 0, 0] 3. index = 2 75 > 74, pop (1, 74) and set res[1] = index - 1 stack = [(2, 75)] res = [1, 1, 0, 0, 0, 0, 0, 0] 4. index = 3 71 72 pop (5, 72) and (2, 75), set res[5] = index - 5, and res[2] = index -2 stack = [] res = [1, 1, 4, 2, 1, 1, 0, 0] è¿™ä¸ªæ˜¯çœŸæ˜¯é¢è¯•é¢˜ï¼Œ21å¹´çš„æ—¶å€™é¢è¯•çš„æ—¶å€™é‡åˆ°äº†ã€‚å¯ä»¥é‡‡ç”¨ stack æ•°æ®ç»“æ„çš„è§£å†³æ–¹æ³•ã€‚å½“éå†å½“å‰æ¸©åº¦çš„æ—¶å€™å»åˆ¤æ–­ stack é‡Œé¢çš„å…ƒç´ æ˜¯å¦å°äºå½“å‰æ¸©åº¦ï¼Œå¦‚æœå°äºçš„è¯åˆ™ pop ï¼Œæœ€åç»“æŸå¾ªç¯çš„æ—¶å€™æŠŠå½“å‰æ¸©åº¦æ·»åŠ åˆ° stack ä¸­ï¼Œå› ä¸ºæ¯ä¸ªæ¸©åº¦éƒ½è¦æ‰¾åˆ°æ¯”å½“å‰å¤§çš„æ¸©åº¦ã€‚ class Solution { public: vector dailyTemperatures(vector& temperatures) { auto stack = std::vector>(); auto res = vector(temperatures.size(), 0); for (int i = 0; i val = stack.back(); if (val.first >= t) break; res[val.second] = i - val.second; stack.pop_back(); } stack.push_back(pair(t, i)); } return res; } }; powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/1019/":{"url":"codes/1019/","title":"1019. Next Greater Node In Linked List","keywords":"","body":"1019. Next Greater Node In Linked List Next Greater Node In Linked List is a medium problem. We are given a linked list with head as the first node. Let's number the nodes in the list: node_1, node_2, node_3, ... etc. Each node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j > i, node_j.val > node_i.val, and j is the smallest possible choice. If such a j does not exist, the next larger value is 0. Return an array of integers answer, where answer[i] = next_larger(node_{i+1}). Note that in the example inputs (not outputs) below, arrays such as [2,1,5] represent the serialization of a linked list with a head node value of 2, second node value of 1, and third node value of 5. Approach This problem is pretty similar with Daily Temperatures which can be solved by applying stack. For this issue, we can use stack + hashmap to solve it with $O(n)$ time complexity. Init stack and the final result. result(hashmap) will recored the index as key and greater or 0 value as the value When the temp node value is greater then the top value of the stack, update the result value and pop the top value of stack. # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def nextLargerNodes(self, head: ListNode) -> List[int]: stack = [] result = {} temp = head index = 0 # stack store like (val, pos) while (temp != None): while len(stack) != 0 and temp.val > stack[len(stack) - 1][0]: result[stack[len(stack) - 1][1]] = temp.val stack.pop(len(stack) - 1) stack.append((temp.val, index)) result[index] = 0 index += 1 temp = temp.next return result.values() We can use the following data to give an example: Input: [2,1,5] Output: [5,5,0] In the following part, we will display the result and stack storage. 1. stack.push((2, 0)) stack = [(2, 0)], result = {0: 0} 2. stack.push((1, 1)), stack = [(2, 0), (1, 1)], result = {0: 0, 1: 0} 3. The node value is 5, greater than 1, then 1. top value of stack is (1, 1), then result[1] = node.val (5), stack pop (1, 1) 2. top value of stack is (2, 0), then result[0] = node.val (5), stack pop (2, 0) 3. End while loop, and insert the (5, 3) into stack and result. The final value in result is: result = { 0: 5, 1: 5, 2: 0 } powered by GitbookFile Modify: 2024-11-28 21:26:51 "},"codes/1365/":{"url":"codes/1365/","title":"1365. How Many Numbers Are Smaller Than the Current Number","keywords":"","body":"1365. How Many Numbers Are Smaller Than the Current Number How Many Numbers Are Smaller Than the Current Number is an easy problem. Howerver, it is more interesting than other questions. Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] . Example 1: Input: nums = [8,1,2,2,3] Output: [4,0,1,1,3] Explanation: For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). For nums[1]=1 does not exist any smaller number than it. For nums[2]=2 there exist one smaller number than it (1). For nums[3]=2 there exist one smaller number than it (1). For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2). Approach Naive approach is brute force. Just use two nest loop can get the result. result = [] for i in range(0, len(nums)): num = 0 for j in range(i, len(nums)): if nums[i] > nums[j]: num += 1 result.append(num) The time complexity is O(n^2) powered by GitbookFile Modify: 2024-11-28 21:26:51 "}}