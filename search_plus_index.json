{"./":{"url":"./","title":"Introduction","keywords":"","body":"Leetcode æœ€è¿‘å› ä¸ºä¸€äº›äº‹æƒ…åˆå¼€å§‹åˆ·é¢˜äº†ï¼Œæ‰€ä»¥è¿™ä¸ªå½“ä½œè®°å½•åˆ·é¢˜ç¬”è®°çš„ç½‘ç«™å§ã€‚ 2024/12/16 è¾¾åˆ°ç›®æ ‡çš„ä¸€åŠï¼Œ150äº† powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/uf/":{"url":"codes/uf/","title":"Union Find","keywords":"","body":"Union Find Union-Findï¼ˆåˆç§°å¹¶æŸ¥é›†ï¼‰æ˜¯ä¸€ç§å¸¸ç”¨çš„æ•°æ®ç»“æ„ï¼Œä¸»è¦ç”¨äºè§£å†³åŠ¨æ€è¿é€šæ€§é—®é¢˜ï¼Œæ¯”å¦‚åˆ¤æ–­æŸäº›å…ƒç´ æ˜¯å¦å±äºåŒä¸€ç»„ï¼Œæˆ–åˆå¹¶ä¸¤ä¸ªç»„ã€‚ åŸºæœ¬åŠŸèƒ½ Findï¼šæ‰¾åˆ°æŸä¸ªå…ƒç´ æ‰€å±ç»„çš„ä»£è¡¨å…ƒç´ ï¼ˆä¹Ÿå«æ ¹èŠ‚ç‚¹ï¼‰ã€‚ Unionï¼šå°†ä¸¤ä¸ªç»„åˆå¹¶æˆä¸€ä¸ªç»„ã€‚ å·¥ä½œåŸç† åˆå§‹åŒ–ï¼šæ¯ä¸ªå…ƒç´ è‡ªæˆä¸€ç»„ï¼Œparent[i] = iã€‚ Find æ“ä½œï¼š é€šè¿‡é€’å½’æˆ–è¿­ä»£æ‰¾åˆ°æŸä¸ªå…ƒç´ çš„æ ¹èŠ‚ç‚¹ã€‚ è·¯å¾„å‹ç¼©ä¼˜åŒ–ï¼šåœ¨æŸ¥æ‰¾æ—¶å°†è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ç›´æ¥æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼Œå‡å°‘åç»­æ“ä½œçš„æŸ¥æ‰¾æ·±åº¦ã€‚ Union æ“ä½œï¼š å°†ä¸¤ä¸ªç»„çš„æ ¹èŠ‚ç‚¹è¿æ¥ã€‚ æŒ‰ç§©åˆå¹¶ä¼˜åŒ–ï¼šå°†èŠ‚ç‚¹æ•°å°‘çš„æ ‘æŒ‚åˆ°èŠ‚ç‚¹æ•°å¤šçš„æ ‘ä¸Šï¼Œæˆ–æ ¹æ®æ·±åº¦å†³å®šå¦‚ä½•åˆå¹¶ï¼Œé¿å…æ ‘å˜å¾—è¿‡é«˜ã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i 0 åœ¨ Union-Find ä¸­ï¼Œæœ€å·®çš„æƒ…å†µå‘ç”Ÿåœ¨æ²¡æœ‰ä»»ä½•ä¼˜åŒ–æ—¶ï¼Œå½“æ‰€æœ‰å…ƒç´ å½¢æˆä¸€ä¸ªé“¾è¡¨ç»“æ„ï¼ŒæŸ¥è¯¢å¤æ‚åº¦ä¼šé€€åŒ–ä¸º O(n) å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚ Optimization è·¯å¾„å‹ç¼©ï¼š åœ¨ find æ“ä½œæ—¶ï¼Œå°†è®¿é—®è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹ç›´æ¥è¿æ¥åˆ°æ ¹èŠ‚ç‚¹ã€‚ å‹ç¼©åï¼ŒæŸ¥è¯¢æ ‘çš„é«˜åº¦è¶‹å‘äº O(log n) æˆ–æ›´ä½ (O(1))ã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i åœ¨ find æ–¹æ³•ä¸­ï¼š ä½¿ç”¨é€’å½’å®ç°è·¯å¾„å‹ç¼©ï¼šroot[x] = find(root[x]);ã€‚ è¿™ä¼šå°†èŠ‚ç‚¹ x çš„çˆ¶èŠ‚ç‚¹ç›´æ¥è®¾ç½®ä¸ºæ ¹èŠ‚ç‚¹ï¼Œä»è€Œå‡å°‘æ ‘çš„æ·±åº¦ã€‚ è¿™æ ·çš„è¯ä¸Šé¢å›¾ä¸­4, 3, 2, 1çš„rootéƒ½ä¼šç›´æ¥æŒ‡å‘0ã€‚è¿™æ ·çš„è¯æŸ¥è¯¢æ•ˆç‡ä¼šæå‡å¾ˆå¤šã€‚ powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/uf/648.html":{"url":"codes/uf/648.html","title":"684. Redundant Connection","keywords":"","body":"684. Redundant Connection In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input. Example 1: Input: edges = [[1,2],[1,3],[2,3]] Output: [2,3] Example 2: Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]] Output: [1,4] Solution è¿™ä¸ªé—®é¢˜è¿˜æ˜¯ç›´æ¥ç”¨union-findå°±è¡Œã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i findRedundantConnection(vector>& edges) { auto res = vector(); auto uf = UnionFind(edges.size() + 1); for (vector& edge : edges) { int u = edge[0], v = edge[1]; if (uf.is_connected(u, v)) { res.push_back(u); res.push_back(v); break; } uf.union_(u, v); } return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/uf/785.html":{"url":"codes/uf/785.html","title":"785. Is Graph Bipartite?","keywords":"","body":"785. Is Graph Bipartite? There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties: There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them. A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. Return true if and only if it is bipartite. Example 1: Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]] Output: false Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other. Example 2: Input: graph = [[1,3],[0,2],[1,3],[0,2]] Output: true Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}. Constraints: graph.length == n 1 0 0 graph[u] does not contain u. All the values of graph[u] are unique. If graph[u] contains v, then graph[v] contains u. Solution ä¹Ÿæ˜¯é€šè¿‡union-findç»“æ„æ¥å®ç°çš„ï¼Œä½†å€¼å¾—æ³¨æ„çš„æ˜¯ä½¿ç”¨çš„æ–¹æ³•ã€‚æ ¹æ®äºŒéƒ¨å›¾çš„ç‰¹æ€§graph[u]æ˜¯uç‚¹æ‰€æœ‰çš„é‚»å±…ï¼Œé‚£ä¹ˆè¿™äº›é‚»å±…åº”è¯¥æ˜¯å±äºåŒä¸€ä¸ªsetã€‚å¦‚æœæŠŠä»–ä»¬æ‰€æœ‰çš„é‚»å±…éƒ½è”é€šèµ·æ¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­uå’Œvæ˜¯å¦è”é€šå°±è¡Œï¼Œä¸è¿é€šåˆ™ä»£è¡¨åœ¨ä¸åŒçš„setã€‚ é€šè¿‡å°† graph[u][0] ä½œä¸ºåŸºå‡†ï¼Œå°è¯•æŠŠèŠ‚ç‚¹ u å’Œæ‰€æœ‰é‚»å±…åˆ†å…¥ä¸åŒçš„ç»„ã€‚å…³é”®æ˜¯ï¼Œå®ƒå®ç°äº†ä¸€ä¸ªç›¸å¯¹ç®€å•çš„â€œç»„ç®¡ç†â€é€»è¾‘ã€‚è‹¥å‡ºç°çŸ›ç›¾ï¼ˆu å’ŒæŸä¸ªé‚»å±…åœ¨åŒä¸€ç»„ï¼‰ï¼Œå³å¯ç›´æ¥è¿”å› falseã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i >& graph) { auto uf = UnionFind(graph.size()); for (int u = 0; u powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/uf/990.html":{"url":"codes/uf/990.html","title":"990. Satisfiability of Equality Equations","keywords":"","body":"990. Satisfiability of Equality Equations You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names. Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise. Example 1: Input: equations = [\"a==b\",\"b!=a\"] Output: false Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations. Example 2: Input: equations = [\"b==a\",\"a==b\"] Output: true Explanation: We could assign a = 1 and b = 1 to satisfy both equations. Solution å¯ä»¥æŠŠè¿™ä¸ªé—®é¢˜è€ƒè™‘æˆå›¾ç®—æ³•æ¥å¤„ç†ï¼Œæ¯”å¦‚a==bæˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ˜¯aå’Œbæ˜¯è”é€šçš„ã€‚æˆ‘ä»¬éœ€è¦å…ˆéå†æ‰€æœ‰==çš„stringï¼Œå¹¶ä¸”æŠŠä»–ä»¬connectåˆ°ä¸€èµ·ã€‚ç„¶åå»éå†!=çš„æ“ä½œï¼Œåˆ¤æ–­æ˜¯å¦è”é€šï¼Œå¦‚æœæ˜¯è”é€šä½†æ˜¯ç¬¦å·æ˜¯!=åˆ™è¿”å›falseã€‚ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i & equations) { auto uf = UnionFind(26); for (string const& s : equations) { if (s[1] == '=') { uf.union_(s[0] - 'a', s[3] - 'a'); } } for (string const& s : equations) { if (s[1] == '!') { if (uf.is_connected(s[0] - 'a', s[3] - 'a')) return false; } } return true; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/ml/":{"url":"codes/ml/","title":"Monotonic List","keywords":"","body":"å•è°ƒé˜Ÿåˆ— ï¼ˆMonotonic Listï¼‰ å•è°ƒé˜Ÿåˆ—å¯ä»¥ç®€å•ç†è§£ä¸ºå•è°ƒé€’å¢æˆ–è€…å•è°ƒé€’å‡çš„é˜Ÿåˆ—ã€‚ è§£é¢˜æ¨¡æ¿ä¸€èˆ¬å¦‚ä¸‹ï¼š pop_backï¼šé˜Ÿåˆ—æœ«å°¾å…ƒç´ å‡ºåˆ—ï¼Œå½“æœ‰æ–°çš„å…ƒç´ åŠ å…¥è¿›æ¥ä½†æ˜¯ä¸æ»¡è¶³å•è°ƒæ€§è¦æ±‚å¯ä»¥åˆ é™¤æ‰å½±å“çš„å…ƒç´  pop_frontï¼šé˜Ÿåˆ—é¦–å…ƒç´ å‡ºåˆ—ï¼Œå½“è¾¾åˆ°æ¡ä»¶é™åˆ¶çš„æ—¶å€™æ¥åˆ é™¤æ‰ä¸ç¬¦åˆæ¡ä»¶çš„å…ƒç´ ï¼Œæ¯”å¦‚kä¸ªelementsè¿™ç§æ¡ä»¶ frontï¼šå–å‡ºé˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¸€èˆ¬ä¸ºæˆ‘ä»¬éœ€è¦çš„å†…å®¹æ‹é‚£ä¸ªã€‚ åœ¨c++ä¸­å› ä¸ºæ²¡æœ‰å•è°ƒé˜Ÿåˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨listæˆ–è€…dequeæ¥æ›¿æ¢ï¼Œå¯ä»¥è¾¾åˆ°ç›¸åŒçš„æ•ˆæœï¼Œä½†æ˜¯æ•ˆç‡è²Œä¼¼ä¸æ˜¯ç‰¹åˆ«é«˜ã€‚ void MonotonicQueue(vector& nums, int k) { deque q; vector res; for (int i = 0; i = k) q.pop_front(); // remove from head, ensure k while (!q.empty() && nums[q.back()] powered by GitbookFile Modify: 2025-01-20 19:10:26 "},"codes/ml/239.html":{"url":"codes/ml/239.html","title":"239. Sliding Window Maximum","keywords":"","body":"239. Sliding Window Maximum (hard) You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1] Solution è¿™ä¸ªé¢˜å°±æ˜¯ä½¿ç”¨å•è°ƒé˜Ÿåˆ—æ¥è§£å†³çš„ã€‚ class Solution { public: vector maxSlidingWindow(vector& nums, int k) { deque vec; vector res; res.resize(nums.size() - k + 1); int sidx = 0; int max_val = INT_MIN; for (int i = 0; i = k) { vec.pop_front(); } while (!vec.empty() && nums[vec.back()] = 0) res[sidx] = nums[vec.front()]; } return res; } }; powered by GitbookFile Modify: 2025-01-20 19:06:16 "},"codes/ml/862.html":{"url":"codes/ml/862.html","title":"862. Shortest Subarray with Sum at Least K","keywords":"","body":"862. Shortest Subarray with Sum at Least K (hard) Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1. A subarray is a contiguous part of an array. Example 1: Input: nums = [1], k = 1 Output: 1 Example 2: Input: nums = [1,2], k = 4 Output: -1 Example 3: Input: nums = [2,-1,2], k = 3 Output: 3 Solution å°è¯•è¿‡sliding windowï¼Œä½†æ˜¯æ»‘åŠ¨çª—å£åœ¨é‡åˆ°è´Ÿæ•°çš„æ—¶å€™leftæ²¡åŠæ³•ç»§ç»­æ”¶æ•›äº†ï¼Œä¼šå‡ºé”™ã€‚å®˜æ–¹çš„æ•™ç¨‹æ˜¯ä½¿ç”¨prefix sumå’Œå•è°ƒé˜Ÿåˆ—æ¥å®ç°ã€‚prefixçš„ä½œç”¨å°±æ˜¯å¯ä»¥å¿«é€Ÿå¾—åˆ°iå’Œjçš„sumã€‚è€Œå•è°ƒé˜Ÿåˆ—çš„ä½œç”¨å°±æ˜¯ä¸ºäº†ç­›é€‰æ‰ä¸€äº›ä¸æ»¡è¶³çš„æƒ…å†µï¼Œæ¯”å¦‚q[last] >= prefix[i]ï¼Œæˆ‘ä»¬éœ€è¦æŠŠé˜Ÿåˆ—ä¸­çš„å…ƒç´ popå‡ºå»ï¼Œå› ä¸ºå¦‚æœé˜Ÿåˆ—ä¸­çš„å…ƒç´ æ¯”æ­£åœ¨è®¿é—®çš„å…ƒç´ è¿˜è¦å¤§çš„è¯ï¼Œé‚£å°±è¯æ˜éœ€è¦çš„subarrayæ›´é•¿ï¼Œæ‰€ä»¥ä¸æ»¡è¶³shortestï¼Œå¯ä»¥æå‰æ’é™¤æ‰ã€‚ 1. å‰”é™¤æ— æ•ˆå€™é€‰ å¦‚æœå½“å‰å‰ç¼€å’Œ prefix[j] å°äºæˆ–ç­‰äºé˜Ÿå°¾ç´¢å¼•å¯¹åº”çš„å‰ç¼€å’Œ prefix[dq.back()]ï¼Œé˜Ÿå°¾ç´¢å¼•æ˜¯æ— æ•ˆçš„ï¼ˆæ— è®ºæ˜¯å¦åŒ…å«è´Ÿæ•°ï¼‰ï¼Œå› ä¸ºï¼š prefix[j] æ›´å°ï¼Œä¸”ç´¢å¼•æ›´é å³ï¼Œèƒ½æä¾›æ›´ä¼˜è§£ã€‚ è¿™ç§é€»è¾‘ç¡®ä¿è´Ÿæ•°ä¸ä¼šå¹²æ‰°é˜Ÿåˆ—çš„æœ‰æ•ˆæ€§ã€‚ while (!q.empty() && prefix[q.back()] >= prefix[i]) { q.pop_back(); } q.push_back(j); 2. å¿«é€Ÿåˆ¤æ–­æ¡ä»¶ å³ä½¿è´Ÿæ•°ä½¿å¾—å‰ç¼€å’Œä¸‹é™ï¼Œæˆ‘ä»¬ä»å¯ä»¥é€šè¿‡æ¯”è¾ƒ prefix[j] - prefix[dq.front()] æ˜¯å¦æ»¡è¶³æ¡ä»¶ >= kï¼Œå¿«é€Ÿæ‰¾åˆ°è§£ã€‚ é˜Ÿåˆ—å¤´éƒ¨å§‹ç»ˆä¿å­˜äº†å½“å‰çš„æœ€å°å‰ç¼€å’Œç´¢å¼•ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¿«é€Ÿåˆ¤æ–­æ˜¯å¦æ»¡è¶³è¦æ±‚ï¼Œè€Œæ— éœ€è€ƒè™‘è´Ÿæ•°çš„ç›´æ¥å½±å“ã€‚ while (!q.empty() && prefix[j] - prefix[q.front()] >= k) { lens = lens > i - q.front() ? i - q.front() : lens; q.pop_front(); } æœ€ç»ˆä»£ç ï¼š class Solution { public: int shortestSubarray(vector& nums, int k) { auto prefix = vector(nums.size() + 1, 0); auto q = deque(); for (int i = 0; i = k) { lens = lens > i - q.front() ? i - q.front() : lens; q.pop_front(); } while (!q.empty() && prefix[q.back()] >= prefix[i]) { q.pop_back(); } q.push_back(i); } return lens == INT_MAX ? -1 : lens; } }; powered by GitbookFile Modify: 2025-01-20 19:06:35 "},"codes/ml/1425.html":{"url":"codes/ml/1425.html","title":"1425. Constrained Subsequence Su","keywords":"","body":"1425. Constrained Subsequence Sum (hard) Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i , the condition j - i is satisfied. A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order. Example 1: Input: nums = [10,2,-10,5,20], k = 2 Output: 37 Explanation: The subsequence is [10, 2, 5, 20]. Example 2: Input: nums = [-1,-2,-3], k = 1 Output: -1 Explanation: The subsequence must be non-empty, so we choose the largest number. Example 3: Input: nums = [10,-2,-10,-5,20], k = 2 Output: 23 Explanation: The subsequence is [10, -2, -5, 20]. Solution è¿™ä¸ªé¢˜æœ‰ä¸¤ç§è§£æ³•, ä¸€ç§æ˜¯priority_queueæ¥è§£å†³, å¦ä¸€ç§æ˜¯ä½¿ç”¨å•è°ƒé˜Ÿåˆ—ã€‚ S1 ä½¿ç”¨priority_queueæ¥è§£å†³çš„è¯, æˆ‘ä»¬å¯ä»¥æŠŠå‰é¢çš„ç»“æœå½“ä½œä¼˜å…ˆçº§æ¥å¤„ç†, è®°å½•æ¯æ¬¡è¿ç®—çš„ç»“æœã€‚å…¶å®è¿™ä¹Ÿç®—æ˜¯è´ªå¿ƒç®—æ³•çš„ä¸€ç§ï¼Œå› ä¸ºæ¯æ¬¡æˆ‘å…ˆæ‹¿åˆ°çš„éƒ½æ˜¯å‰é¢è¿ç®—çš„æœ€å¤§å€¼ã€‚ å€¼å¾—æ³¨æ„çš„å°±æ˜¯å½“æˆ‘ä»¬é‡åˆ°pqæœ€å¤§æ•°å­—æ˜¯è´Ÿæ•°çš„æ—¶å€™æˆ‘ä»¬éœ€è¦è·³è¿‡è¿™ä¸ªè¿ç®—ï¼Œå› ä¸ºå½“æœ€å¤§ç»“æœæ˜¯è´Ÿæ•°çš„æ—¶å€™ï¼Œä¸ç®¡æ€ä¹ˆè¿ç®—æˆ‘å¾—åˆ°çš„ç»“æœåªä¼šå˜å°ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è·³è¿‡è¿™ä¸ªç»“æœï¼Œç›¸å½“äºä»å½“å‰è¿™ä¸ªæ•°å­—é‡æ–°å¼€å§‹è¿ç®—æ‰¾subarrayã€‚ int tmp = nums[i] + max(0, pq.top().first); æœ€ç»ˆç»“æœï¼š class Solution { public: int constrainedSubsetSum(vector& nums, int k) { priority_queue> pq; int sum = nums[0]; pq.emplace(nums[0], 0); for (int i = 1; i k) pq.pop(); // compute the sum, compare, if already negative, then restart int tmp = nums[i] + max(0, pq.top().first); sum = sum > tmp ? sum : tmp; pq.emplace(tmp, i); } return sum; } }; S2 ç¬¬äºŒç§æ–¹æ³•å°±æ˜¯ä½¿ç”¨dequeï¼ˆå•è°ƒé˜Ÿåˆ—ï¼‰çš„æ–¹å¼æ¥è§£å†³äº†ã€‚å…¶å®æ€è·¯å’Œpriority_queueçš„æ–¹æ³•æ˜¯å·®ä¸å¤šçš„ï¼Œéƒ½æ˜¯ä¸ºäº†æ‹¿åˆ°æœ€å¤§å€¼ã€‚ä¸åŒçš„æ˜¯æˆ‘ä»¬éœ€è¦æŠŠæ¯”å½“å‰ç»“æœtmpå°çš„å€¼popå‡ºå»ï¼Œå› ä¸ºå¦‚æœæ¯”å½“å‰ç»“æœå°çš„è¯å°±ä»£è¡¨ä¸å¯èƒ½æ˜¯æœ€ä¼˜è§£äº†ã€‚ class Solution { public: int constrainedSubsetSum(vector& nums, int k) { deque> dq; int sum = nums[0]; for (int i = 0; i k) dq.pop_front(); int tmp = nums[i] + max(0, dq.front().first); sum = sum > tmp ? sum : tmp; while (!dq.empty() && tmp >= dq.back().first) dq.pop_back(); dq.emplace_back(tmp, i); } return sum; } }; powered by GitbookFile Modify: 2025-01-20 19:07:07 "},"codes/ml/1438.html":{"url":"codes/ml/1438.html","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","keywords":"","body":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit. Example 1: Input: nums = [8,2,4,7], limit = 4 Output: 2 Explanation: All subarrays are: [8] with maximum absolute diff |8-8| = 0 4. [8,2,4] with maximum absolute diff |8-2| = 6 > 4. [8,2,4,7] with maximum absolute diff |8-2| = 6 > 4. [2] with maximum absolute diff |2-2| = 0 4. [4] with maximum absolute diff |4-4| = 0 Example 2: Input: nums = [10,1,2,4,7,2], limit = 5 Output: 4 Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 Example 3: Input: nums = [4,2,2,2,4,4,2,2], limit = 0 Output: 3 Solution ä¹Ÿæ˜¯å±…äºsliding windowçš„æ€è·¯æ¥è§£å†³çš„ï¼Œä½†æ˜¯ä¸åŒçš„æ˜¯ï¼Œéœ€è¦å¿«é€Ÿå¾—åˆ°sliding windowé‡Œé¢çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼Œæ‰€ä»¥ä½¿ç”¨äº†ä¸¤ä¸ªå•è°ƒé˜Ÿåˆ—ï¼š æœ€å¤§å€¼å•è°ƒé˜Ÿåˆ— (maxDeque)ï¼šå­˜å‚¨å½“å‰çª—å£ä¸­å…ƒç´ å€¼ï¼Œä»å¤§åˆ°å°æ’åˆ—ï¼Œé˜Ÿå¤´æ˜¯æœ€å¤§å€¼ã€‚ æœ€å°å€¼å•è°ƒé˜Ÿåˆ— (minDeque)ï¼šå­˜å‚¨å½“å‰çª—å£ä¸­å…ƒç´ å€¼ï¼Œä»å°åˆ°å¤§æ’åˆ—ï¼Œé˜Ÿå¤´æ˜¯æœ€å°å€¼ã€‚ å› ä¸ºæˆ‘ä»¬è€ƒè™‘çš„æ˜¯longestæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦è€ƒè™‘windowé‡Œé¢çš„æœ€å¤§å€¼å’Œæœ€å°å€¼å·®å€¼æ˜¯å¤šå°‘ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦æ”¶ç¼©çª—å£ã€‚ class Solution { public: int longestSubarray(vector& nums, int limit) { deque maxD; // decreasing deque minD; // increasing int left = 0; int res = 0; for (int i = 0; i nums[i]) minD.pop_back(); minD.push_back(i); while (!maxD.empty() && !minD.empty() && nums[maxD.front()] - nums[minD.front()] > limit) { if (maxD.front() == left) maxD.pop_front(); if (minD.front() == left) minD.pop_front(); left ++; // shrink the window } res = res > i - left + 1 ? res : i - left + 1; } return res; } }; æœ‰ä¸ªè®²è§£è§†é¢‘ä¸é”™ï¼Œå¯ä»¥å‚è€ƒä¸€ä¸‹ï¼šhttps://www.youtube.com/watch?v=V-ecDfY5xEw powered by GitbookFile Modify: 2025-01-20 19:07:24 "},"codes/1/":{"url":"codes/1/","title":"1. Two Sum","keywords":"","body":"Two Sum Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. è¿™ä¹Ÿæ˜¯æˆ‘ç¬¬ä¸€æ¬¡é¢è¯•çš„ç¬¬ä¸€ä¸ªç®—æ³•ï¼Œå½“æ—¶æƒ³çš„æ–¹æ³•æ˜¯æœ€æš´åŠ›çš„æ–¹æ³•ï¼Œç›´æ¥ä¸¤ä¸ªå¾ªç¯å®Œäº‹ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ˜¯O(n2) O(n^{2}) O(nâ€‹2â€‹â€‹) ï¼Œé‚£æ˜¯ç›¸å½“çš„é«˜o(â•¥ï¹â•¥)oã€‚åæ¥æƒ³äº†ä¸€ä¸‹æ‰¾åˆ°äº†ä¸€ä¸ªç®€å•çš„æ–¹æ³•ï¼Œå½“æ—¶ç”±äºå¤ªç´§å¼ å†™çš„ä¸å¤ªå¥½ã€‚å½“æ—¶çš„é—®é¢˜æ–¹æ³•ä¹Ÿç¨å¾®æœ‰ç‚¹ä¸åŒï¼Œå½“æ—¶è¦æ±‚çš„æ˜¯æ‰¾åˆ°ç›¸å¯¹åº”çš„æ•°å­—ï¼Œä¸æ˜¯indexã€‚ å…ˆå›é¡¾ä¸€ä¸‹å½“æ—¶çš„ç®—æ³•ï¼š int[] another(int[] nums, int target) { int head = 0; int tail = 0; // sort it Arrays.sort(nums); while (true) { int value = nums[head] + nums[tail]; if (value == target) break; else if (value > target) tail -= 1; else head += 1; if (head == tail) break; } if (head != tail) return new int[] {nums[head], nums[tail]}; return null; } å½“æ—¶æƒ³åˆ°çš„æ˜¯ä¸¤å¤´åŒæ—¶éå†çš„æ–¹æ³•ï¼Œä½†æ˜¯æœ‰ä¸ªå‰æè¦æ±‚å°±æ˜¯listå¿…é¡»æ˜¯æ’è¿‡åºçš„ï¼Œå½“numsæ— é™å¤§æ—¶æ’åºæ‰€æ¶ˆè€—çš„æ—¶é—´å¯ä»¥å¿½ç•¥çš„ï¼Œè¿™ä¸ªæ–¹æ³•æœ‰ç‚¹ç±»ä¼¼äºbinary searchã€‚æˆ‘å½“æ—¶ä¹Ÿæƒ³è¿‡ç”¨HashMapï¼Œå¥½åƒå¤„äºä»€ä¹ˆåŸå› è¢«é¢è¯•å®˜å¦å®šäº†ï¼Œwhateverä¸é‡è¦çš„ã€‚ä¸é—²æ‰¯äº†ï¼Œæˆ‘ä»¬å¼€å§‹çœ‹è¿™é¢˜çš„æ¯”è¾ƒä¼˜åŒ–çš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(n)ã€‚ int[] twoSum(int[] nums, int target) { Map map = new HashMap<>(); for (int i = 0; i ç®—æ³•æ€è·¯ï¼š å› ä¸ºæ˜¯ç”¨çš„HashMapæ‰€ä»¥åœ¨æ£€æµ‹keyæ˜¯å¦containçš„è¯ä½¿ç”¨çš„æ˜¯hashçš„æ–¹æ³•ï¼Œæ‰€ä»¥å¤æ‚åº¦æ˜¯$O(1)$ ç¬¬7-11è¡Œï¼Œæ˜¯æ¥åˆ¤æ–­è¿™ä¸ªHashMapæ˜¯å¦åŒ…å«è¿™ä¸ªnumï¼Œå¦‚æœè¿™ä¸ªnumä¸åŒ…å«åœ¨HashMapé‡Œé¢ï¼Œç„¶åæŠŠè¯¥numå­˜åˆ°HashMapé‡Œé¢ï¼Œnumå½“åškeyï¼Œindexå½“åšvalueã€‚è¿™æ ·å°±ç›¸å½“äºæŠŠè®¿é—®è¿‡çš„numå’Œnumçš„indexå­˜åˆ°HashMapé‡Œé¢ï¼Œç„¶åå†éå†numsçš„æ—¶å€™å¾—å¯¹æ¯ä¸ªæ•°å¯ä»¥å¾—åˆ°ä¸€ä¸ªå·®å€¼ï¼Œç„¶ååˆ¤æ–­è¿™ä¸ªå·®å€¼æ˜¯å¦å­˜åœ¨HashMapé‡Œé¢ï¼Œå¦‚æœå­˜åœ¨å°±ä»£è¡¨å¾—åˆ°è¿™ä¸ªç»“æœäº†ï¼Œå¦‚æœä¸å­˜åœ¨å°±æŠŠè¿™ä¸ªnums[i]å­˜åˆ°HashMapã€‚ powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/2/":{"url":"codes/2/","title":"2. Add Two Numbers","keywords":"","body":"Add Two Numbers Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. ç®—æ³•æ€æƒ³ï¼š ä¸»è¦åº”è¯¥è€ƒè™‘ä¸€ä¸‹è¾¹ç•Œæƒ…å†µï¼š å½“sum>=10 ä¸¤ä¸ªé“¾è¡¨ä¸ä¸€æ ·é•¿ åœ¨æœ€åä¸€ä¸ªæ•°å­—ç›¸åŠ çš„æ—¶å€™sum>=10 ç¬¬6è¡Œçš„whileè¯­å¥å°±æ˜¯ä¸ºäº†ä¸¤æ¡é“¾è¡¨ä¸ä¸€æ ·é•¿åº¦ã€‚ç¬¬7-8è¡Œåˆ¤æ–­å¦‚æœè¯¥é“¾è¡¨ä¸ä¸ºnullå°±å–è¯¥valï¼Œä¸ç„¶çš„è¯å°±ä¸º0ï¼ˆä¸ºäº†ä¸å½±å“ä¸‹é¢çš„è®¡ç®—ï¼‰ã€‚int overflow = 0æ˜¯ä¸ºäº†è§£å†³å’Œè¶…è¿‡10çš„æƒ…å†µï¼Œç¬¬9è¡ŒæŠŠæº¢å‡ºçš„æ•°å­—å’Œv1ï¼Œv2ç›¸åŠ ï¼Œç„¶åæŠŠè¯¥ç»“æœå–ä½™å°±æ˜¯ç»“æœã€‚ç„¶åæŠŠoverflow = sum/10 å¾—åˆ°è¿›ä½æ•°ã€‚æ¯æ¬¡ç”Ÿæˆæ–°çš„æ•°å­—ä¹‹åç”Ÿæˆä¸€ä¸ªæ–°çš„nodeæ²¡ç„¶åé“¾æ¥èµ·æ¥ã€‚ä¸»è¦æ˜¯è€ƒè™‘ä¸åŒçš„è¾¹ç•Œæƒ…å†µã€‚ public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int overflow = 0; if (l1 == null && l2 == null) return null; ListNode new_node = new ListNode(); ListNode head = new_node; while (l1 != null || l2 != null) { int v1 = (l1 != null) ? l1.val : 0; int v2 = (l2 != null) ? l2.val : 0; int sum = v1+v2 + overflow; overflow = sum / 10; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; new_node.val = sum % 10; if (l1 != null || l2 != null) { new_node.next = new ListNode(); new_node = new_node.next; } } if (overflow > 0) { new_node.next = new ListNode(overflow % 10); } return head; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/3/":{"url":"codes/3/","title":"3. Longest Substring Without Repeating Characters","keywords":"","body":"Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. è§£é¢˜æ–¹æ³•&æ€è·¯ï¼š é¦–å…ˆè¯´ä¸‹é¢˜æ„ï¼Œæˆ‘åˆšå¼€å§‹æ˜¯æ²¡ç†è§£é¢˜æ„æ¥å¾—ï¼ˆæš´éœ²äº†è‡ªå·±çš„æ— çŸ¥â•®(â•¯â–½â•°)â•­ï¼‰ï¼Œé¢˜æ„å°±æ˜¯åŒ¹é…åˆ°æœ€é•¿çš„å­å­—ç¬¦ä¸²ï¼Œå¹¶ä¸”ä¸èƒ½é‡å¤ã€‚æ¯”å¦‚pwwkew å¯ä»¥åŒ¹é…åˆ°wke æœ€åä¸€ä¸ªwä¸å¯ä»¥è¢«åŒ¹é…åˆ°ï¼Œå› ä¸ºè¯¥å­å­—ç¬¦ä¸²å·²ç»åŒ…å«äº†ä¸€ä¸ªwã€‚ ç®—æ³•è§£æï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æš´åŠ›è§£æ³•ï¼šåŒå¾ªç¯ï¼ˆä½†æ˜¯ä¸æ¨è)ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨HashMapæ¥è§£å†³è¯¥é—®é¢˜ï¼Œå› ä¸ºHashMapæŸ¥è¯¢çš„æ—¶å€™åªéœ€è¦$O(1)$çš„æ—¶é—´å¤æ‚åº¦ã€‚ é¦–å…ˆå¯¹è¯¥å­—ç¬¦ä¸²è¿›è¡Œéå†ï¼Œå¦‚æœè¯¥å­—ç¬¦ä¸åœ¨HashMapé‡Œé¢ï¼Œåˆ™æŠŠè¯¥å­—ç¬¦æ·»åŠ åˆ°HashMapï¼Œå–maxï¼ˆHashMap length, ansï¼‰ å¦‚æœè¯¥å­—ç¬¦å·²ç»å‡ºç°åœ¨HashMapé‡Œé¢ï¼Œä»HashMapé‡Œé¢å»é™¤ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶åcurrent indexä¿æŒä¸å˜ï¼ˆä¼šå¯¹è¯¥indexè¿›è¡Œå†æ¬¡éå†ï¼‰ å¾ªç¯ æœ‰ç‚¹ç±»ä¼¼äºï¼šå½“ä¸€ä¸ªå­—ç¬¦ä¸åœ¨è¯¥HashMapï¼Œpushè¿›å»ï¼Œå¦‚æœå·²ç»åœ¨äº†ï¼Œpopå‡ºæ¥ã€‚ç„¶ååœ¨pushä¹‹åè®¡ç®—æœ€å¤§çš„é•¿åº¦æ˜¯å¤šå°‘ã€‚ï¼ˆè¿›å»ä¸€ä¸ªå¦‚æœå·²ç»å­˜åœ¨å°±popå‡ºæ¥ä¸€ä¸ªï¼Œå› ä¸ºé‡ç‚¹æ˜¯é•¿åº¦ï¼Œæ‰€ä»¥ä¸éœ€è¦å…³å¿ƒåˆ°åº•æ˜¯å“ªäº›å­—ç¬¦ï¼‰ã€‚ Pythonä¼ªä»£ç  def LongSubString(s): while i Javaè§£å†³æ–¹æ³•ï¼š import java.util.HashMap; import java.util.Map; public class LongestSubstring { public int lengthOfLongestSubstring(String s) { int ans = 0; int remove = 0; Map map = new HashMap<>(); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/4/":{"url":"codes/4/","title":"4. Median of Two Sorted Arrays","keywords":"","body":"Median of two sorted array There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 æ²¡åŠæ³•å¤ªèœäº†æ‰¾ä¸åˆ°åˆé€‚çš„æ–¹æ³•æ¥å†™äº†ï¼Œæœ‰æƒ³è¿‡åˆ†å¼€å¾ªç¯ï¼Œä½†æ˜¯è¿™æ ·éœ€è¦æœ‰å¾ˆå¤šçš„åˆ¤æ–­æ¡ä»¶ï¼Œæ™šä¼šä¼šå†å°è¯•çš„ï¼Œç›®å‰å°±å¿«çš„æ–¹æ³•å°±æ˜¯åˆå¹¶arrayäº†ã€‚ public double findMedianSortedArrays(int[] nums1, int[] nums2) { List list = new LinkedList<>(); int l1 = 0, l2 = 0; while (l1 = nums1.length) { for (int i = l2; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/6/":{"url":"codes/6/","title":"6. Zigzag Conversion","keywords":"","body":"6. Zigzag Conversion The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I Example 3: Input: s = \"A\", numRows = 1 Output: \"A\" Constraints: 1 s consists of English letters (lower-case and upper-case), ',' and '.'. 1 Solution ä»¥å‰åšä¸å‡ºæ¥çš„é¢˜ç°åœ¨å¥½åƒéƒ½å¾ˆå®¹æ˜“ï¼Ÿï¼Ÿï¼Ÿå…¶å®åªè¦æ‰¾åˆ°è§„å¾‹å°±è¡Œï¼Œç›´åˆ°æ–œç€çš„charçš„æ•°é‡æ˜¯numRows - 2å°±è¡Œï¼Œç„¶åæ”¶é›†åˆ°æ•°ç»„ï¼Œæœ€åè¿ç®—å°±è¡Œã€‚ä¸è¿‡ä¹Ÿå¯ä»¥ç›´æ¥è®¡ç®—å‡ºæ¥æœ€åçš„stringï¼Œä½†æ˜¯æ¯”è¾ƒéº»çƒ¦ï¼Œä¸æ˜¯å¾ˆæƒ³æŠ˜è…¾ã€‚ class Solution { public: string convert(string s, int numRows) { auto maps = vector>(numRows); string res = \"\"; int idx = 0; bool add_row = true; while (idx 0) { maps[cnt --].push_back(s[idx]); idx ++; } add_row = true; } } for (auto & map : maps) { for (char const& x : map) res += x; } return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/7/":{"url":"codes/7/","title":"7. Reverse Integer","keywords":"","body":"Reverse Integer reverse integer Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 æœ¬æ¥ä»¥ä¸ºè¿™ä¸ªé¢˜å¾ˆç®€å•ï¼Œä½¿ç”¨äº†æœ€ç®€å•çš„ç®—æ³•ï¼Œä½†æ˜¯å‘¢ï¼Œå‡ºç°äº†ä¸€ä¸ªæ•´å‹æº¢å‡ºçš„é—®é¢˜o(â•¥ï¹â•¥)oã€‚ å…ˆè§£æä¸€ä¸‹æ€è·¯å§ï¼š é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç”¨x%10æ¥å¾—åˆ°æœ€åä¸€ä¸ªæ•°å­—ï¼ˆå› ä¸ºæ•°å­—ä¸å¯èƒ½å¤§äº10ï¼‰ x/10æ˜¯æŠŠæœ€åä¸€ä½æ•°å»æ‰ reverse*10æ˜¯ä¸ºäº†æ•´ä½“å‘å·¦ç§»ä¸€ä½ï¼Œæ¯”å¦‚(44, 44*10 = 440)å¤šå‡ºä¸€ä¸ªç©ºä½ï¼Œç„¶ååŠ ä¸Šx%10çš„æ•°å­— public int reverse(int x) { int reverse = 0; while (x != 0) { int last_digit = x % 10; reverse = reverse * 10 + last_digit; x = x / 10; } return reverse ; } è¿™æ ·å¦‚æœæ•°å­—åŒºé—´åœ¨$[âˆ’2^{31}, 2^{31} âˆ’ 1]$çš„è¯é‚£ä¹ˆå°±ä¼šå‡ºç°æº¢å‡ºçš„é—®é¢˜äº†ï¼Œå¤§å®¶å¯ä»¥ä½¿ç”¨1534236469æ¥å°è¯•ä¸€ä¸‹ã€‚ æ‰€ä»¥è¿™æ—¶å€™æˆ‘ä»¬å°±éœ€è¦æ¥åšäº›åˆ¤æ–­äº†ï¼š å½“reverse > intMAX/10çš„æ—¶å€™æˆ‘ä»¬åŸºæœ¬ä¸Šå°±å¯ä»¥ç¡®å®šä»–ä¼šæº¢å‡ºäº†ï¼Œæ¯”å¦‚è¯´intMAX = 2147483647ï¼Œå‡è®¾æˆ‘ä»¬çš„reverse = 214748365 è¿™æ—¶å€™intMAX/10 =214748364ï¼Œreverse > intMAXã€‚è¿™æ—¶å€™å¦‚æœreverse * 10æˆ‘ä»¬ä¸ç®¡æœ€åä¸€ä¸ªæ•°å­—æ˜¯ä»€ä¹ˆäº†ï¼Œreverseå·²ç»è¶…å‡ºäº†intå–å€¼èŒƒå›´ã€‚ æ­£ç¡®ä»£ç ï¼š public int reverse(int x) { int reverse = 0; while (x != 0) { int last_digit = x % 10; if (reverse > Integer.MAX_VALUE / 10) return 0; if (reverse powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/8/":{"url":"codes/8/","title":"8. String to Integer (atoi)","keywords":"","body":"String to Integer (atoi) String to Integer (atoi) Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [âˆ’231, 231 âˆ’ 1]. If the numerical value is out of the range of representable values, INT_MAX (231 âˆ’ 1) or INT_MIN (âˆ’231) is returned. Example 1: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (âˆ’231) is returned. è¿™æ˜¯æˆ‘å†™LeetCodeä»¥æ¥submitæœ€å¤šçš„æ¬¡æ•°â•®(â•¯â–½â•°)â•­ï¼Œé‡Œé¢æ¡ä»¶çš„é™åˆ¶å’Œç¬¦å·çš„åˆ¤å®šå¤ªçƒ¦äº†ã€‚ç»™å¤§å®¶å†™ä¸€ä¸‹åˆ¤æ–­æ¡ä»¶ï¼š ç©ºæ ¼åªèƒ½å‡ºç°åœ¨æœ€å‰é¢ï¼Œä¸€æ—¦å‡ºç°äº†-+0-9è¿™äº›ç¬¦å·ï¼Œä¹‹åå†é‡åˆ°ç©ºæ ¼å°±è¦break -+ç¬¦å·è€ƒè™‘åˆ°ç¬¦å·çš„é—®é¢˜ åªèƒ½ä»¥æ•°å­—å¼€å¤´çš„æ‰èƒ½æå–æ•°å­—ï¼Œå¦‚æœä¸æ˜¯å°±return 0 è€ƒè™‘åˆ°æ•´å‹æº¢å‡ºçš„é—®é¢˜ å°±æ˜¯åˆ¤æ–­æ¡ä»¶æœ‰ç‚¹éº»çƒ¦ï¼Œå…¶ä»–çš„è¿˜å¥½ï¼Œæˆ‘å†™çš„æœ‰ç‚¹ä¹±ä¸ƒå…«ç³Ÿçš„ï¼Œè®²ç©¶çœ‹ä¸‹ã€‚ã€‚ã€‚å¦‚æœæœ‰å¥½çš„ideaå¯ä»¥å†™åœ¨commenté‡Œé¢ï¼Œæˆ‘ä¼šä¿®æ”¹çš„ã€‚ public int myAtoi(String str) { int res = 0; // + or - int operation = 1; if (str.equals(\"\"))return 0; boolean whitespace = true; boolean sign = true; for (int i = 0; i '9') break; whitespace = false; sign=false; if (res*operation > Integer.MAX_VALUE/10 || res*operation 0) return Integer.MAX_VALUE; else return Integer.MIN_VALUE; } if (res*operation == Integer.MAX_VALUE/10) if ((int)c-48 >= Integer.MAX_VALUE %10) return Integer.MAX_VALUE; if (res*operation == Integer.MIN_VALUE/10) if ((int)(c-48) * -1 powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/9/":{"url":"codes/9/","title":"9. Palindrome Number","keywords":"","body":"Palindrome Number palindrome number Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. å›æ–‡æ•°ä¹Ÿå°±æ˜¯è¯´è¯¥æ•°å­—ç­‰äºç¿»è½¬åçš„æ•°å­—ï¼Œnum = reverse(num)ã€‚é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç¡®å®šå¦‚æœè¯¥æ•°å­—æ˜¯è´Ÿæ•°ç›´æ¥falseå°±å¥½äº†ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸Šä¸€é¢˜çš„æ€è·¯ï¼ŒæŠŠæ•°å­—ç¿»è½¬ç„¶åçœ‹æ˜¯å¦ç›¸ç­‰ã€‚ä¹Ÿå¯ä»¥æŠŠè¾¹ç•Œæƒ…å†µè€ƒè™‘è¿›è¡Œã€‚ public boolean isPalindrome(int x) { if (x Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. é›†ä½“æ€è·¯ï¼š é‡‡ç”¨äº†å‚ç›´å¯¹æ¯”æ³•ã€‚æ¯”å¦‚ï¼š s1 = 'flower' s2 = 'flow' s3 = 'flight' æˆ‘ä»¬ç¬¬ä¸€å±‚å¾ªç¯æ˜¯è¡¨ç¤ºå½“å‰stringçš„index, i = 0; ç„¶åå¾—åˆ°ç¬¬ä¸€ä¸ªstringçš„ç¬¬iä¸ªchar ç¬¬äºŒä¸ªå¾ªç¯å¼ä¸ºäº†å’Œå‰©ä½™çš„stringæ¯”å¯¹ï¼Œ å¦‚æœiçš„å¤§å°ç­‰äºå½“å‰stringçš„é•¿åº¦ä¹Ÿå°±æ„å‘³ç€é‡åˆ°äº†ç»“æŸç‚¹ï¼Œæ¯”å¦‚å½“i=3çš„æ—¶å€™ï¼Œi = s2.lengthï¼Œä¹Ÿå°±æ„å‘³ç€æœ‰ç»“æŸç‚¹äº†ã€‚ c != strs[j].charAt(i) è¿™å°±è¯­å¥æ˜¯ä¸ºäº†åˆ¤æ–­å½“å‰stringçš„ç¬¬iä¸ªcharæ˜¯å¦å’Œç¬¬ä¸€ä¸ªç›¸ç­‰ï¼Œå¦‚æœä¸æƒ³å½“ä¹Ÿå°±æ„å‘³ç€å¯ä»¥è¿”å›iä¹‹å‰çš„æ•°æ® æœ€åä¸€è¡Œæ„å‘³ç€strs[0]æ˜¯æœ€çŸ­çš„å­—ç¬¦ä¸²ï¼Œè€Œä¸”strs[0]æ˜¯comm prefix public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; for (int i = 0; i ä¹Ÿå¯ä»¥è¯•ç€å¾—åˆ°æœ€çŸ­çš„stringï¼Œç„¶åè¿›è¡Œå¾ªç¯ï¼Œæ€è·¯å·®ä¸å¤šï¼š è¿™ç§æƒ…å†µå…¶å®æ²¡ä»€ä¹ˆå¿…è¦ï¼Œå› ä¸ºå¯èƒ½æ²¡å¾ªç¯ç»“æŸå°±returnäº†ã€‚ public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; int min = Integer.MAX_VALUE; int index = -1; // get the shortest string length for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/11/":{"url":"codes/11/","title":"11. Container With Most Water","keywords":"","body":"Container With Most Water Container With Most Water æœ¬æ¥è§‰å¾—æ˜¯è¦ç”¨åŠ¨æ€è§„åˆ’ï¼Œå¯æ˜¯çœ‹äº†å¤§ä½¬çš„ä»£ç å’Œideaç¬é—´è§‰å¾—è‡ªå·±çš„æ€è·¯æ˜¯é”™çš„ã€‚è¿™ä¸ªé¢˜å…¶å®å°±æ˜¯å˜ç›¸çš„æ±‚æœ€å¤§é¢ç§¯ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“é•¿æ–¹ä½“çš„é¢ç§¯æ˜¯é•¿*é«˜ï¼Œåœ¨éå†è¿™ä¸ªlistçš„æ—¶å€™é•¿åº¦æ˜¯ä¸€ç›´åœ¨å‡å°çš„ï¼Œå¦‚æœé•¿åº¦å˜å°æˆ‘ä»¬åªæœ‰æ‰¾åˆ°æ›´å¤§çš„é«˜åº¦æ‰èƒ½ä½¿é¢ç§¯æœ€å¤§ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä»ä¸¤å¤´åŒæ—¶å¼€å§‹éå†ï¼Œå¦‚æœleft é‚£ä¹ˆleftå‘å·¦ç§»ï¼Œå› ä¸ºæˆ‘ä»¬è¦æ‰¾åˆ°higher heightï¼Œå¦‚æœleft >= right rightå‘å·¦ç§»å°±è¡Œäº†ã€‚è¿™æ ·å°±ä¼šæ‰¾åˆ°æœ€å¤§çš„areaã€‚ psï¼šä¸æƒ³æƒ³å¤ªå¤æ‚ï¼Œè¯•ç€ä»æœ€åŸºæœ¬çš„ä¿¡æ¯å»æ¨æ–­ï¼Œæ¯”å¦‚è¿™ä¸ªé¢ç§¯ï¼Œå¦‚æœä¸€ä¸ªå˜é‡å˜ä¸‹ï¼Œé‚£å¦ä¸€ä¸ªå˜é‡åªæœ‰å˜å¤§æ‰èƒ½æ‰¾åˆ°æœ€å¤§çš„ã€‚ï¼ˆğŸ˜å­¦ä¹ åˆ°äº†ï¼‰ public int maxArea(int[] height) { int max = 0; int l = 0, r = height.length-1; while (l powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/13/":{"url":"codes/13/","title":"13. Roman to Integer","keywords":"","body":"Roman to Integer Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: \"III\" Output: 3 Example 2: Input: \"IV\" Output: 4 Example 3: Input: \"IX\" Output: 9 Example 4: Input: \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. å¥½åƒæ²¡ä»€ä¹ˆå¥½è¯´çš„å°±æ˜¯ç®€å•çš„å­—ç¬¦ä¸²æ“ä½œè€Œå·²ï¼š public int romanToInt(String s) { Map map = new HashMap<>(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int res = 0; for (int i = 0; i 0) { if (s.charAt(i-1) == 'I') res += map.get(c) - 2; else res += map.get(c); } else res += map.get(c); } else if (c == 'L' || c == 'C') { if (i > 0) { if (s.charAt(i-1) == 'X') res += map.get(c) - 20; else res += map.get(c); } else res += map.get(c); } else if (c == 'D' || c == 'M') { if (i > 0) { if (s.charAt(i-1) == 'C') res += map.get(c) - 200; else res += map.get(c); } else res += map.get(c); } else { res += map.get(c); } } return res; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/14/":{"url":"codes/14/","title":"14. Longest Common Prefix","keywords":"","body":"Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. é›†ä½“æ€è·¯ï¼š é‡‡ç”¨äº†å‚ç›´å¯¹æ¯”æ³•ã€‚æ¯”å¦‚ï¼š s1 = 'flower' s2 = 'flow' s3 = 'flight' æˆ‘ä»¬ç¬¬ä¸€å±‚å¾ªç¯æ˜¯è¡¨ç¤ºå½“å‰stringçš„index, i = 0; ç„¶åå¾—åˆ°ç¬¬ä¸€ä¸ªstringçš„ç¬¬iä¸ªchar ç¬¬äºŒä¸ªå¾ªç¯å¼ä¸ºäº†å’Œå‰©ä½™çš„stringæ¯”å¯¹ï¼Œ å¦‚æœiçš„å¤§å°ç­‰äºå½“å‰stringçš„é•¿åº¦ä¹Ÿå°±æ„å‘³ç€é‡åˆ°äº†ç»“æŸç‚¹ï¼Œæ¯”å¦‚å½“i=3çš„æ—¶å€™ï¼Œi = s2.lengthï¼Œä¹Ÿå°±æ„å‘³ç€æœ‰ç»“æŸç‚¹äº†ã€‚ c != strs[j].charAt(i) è¿™å°±è¯­å¥æ˜¯ä¸ºäº†åˆ¤æ–­å½“å‰stringçš„ç¬¬iä¸ªcharæ˜¯å¦å’Œç¬¬ä¸€ä¸ªç›¸ç­‰ï¼Œå¦‚æœä¸æƒ³å½“ä¹Ÿå°±æ„å‘³ç€å¯ä»¥è¿”å›iä¹‹å‰çš„æ•°æ® æœ€åä¸€è¡Œæ„å‘³ç€strs[0]æ˜¯æœ€çŸ­çš„å­—ç¬¦ä¸²ï¼Œè€Œä¸”strs[0]æ˜¯comm prefix public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; for (int i = 0; i ä¹Ÿå¯ä»¥è¯•ç€å¾—åˆ°æœ€çŸ­çš„stringï¼Œç„¶åè¿›è¡Œå¾ªç¯ï¼Œæ€è·¯å·®ä¸å¤šï¼š è¿™ç§æƒ…å†µå…¶å®æ²¡ä»€ä¹ˆå¿…è¦ï¼Œå› ä¸ºå¯èƒ½æ²¡å¾ªç¯ç»“æŸå°±returnäº†ã€‚ public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return \"\"; int min = Integer.MAX_VALUE; int index = -1; // get the shortest string length for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/17/":{"url":"codes/17/","title":"17. Letter Combinations of a Phone Number","keywords":"","body":"Letter Combinations of a Phone Number Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. æ€è·¯1ï¼š æ¯ä¸ªæ•°å­—ä»£è¡¨å‡ ä¸ªç›¸å¯¹åº”çš„æ•°æ®ï¼ŒæŠŠè¿™äº›ä»£è¡¨çš„æ•°æ®è¿›è¡Œæ’åˆ—ç»„åˆã€‚è¿™ä¸ªç¬¬ä¸€ä¸ªæƒ³åˆ°çš„å°±æ˜¯loopï¼Œé€å±‚é€’è¿›ï¼Œå› ä¸ºå¦‚æœæ˜¯ä¸‰ä¸ªæ•°å­—çš„è¯ï¼Œå°±æ˜¯åªç»„åˆæˆä¸‰ä¸ªå­—æ¯çš„stringï¼Œå¯ä»¥å…ˆæŠŠ1ï¼Œ2ç»„åˆå¾—åˆ°çš„ç»“æœå»å’Œ3ç»„åˆã€‚è¿™æ ·å°±è¡Œäº†ï¼Œè¿˜æœ‰åˆ«çš„ç®—æ³•ã€‚ import java.util.*; public class LetterCombinationsofaPhoneNumber { private List letterCombinations(String digits) { List result = new LinkedList<>(); HashMap maps = new HashMap<>(); maps.put('2', \"abc\"); maps.put('3', \"def\"); maps.put('4', \"ghi\"); maps.put('5', \"jkl\"); maps.put('6', \"mno\"); maps.put('7', \"pqrs\"); maps.put('8', \"tuv\"); maps.put('9', \"wyxz\"); // å…ˆå®éªŒä¸€ä¸‹ç›¸ä¹˜çš„åŠæ³•ï¼Œå› ä¸ºè¿˜æœ‰å¾ˆå¤šå¥½çš„åŠæ³•ï¼Œä¸€ä¼šæ…¢æ…¢çœ‹ for (int i = 0; i (Arrays.asList(str.split(\"\")))); } return result; } private List mul(List s1, List s2) { if (s1.size() == 0 && s2.size() != 0) { return s2; } if (s1.size() != 0 && s2.size() == 0) { return s1; } List result = new LinkedList<>(); for (String value : s1) { for (String s : s2) { result.add(value + s); } } return result; } public static void main(String[] args) { LetterCombinationsofaPhoneNumber l = new LetterCombinationsofaPhoneNumber(); String str = \"23\"; List res = l.letterCombinations(str); for (String s : res) { System.out.println(s); } } } æ€è·¯2ï¼š æƒ³å­¦ä¹ ä¸€ä¸‹dfsçš„ç®—æ³•ã€‚ã€‚ã€‚å­¦ä¹ ä½¿ç”¨dfså’Œé€’å½’çš„æ–¹æ³•ï¼Œè¿™ä¸ªç®—æ³•çš„æ€è·¯å°±æ˜¯ç›´æ¥è®¿é—®åˆ°æœ€åº•å±‚çš„strï¼Œç„¶åéå†æœ€åº•å±‚çš„listï¼Œéå†å®Œä¹‹åè¿”å›åˆ°ä¸Šä¸€å±‚ï¼Œç„¶åå¯¹ä¸Šä¸€å±‚è¿›è¡Œéå†ï¼ŒåŒæ—¶è¿˜ä¼šä½¿ç”¨åˆ°æœ€åº•å±‚çš„å…ƒç´ ã€‚ã€‚ã€‚é€’å½’æœ‰ç‚¹ç»•ã€‚ã€‚ private List letterCombinations(String digits) { List result = new LinkedList<>(); if (digits == null || digits.length() == 0) return result; HashMap maps = new HashMap<>(); maps.put('2', \"abc\"); maps.put('3', \"def\"); maps.put('4', \"ghi\"); maps.put('5', \"jkl\"); maps.put('6', \"mno\"); maps.put('7', \"pqrs\"); maps.put('8', \"tuv\"); maps.put('9', \"wyxz\"); dfs(digits, 0, \"\", result, maps); return result; } public void dfs(String digits, int index, String temp, List res, HashMap maps) { if (index == digits.length()) { res.add(temp); return; } String t = maps.get(digits.charAt(index)); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/18/":{"url":"codes/18/","title":"18. 4Sum","keywords":"","body":"18. 4Sum Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Example 1: Input: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2: Input: nums = [2,2,2,2,2], target = 8 Output: [[2,2,2,2]] Constraints: 1 -109 -109 Solution æœ‰å¾ˆå¤šç§ç®—æ³•å¯ä»¥è°ƒç”¨ï¼Œä½†æ˜¯æ‡’ï¼Œé€‰æ‹©äº†æš´åŠ›é€’å½’ class Solution { void combine(vector>& res, vector& path, vector& candidates, int idx, int target) { long long val = 0; for (int const& v : path) val += v; if (val == target && path.size() == 4) res.push_back(path); if (path.size() >= 4) return; for (int i = idx; i idx && candidates[i] == candidates[i - 1]) continue; path.push_back(candidates[i]); combine(res, path, candidates, i + 1, target); path.pop_back(); } } public: vector> fourSum(vector& nums, int target) { sort(nums.begin(), nums.end()); auto res = vector>(); auto path = vector(); if (nums.size() powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/19/":{"url":"codes/19/","title":"19. Remove Nth Node From End of List","keywords":"","body":"Remove Nth Node From End of List Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note: Given n will always be valid. Follow up: Could you do this in one pass? è§£æï¼š é¢˜æ„å°±æ˜¯åˆ é™¤å€’æ•°ç¬¬Nçš„èŠ‚ç‚¹ã€‚è¿™ä¸ªå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•æ¥è§£å†³ï¼Œå…ˆè®©å¿«çš„æŒ‡é’ˆç§»åŠ¨nä¸ªnodeï¼Œç„¶åæ…¢çš„æŒ‡é’ˆå¼€å§‹ç§»åŠ¨ã€‚è¿™æ ·å½“å¿«çš„æŒ‡é’ˆä¸ºnullçš„æ—¶å€™ï¼Œæ…¢çš„æŒ‡é’ˆåˆšå¥½å°±æ˜¯è¦åˆ é™¤çš„èŠ‚ç‚¹ã€‚ å…¶å®å¯ä»¥å½“fast.next == nullçš„æ—¶å€™å°±åœæ­¢ã€‚è¿™æ ·slow.next = slow.next.nextæ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºæˆ‘çš„ä»£ç ç”¨äº†curræ¥åˆ¤æ–­æ˜¯å¦ä¸ºnullï¼ˆåˆ é™¤çš„å…ƒç´ æ˜¯ä¸æ˜¯headï¼‰ public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode removeNthFromEnd(ListNode head, int n) { ListNode curr = null; ListNode slow = head; ListNode fast = head; while (fast != null) { if (n powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/20/":{"url":"codes/20/","title":"20. Valid Parentheses","keywords":"","body":"Valid Parentheses valid parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: \"()\" Output: true Example 2: Input: \"()[]{}\" Output: true Example 3: Input: \"(]\" Output: false Example 4: Input: \"([)]\" Output: false Example 5: Input: \"{[]}\" Output: true è§£é¢˜æ€è·¯ï¼š è¿™ä¸ªé¢˜æˆ‘ä½¿ç”¨äº†stackï¼ˆæ ˆï¼‰çš„æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚stackæ˜¯ä¸€ç§å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„ï¼Œæ‰€ä»¥æ›´åŠ é€‚åˆè¿™ç§é—®é¢˜ã€‚ æˆ‘ä»¬å…ˆæ¥åˆå§‹åŒ–ä¸€ä¸ªHashMapæ¥å­˜ç›¸å¯¹åº”çš„æ‹¬å· å…ˆåˆ¤æ–­è¯¥HashMapæ˜¯å¦å­˜åœ¨è¯¥å·¦æ‹¬å·ï¼Œå¦‚æœå­˜åœ¨å°±æŠŠå·¦æ‹¬å·pushåˆ°stacké‡Œé¢ï¼Œ å¦‚æœä¸å­˜åœ¨å…ˆåˆ¤æ–­stackæ˜¯å¦æœ‰æ•°æ®ï¼ˆå› ä¸ºä¸å­˜åœ¨çš„æƒ…å†µåªæœ‰è¯¥å­—ç¬¦æ˜¯å³æ‹¬å·çš„æƒ…å†µï¼‰ ç„¶åæ ¹æ®stack popå‡ºæ¥çš„ç»“æœåœ¨HashMapæ‰¾åˆ°ç›¸å¯¹åº”çš„å³æ‹¬å·ï¼Œç„¶ååˆ¤æ–­è¯¥å­—ç¬¦å’ŒHashMapé‡Œé¢çš„å³æ‹¬å·æ˜¯å¦åŒ¹é…ã€‚ public boolean isValid(String s) { Stack stack = new Stack(); Map map = new HashMap<>(); map.put('[', ']'); map.put('(', ')'); map.put('{', '}'); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/21/":{"url":"codes/21/","title":"21. Merge Two Sorted Lists","keywords":"","body":"Merge Two Sorted Lists Merge two sorted lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 è¿™ä¸ªå¥½åƒæ²¡ä»€ä¹ˆè¯´çš„ï¼Œå°±ç›´æ¥å¯¹æ¯”å¤§å°ç„¶åmergeåœ¨ä¸€èµ·å°±è¡Œ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode head = new ListNode(); ListNode temp = head; while (l1 != null && l2 != null) { temp.next = new ListNode(); temp = temp.next; if (l1.val powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/22/":{"url":"codes/22/","title":"22. Generate Parentheses","keywords":"","body":"Generate Parentheses Generate Parentheses Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] è¿™ä¸ªé¢˜ä¸»è¦æ˜¯ä½¿ç”¨äº†é€’å½’çš„æ–¹æ³•ï¼Œé¦–å…ˆä¸€ç›´æ·»åŠ (ï¼Œç›´åˆ°æœ€æ·±åº¦nï¼Œå¦‚æœè¶…è¿‡nè‚¯å®šä¸åˆæ³•äº†ï¼Œå› ä¸ºå·¦å³æ‹¬å·æ˜¯ç›¸å¯¹åº”çš„ã€‚å½“å·¦æ‹¬å·è¾¾åˆ°æœ€æ·±åº¦çš„æ—¶å€™ï¼Œå¼€å§‹é€’å½’å³æ‹¬å·ï¼ŒåŒæ—¶å³æ‹¬å·çš„æ•°é‡åº”è¯¥å°äºå·¦æ‹¬å·ã€‚ä¼ªä»£ç : def find(left, right, depth, str, res): if str length == depth * 2: res.add(str) if left Javaä»£ç ï¼š import java.util.LinkedList; import java.util.List; public class GenerateParentheses { public List generateParenthesis(int n) { List list = new LinkedList<>(); if (n == 0) return list; dfs(0,0,n,list, \"\"); return list; } public void dfs(int close, int open, int depth, List res, String str) { if (str.length() == depth * 2) { res.add(str); return; } if (open res = ge.generateParenthesis(4); for (String str : res) { System.out.println(str); } } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/23/":{"url":"codes/23/","title":"23. Merge k Sorted Lists","keywords":"","body":"23. Merge k Sorted Lists (Hard) You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Example 1: Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1->4->5, 1->3->4, 2->6 ] merging them into one sorted list: 1->1->2->3->4->4->5->6 Example 2: Input: lists = [] Output: [] Example 3: Input: lists = [[]] Output: [] Constraints: k == lists.length 0 0 -104 lists[i] is sorted in ascending order. The sum of lists[i].length will not exceed 104. Solution 21å¹´çš„æ—¶å€™å°è¯•è¿‡åšè¿™ä¸ªé¢˜ï¼Œå¥½åƒæ²¡åšå‡ºæ¥ã€‚ä½†ç°åœ¨çœ‹ä¸€ä¸‹å¥½åƒå°±æ˜¯priority queueå°±èƒ½è§£å†³ï¼Œå¥½åƒä¸éš¾ã€‚ class Solution { public: ListNode* mergeKLists(vector& lists) { auto pq = priority_queue, decltype([] (ListNode* a, ListNode *b) -> bool {return a->val > b->val;})>(); ListNode* head = nullptr; ListNode* curr = nullptr; for (auto& node : lists) { while (node != NULL) { pq.push(node); node = node -> next; } } while (!pq.empty()) { auto top = pq.top(); pq.pop(); if (head == nullptr) { head = top; curr = top; } else { curr->next = top; curr = top; } } if (curr != NULL) curr->next = NULL; return head; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/24/":{"url":"codes/24/","title":"24. Swap Nodes in Pairs","keywords":"","body":"Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list's nodes, only nodes itself may be changed. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. äº¤æ¢nodeçš„ä½ç½®ï¼Œä¸¤ä¸¤äº¤æ¢ï¼Œè¦è€ƒè™‘çš„é—®é¢˜æœ‰ä¸¤ä¸ªï¼Œlisté•¿åº¦ä¸ºoddçš„æ—¶å€™æ€ä¹ˆåŠï¼Œæ€ä¹ˆå»è¿›è¡Œloopã€‚ public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode curr = head; head = curr.next; ListNode last = null; while (curr != null && curr.next != null) { ListNode next = curr.next; ListNode temp = next.next; if (last != null) { last.next = curr.next; } next.next = curr; curr.next = null; last = curr; curr = temp; } if (curr != null && curr.next == null) last.next = curr; return head; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/25/":{"url":"codes/25/","title":"25. Reverse Nodes in k-Group","keywords":"","body":"25. Reverse Nodes in k-Group (hard) Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. Example 1: Input: head = [1,2,3,4,5], k = 2 Output: [2,1,4,3,5] Example 2: Input: head = [1,2,3,4,5], k = 3 Output: [3,2,1,4,5] Constraints: The number of nodes in the list is n. 1 0 Follow-up: Can you solve the problem in O(1) extra memory space? Solution æœ‰å¥½å‡ ç§ä¸åŒçš„åšæ³•ï¼Œå¯ä»¥ä½¿ç”¨vectoræ¥è®°å½•ä½ç½®ï¼Œç„¶ååœ¨vectoré‡Œé¢è¿›è¡Œäº¤æ¢ã€‚ä½†æ˜¯è¿™ç§æ–¹æ³•ç©ºé—´å¤æ‚åº¦O(n)ï¼Œå¦ä¸€ç§æ–¹æ³•å°±æ˜¯ä½¿ç”¨é€’å½’ï¼Œå½“éå†åˆ°ç¬¬kä¸ªçš„æ—¶å€™å¼€å§‹è°ƒç”¨å›æº¯ç®—æ³•è¿›è¡Œreverseã€‚ S1 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == NULL || k (); auto rec = vector(); rec.push_back(0); ListNode* curr = head; while (curr != NULL) { vec.push_back(curr); if (vec.size() % k == 0) rec.push_back(vec.size()); curr = curr->next; } // reverse the linked list by ranges for (int i = 1; i next = NULL; else vec[i]->next = vec[i + 1]; } return vec[0]; } }; S2 class Solution { public: ListNode* reverse(ListNode* head) { if (head == NULL || head->next == NULL) return head; auto last = reverse(head->next); head->next->next = head; head->next = NULL; return last; } ListNode* reverseKGroup(ListNode* head, int k) { int cnt = 0; ListNode* curr = head; ListNode* prev = NULL; ListNode* thead = NULL; // curr = head; head = NULL; while (curr != NULL) { if (thead == NULL) thead = curr; cnt ++; if (cnt % k == 0) { auto tmp = curr->next; curr->next = NULL; auto n = reverse(thead); if (head == NULL) head = n; if (prev == NULL) prev = thead; else { prev -> next = n; prev = thead; } thead->next = tmp; thead = NULL; curr = tmp; continue; } curr = curr->next; } return head; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/26/":{"url":"codes/26/","title":"26. Remove Duplicates from Sorted Array","keywords":"","body":"Remove Duplicates from Sorted Array Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length. æœ€è·å–é•¿åº¦çš„åŒæ—¶éœ€è¦å¯¹arrayå†…éƒ¨æ•°æ®è¿›è¡Œä¿®æ”¹ï¼š é€šè¿‡æ¯æ¬¡è®°å½•numï¼Œå¦‚æœä¸ç›¸åŒçš„è¯ï¼Œå¯¹æ•°ç»„çš„å…¶å®ä½ç½®å¼€å§‹ä¿®æ”¹ï¼Œç„¶åcurræ˜¯æ­£åœ¨ä¿®æ”¹çš„indexã€‚ï¼ˆä¹Ÿä¼šéšç€iå¢åŠ è€Œå¢åŠ ï¼Œå¦‚æœæ‰€æœ‰æ•°å­—éƒ½ä¸ä¸€æ ·ï¼‰åªä¸è¿‡æ˜¯é‡æ–°èµ‹å€¼äº†ä¸€æ¬¡è€Œå·²ã€‚ public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; int dup = nums[0]; int curr = 1; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/27/":{"url":"codes/27/","title":"27. Remove Element","keywords":"","body":"Remove Element Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. è¿™ä¸ªå’Œå‰é¢é‚£ä¸ªremove duplicate numberæ˜¯ä¸€ä¸ªæ€è·¯ï¼š è¿™ä¸ªç®—æ³•å¾ˆç®€å•ï¼Œä½†æ˜¯æ•ˆç‡è´¼é«˜ã€‚å…¶å®å¾ˆå¥½ç†è§£ï¼Œå°±æ˜¯å½“è¿™ä¸ªæ•°å­—ä¸ç­‰äºvalçš„æ—¶å€™ï¼Œä¼šç”¨ä¹‹å‰çš„currï¼ˆéé‡å¤çš„æ•°å­—åæ ‡ï¼‰æ¥æ›¿æ¢å½“å‰çš„valã€‚ 3, 2, 2, 3 & val = 2 curr = 0 when i = 0, val != nums[i] num[curr++] = nums[i] -> nums[0] = nums[0] and curr = 1 now when i = 1, val == nums[i] continue when i = 2, val == nums[i] continue when i = 3, val != nums[i] num[curr++] = nums[i] -> nums[1] = nums[3] and curr = 2 now so nums = 3, 3, 2, 3 and curr = 2, we do not care index > 1 values, so we done public int removeElement(int[] nums, int val) { int curr = 0; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/28/":{"url":"codes/28/","title":"28. Implement strStr()","keywords":"","body":"Implement strStr() Implement strStr() Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 è¿”å›è¦æ±‚çš„æ˜¯indexï¼Œæˆ‘è¿˜ä»¥ä¸ºæ˜¯é•¿åº¦ä¸€åº¦è¿·èŒ«ä¸ºå•¥ä¸å¯¹o(â•¥ï¹â•¥)oï¼Œä¸€ä¸ªforå°±èƒ½è§£å†³çš„é—®é¢˜ï¼Œæˆ‘ä»¬å…ˆå»needleçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶ååœ¨å¾ªç¯haystackçš„æ—¶å€™å¦‚æœé‡Œé¢æœ‰å­—ç¬¦å’Œneedleçš„ç¬¬ä¸€ä¸ªå­—ç¬¦åŒ¹é…äº†å°±ç”¨substringæ¥æ¥å–ç›¸å¯¹åº”çš„é•¿åº¦ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦å’Œneedleç›¸ç­‰ï¼ˆéœ€è¦åˆ¤æ–­indexçš„é•¿åº¦æ˜¯ä¸æ˜¯è¶…è¿‡äº†haystackçš„é•¿åº¦ï¼‰ã€‚ public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; char c = needle.charAt(0); for (int i = 0; i haystack.length()) return -1; if (haystack.substring(i, i+needle.length()).equals(needle)) return i; } } return -1; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/33/":{"url":"codes/33/","title":"33. Search in Rotated Sorted Array","keywords":"","body":"Search in Rotated Sorted Array Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 æ€è·¯ï¼Œå…ˆæŠŠåˆ†å‰²ç‚¹æ‰¾åˆ°ï¼Œå°±æ˜¯ä»å“ªä¸ªåœ°æ–¹æ¥åšçš„rotatedï¼Œæ¯”å¦‚[4,5,6,7,0,1,2]é‚£ä¹ˆåˆ†å‰²ç‚¹å°±æ˜¯index = 3çš„æ—¶å€™ï¼Œå› ä¸ºæ˜¯ä¸€ä¸ªé€’å¢çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥æƒ³æ‰¾åˆ°åˆ†å‰²ç‚¹å°±å¾ˆç®€å•ã€‚å†æ ¹æ®åˆ†å‰²ç‚¹åšä¸€ä¸ªbinary searchï¼Œå…ˆåˆ†æå‰åŠæ®µï¼Œå¦‚æœèƒ½æ‰¾åˆ°ç»“æœå°±returnï¼Œå¦‚æœæ‰¾ä¸åˆ°å°±æ‰¾ååŠæ®µçš„å†…å®¹ã€‚ public class SearchRotatedArray { public int search(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length - 1; int num = nums[0]; int mid = -1; for (int i = 1; i target) { right = temp_mid - 1; } else { left = temp_mid + 1; } } return -1; } public static void main(String[] args) { int[] nums = new int[] {4,5,6,7,0,1,2}; SearchRotatedArray s = new SearchRotatedArray(); int x = s.search(nums, 0); System.out.println(x); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/34/":{"url":"codes/34/","title":"34. Find First and Last Position of Element in Sorted Array","keywords":"","body":"Find First and Last Position of Element in Sorted Array Find First and Last Position of Element in Sorted Array Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] ä½¿ç”¨äº†ä¸€ä¸ª~äºŒåˆ†æŸ¥æ‰¾æ³•~ï¼Œå¤´å°¾éå†æ³•ï¼Œä¸è¿‡è²Œä¼¼æ—¶é—´å¤æ‚åº¦æœ‰ç‚¹é«˜ã€‚ã€‚æ²¡æœ‰åˆ«äººé‚£ä¹ˆå¿«ï¼ŒèŠ±äº†1msæ‰é€šè¿‡ã€‚ä¸€ä¼šå‡†å¤‡å»çœ‹çœ‹å¤§ç¥çš„æ€è·¯ï¼Œçœ‹çœ‹æœ‰æ²¡æœ‰å¥½çš„ideaã€‚ç¬¬23-28è¡Œçš„ä¸»è¦ä½œç”¨æ˜¯è€ƒè™‘åˆ°èµ·å§‹ä½ç½®å’Œç»“æŸä½ç½®åœ¨åŒä¸€ä¸ªåœ°æ–¹ï¼Œå½“å…¶ä¸­æœ‰ä»»ä½•ä¸€ä¸ªæ•°å­—ä¸æ˜¯-1çš„æ—¶å€™ï¼Œä»£è¡¨å·²ç»æ‰¾åˆ°è¿™ä¸ªæ•°å­—äº†ï¼Œä½†æ˜¯head==tailçš„æ—¶å€™å°±ä¼šç»“æŸå¾ªç¯äº†ï¼Œæ‰€ä»¥ä¼šè¿›è¡Œä¸€ä¸ªåˆ¤æ–­ã€‚ public int[] searchRange(int[] nums, int target) { if (nums.length == 0) return new int[] {-1, -1}; if (nums.length == 1)return (nums[0] == target) ? new int[] {0, 0}: new int[]{-1, -1}; int head = 0, tail = nums.length - 1; int[] range = new int[] {-1, -1}; while (head target) tail --; } if (head == tail) { if (range[0] == -1 || range[1] == -1) { range[0] = Math.max(range[0], range[1]); range[1] = Math.max(range[0], range[1]); } } return range; } åˆšå»çœ‹äº†ä¸€ä¸‹discussioné‡Œé¢ï¼Œç„¶åå‘ç°è‡ªå·±å†™çš„äºŒåˆ†æŸ¥æ‰¾ä¸å«äºŒåˆ†æŸ¥æ‰¾ï¼Œåªèƒ½ç®—æ˜¯ä¸€ä¸ªä¸¤å¤´éå†çš„å¾ªç¯ã€‚ç„¶åæ ¹æ®äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•å†™äº†ä¸€ä»½ï¼š public int[] searchRange(int[] nums, int target) { if (nums.length == 0) return new int[] {-1, -1}; int head = 0, tail = nums.length - 1; int[] range = new int[] {-1, -1}; while (head target) { tail = mid - 1; } else if (nums[mid] = mid) { if (nums[tail] == target) { range[1] = tail; break; } tail --; } break; } } return range; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/35/":{"url":"codes/35/","title":"35. Search Insert Position","keywords":"","body":"Search insert position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 å°±æ˜¯æ‰¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œç„¶åè¿”å›ç›¸å¯¹åº”çš„indexï¼Œæ²¡ä»€ä¹ˆéš¾åº¦ï¼š public int searchInsert(int[] nums, int target) { for (int i = 0; i = target) return i; } return nums.length; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/39/":{"url":"codes/39/","title":"39. Combination Sum","keywords":"","body":"39. Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] è¿™ä¸ªå¯ä»¥ä½¿ç”¨åˆ°å›æº¯ç®—æ³•çš„æ€æƒ³ï¼Œä»i - nums.lengthï¼Œæ¯ä¸ªéƒ½ä¼šé‡å¤ï¼Œæ¯”å¦‚å½“i=0çš„æ—¶å€™ï¼š 2,2,2,2 2,2,2,3 2,2,2,6 2,2,2,7 2,2,3 2,2,6 2,2,7 2,2 2,3 .... è¿™æ ·çš„ä¸€ä¸ªè§„å¾‹ã€‚ import java.util.*; public class CombinationSum { public List> combinationSum(int[] candidates, int target) { List> res = new LinkedList<>(); back_tracking(res, new ArrayList<>(), target, candidates, 0); return res; } // å›æº¯ç®—æ³• public void back_tracking(List> res, List temp, int target, int[] nums, int index) { if (target (temp)); else { for (int i = index; i > res = cs.combinationSum(nums, 7); for (List l : res) { System.out.println(Arrays.toString(l.toArray())); } } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/40/":{"url":"codes/40/","title":"40. Combination Sum II","keywords":"","body":"40. Combination Sum II Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5 Output: [ [1,2,2], [5] ] Constraints: 1 1 1 Solution ä»Šå¤©çŠ¶æ€å¾ˆä¸é”™ï¼Œç–¯ç‹‚åˆ·é¢˜ã€‚ã€‚ã€‚è¿™ä¸ªé¢˜å°±æ˜¯å›æº¯ç®—æ³•ï¼Œæ·»åŠ ä¸€ä¸ªå‰ªæå°±è¡Œï¼Œcand[i] != cand[i - 1] class Solution { public: void combine(vector>& res, vector& path, vector& candidates, int idx, int target) { int val = accumulate(path.begin(), path.end(), 0); if (val == target) res.push_back(path); if (val >= target) return; for (int i = idx; i target) continue; if (i > idx && candidates[i] == candidates[i - 1]) continue; path.push_back(candidates[i]); combine(res, path, candidates, i + 1, target); path.pop_back(); } } vector> combinationSum2(vector& candidates, int target) { auto res = vector>(); auto path = vector(); sort(candidates.begin(), candidates.end()); combine(res, path, candidates, 0, target); return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/41/":{"url":"codes/41/","title":"41. First Missing Positive","keywords":"","body":"41. First Missing Positive Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums. You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space. Example 1: Input: nums = [1,2,0] Output: 3 Explanation: The numbers in the range [1,2] are all in the array. Example 2: Input: nums = [3,4,-1,1] Output: 2 Explanation: 1 is in the array but 2 is missing. Example 3: Input: nums = [7,8,9,11,12] Output: 1 Explanation: The smallest positive integer 1 is missing. Constraints: 1 -231 Solution æ ¸å¿ƒæ€æƒ³ï¼š ä½¿ç”¨è¾“å…¥æ•°ç»„æœ¬èº«ä½œä¸ºå“ˆå¸Œè¡¨ï¼Œé‡æ–°æ’åˆ—æ•°ç»„ï¼Œä½¿å¾—æ•°å­—xå°½å¯èƒ½æ”¾åˆ°ç´¢å¼•x-1çš„ä½ç½® ï¼ˆå› ä¸ºæœ€å°æ­£æ•´æ•°æ˜¯1ï¼‰ã€‚ æœ€åä¸€æ¬¡éå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä½ç½® i æ»¡è¶³ nums[i]â‰ i+1ï¼Œåˆ™ i+1 å³ä¸ºç¬¬ä¸€ä¸ªç¼ºå¤±çš„æ­£æ•´æ•°ã€‚ ç®—æ³•æ­¥éª¤ï¼š éå†æ•°ç»„ï¼Œå¯¹äºæ¯ä¸ªå…ƒç´ nums[i] å¦‚æœnums[i]åœ¨1åˆ°nèŒƒå›´å†…ï¼Œå¹¶ä¸”nums[nums[i]âˆ’1]â‰ nums[i]ï¼Œå°†nums[i]æ”¾åˆ°æ­£ç¡®çš„ä½ç½®ï¼ˆå³äº¤æ¢åˆ°ç´¢å¼•nums[i]âˆ’1ï¼‰ã€‚ éå†æ’åºåçš„æ•°ç»„ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªnums[i]â‰ i+1çš„ä½ç½®ï¼Œè¿”å›i+1ã€‚ å¦‚æœæ•°ç»„æ‰€æœ‰ä½ç½®éƒ½æ»¡è¶³nums[i]=i+1ï¼Œè¿”å›n+1ã€‚ class Solution { public: int firstMissingPositive(vector& nums) { for (int i = 0; i = 1 && nums[i] - 1 powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/46/":{"url":"codes/46/","title":"46. Permutations","keywords":"","body":"46. Permutations Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] ä¹Ÿæ˜¯ä¸€ä¸ªå›æº¯ç®—æ³•ï¼Œéœ€è¦åŠ ä¸€ä¸ªé¢å¤–çš„æ¡ä»¶ï¼Œä¸èƒ½é‡å¤ï¼Œä¸è¿‡ä¹Ÿæ˜¯å›æº¯ç®—æ³•çš„ä¸€ä¸ªå¥—è·¯ã€‚ä¼ªä»£ç ï¼š result = [] def backtrack(path, select_list): if condition: result.add(path) return for list in select_list: make a select backtrack(path, select_list) drawback select import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.List; public class Permutations { public List> permute(int[] nums) { List> res = new LinkedList<>(); back_track(res, new ArrayList<>(), nums); return res; } public void back_track(List> res, List temp, int[] nums) { if (temp.size() == nums.length) { res.add(new ArrayList<>(temp)); return; } for (int i = 0; i > res = p.permute(nums); for (List l : res) { System.out.println(Arrays.toString(l.toArray())); } } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/48/":{"url":"codes/48/","title":"48. Rotate Image","keywords":"","body":"48. Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] emmmè¿™ä¸ªé¢˜æˆ‘ä½¿ç”¨äº†å¦ä¸€ä¸ªdouble arrayåº”è¯¥æ˜¯ä¸å’‹å¯¹ import java.util.Arrays; public class RotateImage { public void rotate(int[][] matrix) { int[][] res = new int[matrix.length][matrix[0].length]; for (int i = 0; i = 0; j --) { res[i][index++] = matrix[j][i]; } } for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/49/":{"url":"codes/49/","title":"49. Group Anagrams","keywords":"","body":"Group Anagrams Group Anagrams Given an array of strings, group anagrams together. Example: Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Output: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] Note: All inputs will be in lowercase. The order of your output does not matter. æŠŠä½¿ç”¨åŒä¸€ä¸ªå­—ç¬¦æ„æˆçš„stringæ”¾åˆ°ä¸€èµ·ã€‚é¦–å…ˆç¡®å®šæ˜¯ä½¿ç”¨HashMapï¼Œåœ¨éå†æ•°ç»„çš„æ—¶å€™å¯¹æ¯ä¸€ä¸ªstringå…ˆè¿›è¡Œsortä¸€ä¸‹ï¼ˆæˆ–è€…ç”¨hashçš„æ–¹æ³•ï¼Œæˆ‘ä¸‹é¢æœ‰å†™ï¼‰ï¼Œæ’è¿‡åºçš„stringå½“åškeyï¼Œå¦‚æœè¿˜æœ‰ç›¸åŒçš„æ•°æ®å°±æ¥ç€æ·»åŠ ï¼Œå¦‚æœæ²¡æœ‰è¯¥keyå°±åˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„ã€‚ import java.util.*; public class GroupAnagrams { public List> groupAnagrams(String[] strs) { List> list = new LinkedList<>(); HashMap> hashMap = new HashMap<>(); for (String str : strs) { hash(str); char[] temp_char = str.toCharArray(); Arrays.sort(temp_char); String key = Arrays.toString(temp_char).toString(); if (hashMap.containsKey(key)) { hashMap.get(key).add(str); } else { List temp = new LinkedList<>(); temp.add(str); hashMap.put(key, temp); } } for (String key : hashMap.keySet()) { list.add(hashMap.get(key)); } return list; } public void hash(String str) { int hash = 31; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/50/":{"url":"codes/50/","title":"50. Pow(x, n)","keywords":"","body":"Pow(x, n) Pow(x, n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 x n is a 32-bit signed integer, within the range [âˆ’231, 231 âˆ’ 1] è¿™ä¸ªå°±æ˜¯ç®€å•çš„æ±‚ä¸€ä¸‹å¹³æ–¹ï¼Œç„¶åç»™ä¿ç•™5ä½å°æ•°å°±è¡Œäº†ï¼Œç”¨Pythonç®€å•çš„å†™äº†ä¸€æ³¢ class Solution(object): def myPow(self, x, n): \"\"\" :type x: float :type n: int :rtype: float \"\"\" x = x**n x = 2**32-1 if x >= 2**32-1 else x x = -2**32 if x powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/53/":{"url":"codes/53/","title":"53. Maximum Subarray","keywords":"","body":"Maximum Subarray Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. é¢˜æ„è§£æï¼šæ‰¾åˆ°å’Œæœ€å¤§çš„å­åºåˆ—ã€‚ ç®—æ³•è§£æï¼š å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥åšã€‚åˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„é•¿åº¦å’ŒåŸæ•°ç»„ä¸€æ ·ï¼Œå¦‚æœi-1çš„æ•°å­—å°äºé›¶å°±è¡¨ç¤ºè¿™å°±ä¸ç”¨éœ€è¦è¿›è¡ŒåŠ å’Œï¼Œå› ä¸ºåŠ è´Ÿæ•°å°±æ˜¯åœ¨å‡å°ï¼Œç„¶åæŠŠiå°±è¡Œèµ‹å€¼ã€‚åœ¨æ¯æ¬¡å¾ªç¯çš„æ—¶å€™æ‰¾åˆ°æœ€å¤§çš„å€¼å°±è¡Œï¼ˆmax,dp[i]å–æœ€å¤§çš„ï¼‰ã€‚dp[i]å­˜çš„ç»“æœï¼šå¦‚æœdp[i-1]å°äºé›¶é‚£å°±æ˜¯æœ¬èº«ï¼Œä¸ç„¶å°±æ˜¯dp[i-1] + num[i]åŠ ä¸Šå½“å‰æ•°å­—ã€‚ public int maxSubArray(int[] nums) { int max = nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i çœ‹äº†å¤§ä½¬çš„æ€è·¯ä¹‹åå‘ç°äº†æ–°å¤©åœ°ï¼Œå¯ä»¥èŠ‚çœä¸€äº›å†…å­˜ç©ºé—´ï¼Œé™ä½ç©ºé—´å¤æ‚åº¦ï¼š åªéœ€è¦ä¸¤ä¸ªç©ºé—´çš„ä½ç½®å°±è¡Œäº†ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦iå’Œi-1è¿™ä¸¤ä¸ªå‚æ•°ã€‚ public int maxSubArray(int[] nums) { int max = nums[0]; int[] temp = new int[2]; temp[0] = nums[0]; for (int i = 1; i = 0) { temp[i % 2] = temp[(i-1) % 2] + nums[i]; max = Math.max(temp[i%2], max); } else { temp[i % 2] = nums[i]; } } return max; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/56/":{"url":"codes/56/","title":"56. Merge Intervals","keywords":"","body":"56. Merge Intervals Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2: Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: 1 intervals[i].length == 2 0 Solution å…ˆè¿›è¡Œæ’åºï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯å…ˆå¯¹æ•°ç»„çš„ç¬¬ä¸€ä¸ªæ•°å­—è¿›è¡Œæ’åºï¼Œç„¶åæ˜¯ç¬¬äºŒä½æ•°å­—ã€‚æ’å®Œåºä¹‹åå†è®¡ç®—ä¸€ä¸‹coverå°±è¡Œï¼Œä¸éš¾ï¼Œæƒ…å†µå¯èƒ½å¤šä¸€ç‚¹ï¼Œå¯ä»¥å…ˆå†™åŸºç¡€ä»£ç ï¼Œç„¶åä¼˜åŒ–ã€‚ class Solution { public: vector> merge(vector>& intervals) { std::sort(intervals.begin(), intervals.end(), [](const std::vector& a, const std::vector& b) { if (a[0] != b[0]) { return a[0] >(); int idx = 0; while (idx val) { break; } else { if (intervals[j][1] > val) val = intervals[j][1]; } j += 1; } if (j != idx + 1) { j --; auto tmp = vector(); tmp.push_back(intervals[idx][0]); // if (intervals[idx][1] > intervals[j][1]) tmp.push_back(intervals[idx][1]); // else tmp.push_back(intervals[j][1]); tmp.push_back(val); res.push_back(tmp); idx = j + 1; continue; } else { res.push_back(intervals[idx]); } idx += 1; } return res; } }; ä¼˜åŒ–ä¹‹åçš„ï¼š class Solution { public: vector> merge(vector>& intervals) { std::sort(intervals.begin(), intervals.end(), [](const std::vector& a, const std::vector& b) { return a[0] > res; int idx = 0; while (idx val) break; val = std::max(val, intervals[j][1]); j++; } res.emplace_back(vector{intervals[idx][0], val}); idx = j; } return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/57/":{"url":"codes/57/","title":"57. Insert Interval","keywords":"","body":"57. Insert Interval You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Note that you don't need to modify intervals in-place. You can make a new array and return it. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Constraints: 0 intervals[i].length == 2 0 intervals is sorted by starti in ascending order. newInterval.length == 2 0 Solution å’Œ56. Merge IntervalsåŸºæœ¬ä¸Šæ²¡å•¥åŒºåˆ«ï¼Œå¤šäº†ä¸€ä¸ªäºŒåˆ†æœç´¢ï¼Œæ‰¾åˆ°åˆé€‚çš„æ’å…¥ä½ç½®ã€‚ class Solution { public: vector> insert(vector>& intervals, vector& newInterval) { int left = 0, right = intervals.size() - 1; int target = newInterval[0]; while (left > res; int idx = 0; while (idx val) break; val = std::max(val, intervals[j][1]); j++; } res.emplace_back(vector{intervals[idx][0], val}); idx = j; } return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/58/":{"url":"codes/58/","title":"58. Length of Last Word","keywords":"","body":"58. Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word (last word means the last appearing word if we loop from left to right) in the string. If the last word does not exist, return 0. Note: A word is defined as a maximal substring consisting of non-space characters only. Example: Input: \"Hello World\" Output: 5 ç›´æ¥splitç„¶åå–æœ€åä¸€ä¸ªï¼Œç„¶åç›´æ¥è®¡ç®—length public class LengthofLastWord { public int lengthOfLastWord(String s) { if (s.equals(\"\")) return 0; String[] res = s.split(\" \"); if (res.length == 0) return 0; return res[res.length - 1].length(); } public static void main(String[] args) { String r = \"Hello world\"; LengthofLastWord l = new LengthofLastWord(); System.out.println(l.lengthOfLastWord(r)); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/61/":{"url":"codes/61/","title":"61. Rotate List","keywords":"","body":"61. Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL åšæ³•ç¨å¾®è ¢äº†ä¸€ç‚¹ï¼Œæˆ‘æ˜¯é€šè¿‡å…ˆè®¡ç®—é“¾è¡¨çš„é•¿åº¦ï¼Œç„¶åæŠŠk = k % lengthè¿™æ ·å°±å¯ä»¥å¾—åˆ°ç›¸å¯¹é“¾è¡¨æ¥è¯´çš„ç¬¬å‡ ä½ã€‚ç„¶åéå†é“¾è¡¨ï¼Œå½“èŠ‚ç‚¹çš„indexç­‰äºkçš„æ—¶å€™å¼€å§‹æŠŠkä¹‹åçš„nodeæ”¾åˆ°é“¾è¡¨çš„èµ·å§‹ä½ç½®ã€‚è¿™æ ·å°±å®Œæˆäº†rotate listã€‚ public class RotateList { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode rotateRight(ListNode head, int k) { if (head == null || head.next == null || k == 0) return head; ListNode curr = head; int length = length(curr); k = length - (k % length); if(k == length) return head; ListNode rota = find_rota(curr, k); ListNode temp = rota; while (temp.next != null) { temp = temp.next; } temp.next = head; head = rota; return head; } public ListNode find_rota(ListNode curr, int k) { while (k > 1) { curr = curr.next; k --; } ListNode node = curr.next; curr.next = null; return node; } public int length(ListNode node) { int length = 0; while (node != null) { node = node.next; length ++; } return length; } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(3); // ListNode l4 = new ListNode(4); // ListNode l5 = new ListNode(5); l1.next = l2; l2.next = l3; // l3.next = l4; // l4.next = l5; RotateList r = new RotateList(); r.rotateRight(l1, 2); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/66/":{"url":"codes/66/","title":"66. Plus One","keywords":"","body":"Plus One Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. ä¸€ä¸ªæ•°å­¦çš„é—®é¢˜ï¼Œåœ¨æœ€åé¢åŠ 1ï¼Œç„¶åå¦‚æœå¤§äº10ï¼Œé‚£ä¹ˆå‰é¢çš„æ•°å­—å°±éœ€è¦åŠ ä¸€ã€‚å¯ä»¥ç›´æ¥ä¸ç”¨åˆ†ç±»æ¥è®¨è®ºï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸€ä¸ªå¾ªç¯index ï¼Œindex = nums.length - 1è¿™æ ·æˆ‘ä»¬ä»æœ€åé¢å¼€å§‹åŠ 1ï¼Œoverflowæ˜¯ç”¨æ¥åˆ¤æ–­æ˜¯å¦æº¢å‡ºï¼Œåœ¨å¾ªç¯é‡Œé¢å¦‚æœæ²¡æœ‰æº¢å‡ºï¼Œå°±è¡¨ç¤ºå‰é¢æ•°å­—åŠ ä¸€çš„ç»“æœä¸å¤§äº10ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥breakã€‚è¿˜æœ‰ä¸€ç§å¦‚æœå¾ªç¯ç»“æŸäº†ä¾ç„¶æº¢å‡ºäº†ï¼Œè¿™æ—¶å€™æˆ‘ä»¬éœ€è¦åœ¨arrayé‡Œé¢å¤šåŠ ä¸€ä¸ªæ•°å­—åœ¨æœ€å‰é¢ã€‚ import java.util.Arrays; import java.util.stream.IntStream; public class PlusOne { public int[] plusOne(int[] digits) { int lens = digits.length - 1; int[] nums = digits.clone(); int overflow = 0; nums[lens] += 1; while (lens != -1) { // every time plus one nums[lens] += overflow; overflow = nums[lens] / 10; if (nums[lens] > 9) nums[lens] %= 10; lens --; // å½“ä¸æº¢å‡ºçš„æ—¶å€™å°±å¯ä»¥breakäº†ï¼Œå› ä¸ºä¸ä¼šè¿›ä½äº† if (overflow == 0) break; } // å¦‚æœå¾ªç¯ç»“æŸè¿˜æº¢å‡ºï¼Œè¯´æ˜è¿˜éœ€è¦å¤šå¼€è¾Ÿä¸€ä¸ªå†…å­˜ä½ç½®ã€‚ if (overflow != 0) { nums = IntStream.concat(Arrays.stream(new int[] {1}), Arrays.stream(nums)).toArray(); } return nums; } public static void main(String[] args) { int[] nums = new int[] {8,9}; PlusOne p = new PlusOne(); int[] res = p.plusOne(nums); System.out.println(Arrays.toString(res)); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/70/":{"url":"codes/70/","title":"70. Climbing Stairs","keywords":"","body":"Climbing Stairs Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step è¿™æ˜¯ä¸€ä¸ªå¾ˆç»å…¸çš„åŠ¨æ€è§„åˆ’çš„é—®é¢˜ã€‚ä¸€æ¬¡å¯ä»¥èµ°ä¸€é˜¶æ¥¼æ¢¯æˆ–è€…ä¸¤é˜¶æ¥¼æ¢¯ã€‚åœ¨ç¬¬ä¸€å±‚çš„æ—¶å€™è‚¯å®šåªèƒ½ä¸Šä¸€é˜¶ï¼Œç¬¬äºŒå±‚çš„æ—¶å€™å¯ä»¥æ˜¯1+1ï¼ˆè¿ç»­èµ°ä¸¤ä¸ªä¸€é˜¶ï¼‰æˆ–è€…2ï¼ˆç›´æ¥ä¸¤é˜¶ï¼‰æ‰€ä»¥æ˜¯ä¸¤ç§æ–¹æ³•ï¼Œç¬¬ä¸‰å±‚çš„æ—¶å€™å¯ä»¥æ˜¯1+1+1, 1+2, 2+1ä¸‰ç§æ–¹æ³•ã€‚æ‰€ä»¥å¯ä»¥çœ‹å‡º$f(n)=f(n-1)+f(n-2)$çš„ç®—æ³•ã€‚ public int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; int[] array = new int[n]; array[0] = 1; array[1] = 2; for (int i = 2; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/75/":{"url":"codes/75/","title":"75. Sort Colors","keywords":"","body":"75. Sort Colors Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function. Example 1: Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Example 2: Input: nums = [2,0,1] Output: [0,1,2] Constraints: n == nums.length 1 nums[i] is either 0, 1, or 2. Follow up: Could you come up with a one-pass algorithm using only constant extra space? Solution å¯ä»¥ä½¿ç”¨hashmapæˆ–è€…ç›´æ¥countæ•°é‡ä¹Ÿè¡Œã€‚ S1 class Solution { public: void sortColors(vector& nums) { auto maps = unordered_map>(); for (int const& num : nums) { maps[num].push_back(num); } int idx = 0; for (int i = 0; i S2 class Solution { public: void sortColors(vector& nums) { int cnt0 = 0; int cnt1 = 0; int cnt2 = 0; for (int const & num : nums) { if (num == 0) cnt0 ++; if (num == 1) cnt1 ++; if (num == 2) cnt2 ++; } int idx = 0; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/80/":{"url":"codes/80/","title":"80. Remove Duplicates from Sorted Array II","keywords":"","body":"80. Remove Duplicates from Sorted Array II Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Solution ä¸€å¼€å§‹ç†è§£é”™äº†ï¼Œä»¥ä¸ºåªè¦è¿”å›æ•°é‡å°±è¡Œï¼Œåé¢å‘ç°è¿˜éœ€è¦é¢å¤–çš„ä¿®æ”¹å†…å­˜æ•°æ®ã€‚å…¶å®è¿™ä¸ªé¢˜å¾ˆç®€å•ï¼Œåªéœ€è¦ç”¨åˆ°åŒæŒ‡é’ˆå°±è¡Œï¼Œæˆ–è€…å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•ï¼Œæ„æ€éƒ½æ˜¯å·®ä¸å¤šçš„ã€‚idxæŒ‡é’ˆè´Ÿè´£å»éå†numsæ•°æ®ï¼Œs_idxè´Ÿè´£è®°å½•æ›´æ–°å¼€å§‹çš„åæ ‡ã€‚ class Solution { public: int removeDuplicates(vector& nums) { int idx = 0, s_idx = 0, val = 0, cnt = 0; while (idx powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/82/":{"url":"codes/82/","title":"82. Remove Duplicates from Sorted List II","keywords":"","body":"82. Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5 Example 2: Input: 1->1->1->2->3 Output: 2->3 è¿™ä¸ªç¬¬83çš„è¿›é˜¶ç‰ˆã€‚åªè¦æ˜¯æœ‰é‡å¤çš„nodeéƒ½éœ€è¦åˆ é™¤æ‰ã€‚æˆ‘ä»¬éœ€è¦æœ‰ä¸€ä¸ªnodeï¼ˆlastï¼‰æ¥è®°å½•ä¸Šä¸€ä¸ªè®¿é—®çš„nodeï¼Œä¸€ä¸ªnodeï¼ˆcurrï¼‰æ¥å¾ªç¯ã€‚å¦‚æœcurr.val == curr.next.valå°±ä»£è¡¨ç€æœ‰é‡å¤çš„nodeäº†ï¼Œè¿™æ—¶å€™æ‰¾åˆ°æ‰€æœ‰é‡å¤çš„nodeï¼Œç„¶åå¾—åˆ°æœ€åä¸€ä¸ªé‡å¤nodeçš„nextï¼Œç„¶åä½¿ç”¨lasté“¾æ¥å°±è¡Œï¼Œä½†æ˜¯lastéœ€è¦åˆ¤æ–­æ˜¯å¦æ˜¯nullï¼Œå¦‚æœæ˜¯nullçš„è¯éœ€è¦è€ƒè™‘åˆ°headçš„æƒ…å†µã€‚ public class RemoveDuplicatesfromSortedListII { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; ListNode last = null; ListNode curr = head; while (curr.next != null) { if (curr.val == curr.next.val) { ListNode node = different(curr); if (last == null) { head = node; } else { last.next = node; } curr = node; if (curr == null) break; continue; } else { last = curr; } curr = curr.next; } return head; } public ListNode different(ListNode node) { ListNode last = node; while (node.next != null) { if (node.val != node.next.val) { return node.next; } last = node; node = node.next; } // å› ä¸ºæ˜¯node.next != null æ‰€ä»¥éœ€è¦åˆ¤æ–­æœ€åä¸€ä¸ªnodeæ˜¯ä¸æ˜¯å’Œå‰é¢çš„ç›¸ç­‰ if (last.val == node.val) return null; return node; } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(2); ListNode l4 = new ListNode(2); // ListNode l5 = new ListNode(5); l1.next = l2; l2.next = l3; l3.next = l4; // l4.next = l5; RemoveDuplicatesfromSortedListII r = new RemoveDuplicatesfromSortedListII(); r.deleteDuplicates(l1); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/83/":{"url":"codes/83/","title":"83. Remove Duplicates from Sorted List","keywords":"","body":"83. Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2 Example 2: Input: 1->1->2->3->3 Output: 1->2->3 åœ¨å·²ç»sortedçš„é“¾è¡¨é‡Œé¢å»é™¤é‡å¤çš„å€¼ï¼Œå¯ä»¥ä½¿ç”¨è¿ä¸ªæŒ‡é’ˆæ¥å®Œæˆï¼Œcurræ¥å‰è¿›ï¼Œtempæ¥é“¾æ¥ä¸ä¸€æ ·çš„å€¼ã€‚å½“temp.val != curr.valçš„æ—¶å€™ä»£è¡¨ä¸­é—´å·²ç»çœç•¥äº†åŒç±»é¡¹ï¼Œæ‰€ä»¥ç›´æ¥è®¾ç½®temp.next = currç„¶åæŠŠcurrèµ‹å€¼ç»™tempï¼ˆtemp = currï¼‰ã€‚ public class RemoveDuplicatesfromSortedList { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; ListNode curr = head.next; ListNode temp = head; while (curr != null) { if (temp.val != curr.val) { temp.next = curr; temp = curr; } curr = curr.next; } temp.next = null; return head; } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(1); ListNode l3 = new ListNode(2); l1.next = l2; l2.next = l3; l3.next = null; RemoveDuplicatesfromSortedList re = new RemoveDuplicatesfromSortedList(); ListNode head = re.deleteDuplicates(l1); while (head != null) { System.out.println(head.val); head = head.next; } } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/86/":{"url":"codes/86/","title":"86. Partition List","keywords":"","body":"86. Partition List Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example 1: Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] Example 2: Input: head = [2,1], x = 2 Output: [1,2] Solution ä¸éš¾ï¼Œè®°å½•ä¸€ä¸‹è®¿é—®åˆ°çš„nodeså°±è¡Œï¼Œ æˆ–è€…å¯ä»¥é€šè¿‡åŠ¨æ€çš„è®°å½•ä¸¤æ¡linked listç„¶ååˆå¹¶ï¼Œä½†æ˜¯è¿™ç§å®¹æ˜“å‡ºé”™ï¼Œæœ‰æ—¶é—´å¯ä»¥å°è¯•å®ç°ä¸€ä¸‹ã€‚ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { auto sm = vector(); auto lg = vector(); auto curr = head; while (curr != NULL) { if (curr->val next; } if (!sm.empty()) head = sm[0]; if (sm.empty() && !lg.empty()) head = lg[0]; curr = NULL; for (int i = 0; i next = sm[i]; curr = sm[i]; } } for (int i = 0; i next = lg[i]; curr = lg[i]; } } if (curr != NULL) curr->next = NULL; return head; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/88/":{"url":"codes/88/","title":"88. Merge Sorted Array","keywords":"","body":"Merge Sorted Array Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] è¿™æ˜¯æˆ‘ä»Šå¤©é€›ç‰›å®¢çš„æ—¶å€™å‘ç°çš„ä¸€é“é¢˜ï¼Œç„¶åæƒ³äº†ä¸€ä¸‹ï¼ŒæŒ‰ç…§æˆ‘ç°åœ¨çš„æ€æƒ³å¥½åƒåªçŸ¥é“ç›´æ¥mergeç„¶åsortã€‚è¿˜æœ‰ä¸€ç§å°±æ˜¯æ­£åºæ’å…¥ï¼Œä½†æ˜¯æ¯ä¸ªelementéƒ½éœ€è¦åç§»ä¸€ä½ï¼Œä½†æ˜¯è¿™æ ·çš„æ•ˆç‡å¤ªä½äº†ï¼Œçœ‹äº†ç½‘ä¸Šçš„å¤§ç¥çš„ideaä¹‹åå°±å‘ç°äº†æ–°å¤§é™†ã€‚å› ä¸ºè¿™ä¸ªlistæ˜¯æ‹è¿‡åºçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±çŸ¥é“äº†æœ€åä¸€ä¸ªå…ƒç´ è‚¯å®šæ˜¯æœ€å¤§ã€‚é‚£ä¹ˆæˆ‘ä»¬ä¸ºä»€ä¹ˆä¸ä»åé¢å¾€å‰é¢å¾ªç¯å‘¢ï¼Œè¿™æ ·ä¸éœ€è¦å…ƒç´ ä»¥ä¸ºï¼Œåªéœ€è¦ç›´æ¥èµ‹å€¼å°±å¥½äº†ã€‚ public void merge(int[] nums1, int m, int[] nums2, int n) { // the last position of array int last = nums1.length - 1; m--; n--; while (m > 0 && n > 0) { if (nums1[m] > nums2[n]) nums1[last--] = nums1[m--]; else nums1[last--] = nums2[n--]; } while (m > 0) nums1[last--] = nums1[m--]; while (n > 0) nums1[last--] = nums2[n--]; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/92/":{"url":"codes/92/","title":"92. Reverse Linked List II","keywords":"","body":"92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 â‰¤ m â‰¤ n â‰¤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL ä»èµ·å§‹ç‚¹åˆ°ç»“æŸç‚¹è¿›è¡Œreverseã€‚é¦–å…ˆæ ¹æ®currçš„indexéå†åˆ°mçš„æ—¶å€™è®°å½•ä¸€ä¸‹è¯¥node startï¼Œç„¶ååŒæ—¶è®°å½•startå‰é¢çš„ä¸€ä¸ªnode preå› ä¸ºreverseç»“æŸè¿˜è¦æŠŠé“¾è¡¨é“¾æ¥èµ·æ¥ã€‚å½“indexéå†åˆ°nçš„æ—¶å€™è®°å½•è¯¥node endã€‚ç„¶åä½¿ç”¨é€’å½’è¿›è¡Œreverseã€‚ public class ReverseLinkedListII { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public ListNode reverseBetween(ListNode head, int m, int n) { if (m >= n || head == null || head.next == null) return head; int index = 1; ListNode curr = head; ListNode start = null; ListNode end = null; ListNode pre = null; while (curr != null) { if (index == m) start = curr; if (index == n) end = curr; if (start == null) pre = curr; curr = curr.next; ++index; } if (end == null || start == null) return head; ListNode rest = end.next; end.next = null; reverse(start, start.next); // ç°åœ¨enduåº”è¯¥æ˜¯head if (pre == null) head = end; else pre.next = end; start.next = rest; return head; } public void reverse(ListNode curr, ListNode next) { if (next == null) return; reverse(next, next.next); next.next = curr; curr.next = null; } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(3); ListNode l4 = new ListNode(4); l1.next = l2; l2.next = l3; l3.next = l4; ReverseLinkedListII r = new ReverseLinkedListII(); r.reverseBetween(l1, 1, 4); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/100/":{"url":"codes/100/","title":"100. Same Tree","keywords":"","body":"100. Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false æ€è·¯å°±æ˜¯å·¦å³ä¸¤è¾¹çš„nodeéƒ½ä¸€æ ·ã€‚ public class SameTree { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null && q == null) return true; if (p == null || q == null) return false; boolean left = isSameTree(p.left, q.left); boolean right = isSameTree(p.right, q.right); return p.val == q.val && (left && right); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/101/":{"url":"codes/101/","title":"101. Symmetric Tree","keywords":"","body":"101. Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3 å…¶å®æ˜¯å’Œä¸Šé¢é‚£é“é¢˜ä¸€ä¸ªç›¸åçš„æ€è·¯ï¼Œä¸Šé¢æ˜¯å·¦å³ç›¸ç­‰ï¼Œè¿™ä¸ªæ˜¯left = right, right = leftã€‚ public class SymmetricTree { public boolean isSymmetric(TreeNode root) { if (root == null) return true; return mirror(root.left, root.right); } // åˆ¤æ–­å·¦å³æ˜¯å¦ä¸€æ · public boolean mirror(TreeNode p, TreeNode q) { if (p == null && q == null) return true; if (p == null || q == null) return false; boolean left = mirror(p.left, q.right); boolean right = mirror(p.right, q.left); return p.val == q.val && (left && right); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/102/":{"url":"codes/102/","title":"102. Binary Tree Level Order Traversal","keywords":"","body":"102. Binary Tree Level Order Traversal Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] Solution BFSå°±èƒ½è§£å†³ã€‚ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector> levelOrder(TreeNode* root) { std::queue queue; // std::queue nq; auto res = vector>(); if (root == NULL) return res; int cnt = 1; int cntn = 0; queue.push(root); auto curr = vector(); while (!queue.empty()) { auto node = queue.front(); queue.pop(); cnt --; curr.push_back(node->val); if (node->left != NULL) { queue.push(node->left); cntn ++; } if (node->right != NULL) { queue.push(node->right); cntn ++; } if (cnt == 0) { res.push_back(curr); curr.clear(); cnt = cntn; cntn = 0; } } return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/107/":{"url":"codes/107/","title":"107. Binary Tree Level Order Traversal II","keywords":"","body":"107. Binary Tree Level Order Traversal II Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root). Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[15,7],[9,20],[3]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 Solution å’Œ102é¢˜æ€è·¯å·®ä¸å¤šï¼Œå¯ä»¥bfséå†ä¹‹åå†reverseä¸€ä¸‹æ•°ç»„å°±è¡Œã€‚ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector> levelOrderBottom(TreeNode* root) { std::queue queue; // std::queue nq; auto res = vector>(); if (root == NULL) return res; int cnt = 1; int cntn = 0; queue.push(root); auto curr = vector(); while (!queue.empty()) { auto node = queue.front(); queue.pop(); cnt --; curr.push_back(node->val); if (node->left != NULL) { queue.push(node->left); cntn ++; } if (node->right != NULL) { queue.push(node->right); cntn ++; } if (cnt == 0) { res.push_back(curr); curr.clear(); cnt = cntn; cntn = 0; } } std::reverse(res.begin(), res.end()); return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/111/":{"url":"codes/111/","title":"111. Minimum Depth of Binary Tree","keywords":"","body":"111. Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its minimum depth = 2. å…³äºtreeçš„ç®—æ³•å¯ä»¥å»çœ‹æˆ‘å¦ä¸€ç¯‡æ–‡ç« https://shunyangli.github.io/2020/05/03/Algorithm/#more public class MinimumDepthofBinaryTree { public int minDepth(TreeNode root) { if (root == null) return 0; if (root.left == null && root.right == null) return 1; int left = minDepth(root.left); int right = minDepth(root.right); if (root.left == null) return 1 + right; if (root.right == null) return 1 + left; return Math.min(left, right) + 1; } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/112/":{"url":"codes/112/","title":"112. Path Sum","keywords":"","body":"112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22. public class PathSum { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) return false; if (root.left == null && root.right == null) return root.val == sum; boolean left = hasPathSum(root.left, sum - root.val); boolean right = hasPathSum(root.right, sum - root.val); return left | right; } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/121/":{"url":"codes/121/","title":"121. Best Time to Buy and Sell Stock","keywords":"","body":"Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. è¿™ä¸ªé¢˜çš„æ€è·¯ç¨å¾®ç®€å•ä¸€ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥æ‰¾åˆ°æœ€å°çš„ä¹°å…¥ä»·æ ¼ï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥æ ¹ç»åœ¨ä¹°å…¥ä»·æ ¼æœ€ä½çš„æ—¥æœŸä¹‹åï¼Œæ‰¾åˆ°å–å‡ºä»·æ ¼æœ€é«˜çš„ç‚¹ï¼Œè¿™æ ·æ”¶ç›Šå°±æ˜¯æœ€å¤§çš„ã€‚ public int maxProfit(int[] prices) { if (prices.length = 0) max = Math.max(max, price-stock); // æ‰¾åˆ°æœ€æ–°çš„æ”¶å…¥ stock = Math.min(stock, price); } return max; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/125/":{"url":"codes/125/","title":"125. Valid Palindrome","keywords":"","body":"125. Valid Palindrome Valid Palindrome: Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. This one is pretty easy, we just need to ignore the char which is not belong to a-z, 0-9. During the processing, we can use double pointer to do that. Set a index from the left and a index from the right. class Solution: def isPalindrome(self, s: str) -> bool: s = s.lower() start = 0 end = len(s) - 1 while start powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/127/":{"url":"codes/127/","title":"127. Word Ladder","keywords":"","body":"126. Word Ladder Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: 5 Explanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", return its length 5. è¯è¯­æ¥é¾™ï¼Œä¸€ä¸ªè€å¤–å¾ˆå–œæ¬¢çš„æ¸¸æˆï¼Œæˆ‘è§‰å¾—ä»–ä»¬çš„testæœ‰é—®é¢˜ã€‚ã€‚ã€‚è¿™ä¸ªæ•°é‡å°±å¾ˆå¥‡æ€ªï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯æŒ‰ç…§æˆ‘çš„æ–¹æ³•æ¥ï¼Œæˆ‘ä¸è§‰å¾—æˆ‘å†™é”™äº†ï¼Œä½¿ç”¨äº†ä¸€ä¸ªbfsçš„ç®—æ³•ï¼Œå› ä¸ºæ¯æ¬¡æ”¹å˜ä¸€ä¸ªå•è¯å…¶ä¸­çš„ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶ååˆ¤æ–­æ–°ç”Ÿæˆçš„å­—ç¬¦æ˜¯å¦åœ¨wordListä¹‹é—´ï¼Œç„¶åå†åˆ¤æ–­æ˜¯ä¸æ˜¯å·²ç»visitedè¿‡çš„ã€‚ import java.util.*; public class WordLadder { public int ladderLength(String beginWord, String endWord, List wordList) { int step = 0; if (!wordList.contains(endWord)) return step; Queue queue = new LinkedList<>(); queue.offer(beginWord); Set visited = new HashSet<>(); while (!queue.isEmpty()) { ++step; for (int x = 0; x list = new ArrayList( Arrays.asList(\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\") ); int res = w.ladderLength(\"hit\", \"cog\", list); System.out.println(res); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/130/":{"url":"codes/130/","title":"130. Surrounded Regions","keywords":"","body":"130. Surrounded Regions You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded: Connect: A cell is connected to adjacent cells horizontally or vertically. Region: To form a region connect every 'O' cell. Surround: The region is surrounded with 'X' cells if you can connect the region with 'X' cells and none of the region cells are on the edge of the board. A surrounded region is captured by replacing all 'O's with 'X's in the input matrix board. Example 1: Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded. Example 2: Input: board = [[\"X\"]] Output: [[\"X\"]] Solution è¿™ä¸ªé¢˜å¤§æ¦‚æ„æ€å°±æ˜¯å½“Oåœ¨ç½‘æ ¼çš„è¾¹ç¼˜åœ°åŒºåˆ™ä¸ä¼šè¢«XåŒåŒ–ï¼Œå¦‚æœä¸åœ¨è¾¹ç¼˜çš„Oèƒ½å’Œåœ¨è¾¹ç¼˜çš„Oè¿æ¥çš„è¯åˆ™ä¸ä¼šè¢«åŒåŒ–ã€‚å…¶ä»–çš„åˆ™éƒ½ä¼šè¢«åŒåŒ–æˆXã€‚ S1 å¯ä»¥é€šè¿‡è¾¹ç¼˜Oå‡ºå‘åšdfsæ‰¾åˆ°å’Œå®ƒæ‰€æœ‰å…³è”çš„Oã€‚ S2 é€šè¿‡union findæ¥è§£å†³ class UnionFind { private: vector root; int cnt; public: explicit UnionFind(int n) { for (int i = 0; i >& board) { if (board.empty()) return; auto size = board.size() * board[0].size(); auto uf = UnionFind(size + 1); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/134/":{"url":"codes/134/","title":"134. Gas Station","keywords":"","body":"134. Gas Station There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique. Example 1: Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. Example 2: Input: gas = [2,3,4], cost = [3,4,3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. Constraints: n == gas.length == cost.length 1 0 Solution Baseline ä¸€å¼€å§‹æ²¡å¾ˆæ¸…æ¥šçš„ç†è§£é¢˜æ„ï¼Œé€‰äº†ä¸€ä¸ªæœ€å¤æ‚çš„è§£æ³• O(n^2)å§ã€‚ class Solution { public: int canCompleteCircuit(vector& gas, vector& cost) { if (gas.size() != cost.size()) return -1; for (int i = 0; i = 0) return i; } return -1; } }; Greedy é€»è¾‘æ ¸å¿ƒï¼š å’Œ Python å®ç°ç±»ä¼¼ï¼Œä½¿ç”¨ä¸¤ä¸ªå˜é‡ total_tank å’Œ curr_tank åˆ†åˆ«è®°å½•æ€»å‰©ä½™æ²¹é‡å’Œå½“å‰è·¯å¾„çš„å‰©ä½™æ²¹é‡ã€‚ å½“ curr_tank å°äº 0 æ—¶ï¼Œè¯´æ˜ä»¥å½“å‰èµ·å§‹ç‚¹æ— æ³•å®Œæˆè·¯å¾„ï¼Œå°†èµ·å§‹ç‚¹æ›´æ–°ä¸ºä¸‹ä¸€ä¸ªåŠ æ²¹ç«™ã€‚ å¤æ‚åº¦åˆ†æï¼š æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œåªéœ€éå†åŠ æ²¹ç«™ä¸€æ¬¡ã€‚ ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œåªä½¿ç”¨äº†å¸¸é‡ç©ºé—´ã€‚ å‡½æ•°è°ƒç”¨ï¼š ä¼ å…¥ä¸¤ä¸ªå‘é‡ gas å’Œ costï¼Œåˆ†åˆ«è¡¨ç¤ºæ¯ä¸ªåŠ æ²¹ç«™çš„æ±½æ²¹é‡å’Œåˆ°ä¸‹ä¸€ä¸ªåŠ æ²¹ç«™çš„æ¶ˆè€—é‡ã€‚ è¿”å›å€¼æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºèµ·å§‹åŠ æ²¹ç«™çš„ç´¢å¼•ï¼›è‹¥æ— è§£åˆ™è¿”å› -1ã€‚ ç†è§£é¢˜ç›®æç¤º å¯èƒ½äº§ç”Ÿç–‘æƒ‘çš„åœ°æ–¹åœ¨äºé¢˜ç›®æè¿°çš„ç¯å½¢è·¯å¾„æ€§è´¨ï¼š ç¯å½¢è·¯å¾„æ„å‘³ç€ä»æœ€åä¸€ä¸ªåŠ æ²¹ç«™çš„æ¶ˆè€—æ˜¯å›åˆ°ç¬¬ä¸€ä¸ªåŠ æ²¹ç«™ï¼Œè¿™ç§æ€§è´¨å¯èƒ½è®©äººè¯¯ä»¥ä¸ºéœ€è¦ç”¨ cost[i-1] ä¹‹ç±»çš„ç´¢å¼•æ“ä½œã€‚ å®é™…ä¸Šï¼Œgas[i] - cost[i] çš„ç›´æ¥è®¡ç®—å·²ç»æ¶µç›–äº†åŠ æ²¹å’Œæ¶ˆè€—çš„æœ¬è´¨ï¼Œé¢˜ç›®æ‰€è¯´çš„ç¯å½¢åªå½±å“ç´¢å¼•åœ¨é€»è¾‘ä¸Šæ˜¯å¾ªç¯çš„ã€‚ é‡ç‚¹ï¼šç¯å½¢è·¯å¾„çš„æ ¸å¿ƒ ç¯å½¢è·¯å¾„çš„ç‰¹æ€§åªæ˜¯åŠ æ²¹ç«™ç¼–å·çš„é€»è¾‘å¾ªç¯ï¼Œå®ƒåœ¨ç¼–ç¨‹ä¸­ç›´æ¥ä½“ç°åœ¨ç´¢å¼•è¿ç®—çš„è¾¹ç•Œå¤„ç†ä¸Šï¼š i = n - 1 åˆ° i = 0 è¿™ç§è·³è·ƒæ˜¯å¾ªç¯è·¯å¾„çš„ä½“ç°ã€‚ æ•°ç»„ä¸­å¹¶æ²¡æœ‰å®é™…çš„é¢å¤–å¤æ‚æ€§ï¼Œç›´æ¥è®¡ç®—å³å¯ã€‚ class Solution { public: int canCompleteCircuit(vector& gas, vector& cost) { int total_tank = 0; int curr_tank = 0; int start_station = 0; for (int i = 0; i = 0 ? start_station : -1; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/136/":{"url":"codes/136/","title":"136. Single Number","keywords":"","body":"Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 åº†å¹¸ä¸€ä¸‹ç»ˆäºå¯ä»¥ç‹¬ç«‹æ€è€ƒå‡ºæ¥ä¸€äº›ç®€å•çš„ç®—æ³•äº†ã€‚è¿™ä¸ªé¢˜å…¶å®ç®—æ˜¯è¿˜OKçš„ï¼Œå¯ä»¥ä½¿ç”¨HashMapè§£å†³ï¼Œå› ä¸ºHashMapç›‘æµ‹keyçš„æ—¶å€™çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(1)$ï¼Œæ‰€ä»¥æ•´ä½“æ—¶é—´æ˜¯$O(n)$ã€‚åœ¨loopé‡Œé¢å»åˆ¤æ–­è¯¥æ•°å­—æ˜¯å¦å­˜åœ¨HashMapé‡Œé¢ï¼Œå¦‚æœä¸å­˜åœ¨å°±pushè¿›å»ï¼Œå¦‚æœå·²ç»å­˜åœ¨å°±åˆ é™¤ã€‚é‚£ä¹ˆæœ€åå‰©ä¸‹çš„é‚£ä¸ªå…ƒç´ è‚¯å®šæ˜¯singleï¼ˆå•èº«ç‹—ï¼‰ã€‚ public int singleNumber (int[] A) { // write code here Map map = new HashMap<>(); for (int value : A) { if (map.containsKey(value)) { map.remove(value); } else { map.put(value, value); } } return map.get(map.keySet().toArray()[0]); } Ps: åœ¨discussé‡Œé¢çœ‹åˆ°äº†ä¸€ä¸ªç‰¹åˆ«éªšçš„æ“ä½œã€‚ã€‚ã€‚çœŸçš„éªšæ“ä½œã€‚ã€‚ã€‚ ä½¿ç”¨äº†å¼‚æˆ–ï¼ˆexclusive ORç®€ç§°xorï¼‰è¿™ä¸ªæ¥åˆ¤æ–­çš„ï¼Œå¼‚æˆ–çš„è¯ç©ºé—´å¤æ‚åº¦åªæœ‰$O(1)$ã€‚ $1\\oplus0=1$ $1\\oplus1=1$ $0\\oplus0=0$ $0\\oplus1=1$ public int singleNumber(int[] nums) { int res = 0; for (int i = 0; i è¡Œå§ã€‚ã€‚ã€‚ç‰›é€¼ã€‚ã€‚ powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/141/":{"url":"codes/141/","title":"141. Linked List Cycle","keywords":"","body":"Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. ç®—æ³•æ€è·¯ï¼š ä¸€å¼€å§‹æƒ³åˆ°çš„æ˜¯ç”¨HashMapçš„æ–¹å¼æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯è¿™æ ·çš„è¯ç©ºé—´å¤æ‚åº¦å°±é«˜äº†å¾ˆå¤šå°±æ˜¯$O(n)$äº†ï¼Œç„¶åçœ‹äº†ä¸€ä¸‹å¤§ç¥ä»¬çš„è§£æ³•ï¼Œå°±æ˜¯åˆ©ç”¨å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•ï¼Œä¸¤ç§æˆ‘éƒ½è¯•äº†ä¸€ä¸‹ï¼š HashMapçš„æ–¹æ³• public boolean hasCycle(ListNode head) { Map map = new HashMap<>(); ListNode curr = head; while (curr != null) { if (map.containsKey(curr)) return true; else map.put(curr, 1); curr = curr.next; } return false; } å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³• è¿™æ ·æ•ˆç‡é«˜ï¼Œå†…å­˜å ç”¨å°‘ public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (slow == fast) return true; } return false; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/142/":{"url":"codes/142/","title":"142. Linked List Cycle II","keywords":"","body":"142. Linked List Cycle II Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. é¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯HashMapå“ˆå“ˆå“ˆå“ˆï¼Œç„¶åä»–è¦æ±‚è¯´ä¸ç”¨é¢å¤–çš„ç©ºé—´ï¼Œåœ¨ä¸å®ç”¨é¢å¤–çš„ç©ºé—´çš„æƒ…å†µä¸‹æƒ³åˆ°äº†é€’å½’+å¾ªç¯çš„æ–¹æ³•ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒé«˜ã€‚åœ¨å¾ªç¯çš„è¿‡ç¨‹ä¸­æ¯ä¸ªnodeéƒ½è¿›è¡Œä¸€ä¸ªæ£€æŸ¥ç¯çš„æ“ä½œï¼Œå¹¶ä¸”åˆ¤æ–­åœ¨ç¯é‡Œé¢æ˜¯ä¸æ˜¯ç­‰äºè¯¥æ•°å­—ï¼Œå¦‚æœä¸ç­‰äºçš„è¯å°±ä»£è¡¨ä¸æ˜¯ç¯çš„ä¸€ä¸ªnodeï¼Œå½“å‡ºç°ç¬¬ä¸€ä¸ªnodeå¹¶ä¸”æ˜¯åœ¨ç¯é‡Œé¢çš„nodeå°±ä»£è¡¨æ˜¯ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚æ„Ÿè§‰ç‰ºç‰²äº†æ—¶é—´æ¢æ¥äº†ç©ºé—´çš„ä¼˜åŒ–ã€‚ã€‚ã€‚ã€‚ã€‚ import java.util.HashMap; public class LinkedListCycleII { public static class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } // hashmapçš„è§£å†³æ–¹æ³• // public ListNode detectCycle(ListNode head) { // HashMap map = new HashMap<>(); // // ListNode curr = head; // while (curr != null) { // if (map.containsKey(curr)) { // return curr; // } else { // map.put(curr, 1); // } // curr = curr.next; // } // // return null; // } public ListNode detectCycle(ListNode head) { if (head == null || head.next == null) return null; ListNode curr = head; while (curr.next != null) { ListNode temp = loop(curr.next, curr.next.next, curr); if (temp != null) return curr; curr = curr.next; } return null; } public ListNode loop(ListNode slow, ListNode fast, ListNode node) { if (slow == null || fast == null || slow.next == null || fast.next == null || fast.next.next == null) return null; if (slow == fast && slow == node) return slow; if (slow == fast) return null; return loop(slow.next, fast.next.next, node); } public static void main(String[] args) { ListNode l1 = new ListNode(1); ListNode l2 = new ListNode(2); ListNode l3 = new ListNode(3); ListNode l4 = new ListNode(4); l1.next = l2; l2.next = l3; l3.next = l4; // l4.next = l2; LinkedListCycleII l = new LinkedListCycleII(); l.detectCycle(l1); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/143/":{"url":"codes/143/","title":"143. Reorder List","keywords":"","body":"143. Reorder List You are given the head of a singly linked-list. The list can be represented as: L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln Reorder the list to be on the following form: L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦ You may not modify the values in the list's nodes. Only nodes themselves may be changed. Example 1: Input: head = [1,2,3,4] Output: [1,4,2,3] Example 2: Input: head = [1,2,3,4,5] Output: [1,5,2,4,3] Constraints: The number of nodes in the list is in the range [1, 5 * 104]. 1 Solution ä½¿ç”¨stackï¼Œå…ˆæŠŠæ‰€æœ‰nodeéƒ½æ”¶é›†èµ·æ¥ï¼Œç„¶åå¼€å§‹popã€‚è€ƒè™‘ä¸€ä¸‹è¾¹ç•Œæƒ…å†µå°±è¡Œï¼Œä¸éš¾ã€‚ class Solution { public: void reorderList(ListNode* head) { if (head->next == nullptr) return; auto stack = vector(); ListNode* tmp = head; while (tmp != nullptr) { stack.push_back(tmp); tmp = tmp->next; } int lens = stack.size(); tmp = head; while (!stack.empty()) { auto ele = stack.back(); stack.pop_back(); auto n = tmp -> next; tmp -> next = ele; ele -> next = n; tmp = n; if (stack.size() == int(lens / 2)) break; } tmp -> next -> next = nullptr; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/144/":{"url":"codes/144/","title":"144. Binary Tree Preorder Traversal","keywords":"","body":"144. Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? å°±æ˜¯ä¸€ä¸ªå‰åºçš„éå†ï¼šæ ¹å·¦å³ import java.util.LinkedList; import java.util.List; public class BinaryTreePreorderTraversal { public List preorderTraversal(TreeNode root) { List res = new LinkedList<>(); traversal(root, res); return res; } public void traversal(TreeNode root, List res) { if (root == null) return; res.add(root.val); traversal(root.left, res); traversal(root.right, res); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/146/":{"url":"codes/146/","title":"146. LRU Cache","keywords":"","body":"146. LRU Cache Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity. Example 1: Input [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4 Constraints: 1 0 0 At most 2 * 105 calls will be made to get and put. Solution å·¥ä½œé€»è¾‘ ç¼“å­˜åˆå§‹åŒ–ï¼šè®¾å®šä¸€ä¸ªå›ºå®šå¤§å°çš„ç¼“å­˜ç©ºé—´ã€‚ è®¿é—®æ•°æ®ï¼š å¦‚æœæ•°æ®åœ¨ç¼“å­˜ä¸­ï¼ˆå‘½ä¸­ï¼‰ï¼Œå°†å…¶æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨çš„ã€‚ å¦‚æœæ•°æ®ä¸åœ¨ç¼“å­˜ä¸­ï¼ˆ æœªå‘½ä¸­ ï¼‰ï¼Œåˆ™éœ€è¦å°†æ•°æ®åŠ è½½åˆ°ç¼“å­˜ã€‚ å¦‚æœç¼“å­˜æœªæ»¡ï¼Œç›´æ¥å°†æ•°æ®åŠ å…¥ã€‚ å¦‚æœç¼“å­˜å·²æ»¡ï¼Œæ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„é¡¹ï¼Œç„¶åå°†æ–°æ•°æ®åŠ å…¥ã€‚ å…³é”®æ“ä½œï¼š æ›´æ–°æœ€è¿‘ä½¿ç”¨çŠ¶æ€ï¼šæ¯æ¬¡è®¿é—®æŸä¸ªæ•°æ®æ—¶ï¼Œéœ€è¦å°†å…¶æ›´æ–°ä¸ºæœ€è¿‘ä½¿ç”¨çš„ã€‚ æ·˜æ±°æœºåˆ¶ï¼šå½“ç¼“å­˜å·²æ»¡ä¸”æ–°æ•°æ®éœ€è¦åŠ å…¥æ—¶ï¼Œç§»é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®ã€‚ é€»è¾‘å¾ˆç®€å•ï¼Œå°±æ˜¯åŒå‘é“¾è¡¨æ¯”è¾ƒéº»çƒ¦ã€‚GPTä»£å†™ä¸€éƒ¨åˆ† using namespace std; struct Node { int key; int val; Node* next; Node* prev; Node(int k, int v) : key(k), val(v), next(nullptr), prev(nullptr) {} }; class LRUCache { private: Node* head; Node* tail; unordered_map maps; int capacity; int size; void moveToHead(Node* node) { removeNode(node); addToHead(node); } void removeNode(Node* node) { node->prev->next = node->next; node->next->prev = node->prev; } void addToHead(Node* node) { node->next = head->next; node->prev = head; head->next->prev = node; head->next = node; } Node* removeTail() { Node* node = tail->prev; removeNode(node); return node; } public: LRUCache(int capacity) { this->capacity = capacity; this->size = 0; head = new Node(0, 0); tail = new Node(0, 0); head->next = tail; tail->prev = head; } int get(int key) { if (maps.find(key) == maps.end()) { return -1; } Node* node = maps[key]; moveToHead(node); return node->val; } void put(int key, int value) { if (maps.find(key) != maps.end()) { Node* node = maps[key]; node->val = value; moveToHead(node); } else { Node* newNode = new Node(key, value); maps[key] = newNode; addToHead(newNode); size++; if (size > capacity) { Node* tailNode = removeTail(); maps.erase(tailNode->key); delete tailNode; size--; } } } ~LRUCache() { Node* current = head; while (current != nullptr) { Node* temp = current; current = current->next; delete temp; } } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/155/":{"url":"codes/155/","title":"155. Min Stack","keywords":"","body":"Min Stack Min Stack(https://leetcode.com/problems/min-stack/) Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example 1: Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 è¿™ä¸ªåªéœ€è¦çŸ¥é“stackæ˜¯å…ˆè¿›åå‡ºçš„åŸåˆ™å°±è¡Œã€‚ import java.util.Collections; import java.util.LinkedList; import java.util.List; public class MinStack { /** initialize your data structure here. */ private List list; private int lens; public MinStack() { this.list = new LinkedList<>(); this.lens = 0; } public void push(int x) { this.list.add(x); this.lens ++; } public void pop() { if (this.list.size() > 0) { this.lens --; this.list.remove(this.lens); } } public int top() { if (this.list.size() > 0) { return this.list.get(this.lens - 1); } return -1; } public int getMin() { return Collections.min(this.list); } public static void main(String[] args) { MinStack m = new MinStack(); m.push(-2); m.push(0); m.push(-3); System.out.println(m.getMin()); m.pop(); System.out.println(m.top()); // return 0 System.out.println(m.getMin()); // return -2 } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/160/":{"url":"codes/160/","title":"160. Intersection of Two Linked Lists","keywords":"","body":"Intersection of Two Linked Lists Intersection of Two Linked Lists ä¹Ÿç®—æ˜¯æˆ‘ç¬¬ä¸€æ¬¡é¢è¯•çš„ç¬¬ä¸€é“é¢˜ã€‚å½“æ—¶æƒ³çš„æ˜¯æš´åŠ›è§£å†³ï¼Œdoubleå¾ªç¯å“ˆå“ˆå“ˆã€‚è¿™æ¬¡å†™çš„æ—¶å€™æƒ³åˆ°äº†ä¸€ä¸ªæ–°çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨HashMapæ¥è§£å†³ï¼Œæœ€åçš„æƒ…å†µæ˜¯$O(n+m)$ï¼Œä¸è¿‡ä¹Ÿæ¯”$O(n^2)$å¥½ã€‚å…ˆæŠŠä¸€ä¸ªLinkListå…¨éƒ¨æ”¾åˆ°HashMapé‡Œé¢ï¼Œç„¶åå¾ªç¯ç¬¬äºŒä¸ªé“¾è¡¨ï¼Œçœ‹æ˜¯ä¸æ˜¯æœ‰ä¸€æ ·çš„nodeï¼Œå¦‚æœæœ‰å°±ç›´æ¥returnå½“å‰çš„nodeï¼Œå¦‚æœç›´åˆ°å¾ªç¯ç»“æŸè¿˜æ²¡æœ‰å°±return null public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode head = null; ListNode curr = headA; Map map = new HashMap<>(); while (curr != null) { map.put(curr, curr.val); curr = curr.next; } curr = headB; while (curr != null) { if (map.containsKey(curr)) { head = curr; break; } curr = curr.next; } return head; } åœ¨é¢è¯•çš„æ—¶å€™é¢è¯•å®˜ä¹Ÿç»™æˆ‘è¯´äº†å¦ä¸€ç§è§£æ³•ï¼Œå°±æ˜¯å‡è®¾å·²çŸ¥ä¸¤æ¡é“¾è¡¨çš„é•¿åº¦ï¼Œç„¶åå…ˆæŠŠä¸¤æ¡é“¾è¡¨æˆªå–åˆ°ä¸€æ ·çš„é•¿åº¦ï¼Œç„¶åä¸€ä¸ªå¾ªç¯å°±èƒ½æ‰¾åˆ°ç›¸å¯¹åº”çš„ç»“æœã€‚è¿™ä¸ªæˆ‘è§‰å¾—æ—¶é—´å¤æ‚åº¦æ¯”æˆ‘çš„è¦é«˜ï¼Œå°±æ²¡å†™ã€‚ powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/162/":{"url":"codes/162/","title":"162. Find Peak Element","keywords":"","body":"162. Find Peak Element A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] â‰  nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -âˆ. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Follow up: Your solution should be in logarithmic complexity. å¯ä»¥é‡‡ç”¨ä¸€ä¸ªäºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºå·²çŸ¥peak numberæ˜¯ nums[i] > nums[i+1]ä¹Ÿå°±æ˜¯è¯´å¦‚æœåœ¨arrayé‡Œé¢å‡ºç°ä¸€ä¸ªé™åºå°±ä»£è¡¨ç€æ˜¯peak numberã€‚è¿™æ ·çš„è¯å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œå¦‚æœnums[mid] > nums[mid+1]å°±ä»£è¡¨è¯¥æ•°å­—å°±æ˜¯peak numberï¼Œä½†æ˜¯ä¹‹å‰çš„å¯ä»¥è¿˜æœ‰ç›¸å¯¹åº”çš„peak numberï¼Œæ‰€ä»¥å°±æ˜¯search(nums, left, mid)ã€‚ ps: ä¹Ÿæœ‰ä¸€ç§O(n)çš„æ–¹æ³•æ¥æŸ¥æ‰¾ã€‚ public class FindPeakElement { // public int findPeakElement(int[] nums) { // for (int i = 0; i nums[i+1]) return i; // } // // return nums.length-1; // } public int findPeakElement(int[] nums) { return search(nums, 0, nums.length - 1); } public int search(int[] nums, int left, int right) { if (left == right) return left; int mid = (left + right) / 2; if (nums[mid] > nums[mid+1]) return search(nums, left, mid); return search(nums, mid+1, right); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/169/":{"url":"codes/169/","title":"169. Majority Element","keywords":"","body":"Majority Element Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2 æ–¹æ³•1ï¼šhashmap çœ‹åˆ°è¿™ä¸€ç±»çš„é¢˜ï¼Œæœ€å…ˆæƒ³åˆ°çš„å°±æ˜¯ä½¿ç”¨HashMapæ¥è§£å†³è¿™ä¸ªè®¡æ•°çš„é—®é¢˜ï¼Œå½“è®¡æ•°çš„ç»“æœ> nums.leng/2çš„æ—¶å€™å¯ä»¥ç›´æ¥returnå°±å¥½äº†ï¼Œå‡†æ²¡é”™ public int majorityElement(int[] nums) { if (nums.length map = new HashMap<>(); for (int i = 0; i = nums.length/2) return nums[i]; map.put(nums[i], map.get(nums[i]) + 1); } else { map.put(nums[i], 1); } } return -1; } æ–¹æ³•2ï¼šæ’åº ç„¶åçœ‹äº†ä¸€ä¸‹å®˜æ–¹çš„è§£æ³•ï¼Œå°±æ˜¯å…ˆsortä¸€ä¸‹ï¼Œå¦‚æœè¯¥æ•°å­—çš„ä¸ªæ•°å¤§äºæ€»arrayé•¿åº¦çš„ä¸€èˆ¬ä¹Ÿå°±æ„å‘³ç€sortå®Œä¹‹åå–ä¸­é—´é‚£ä¸ªæ•°å­—å‡†æ²¡é”™ã€‚ã€‚ã€‚é‚£ä¹ˆç®€å•çš„æ–¹æ³•å’‹å°±æ²¡æƒ³åˆ°å‘¢o(â•¥ï¹â•¥)o public int majorityElement(int[] nums) { if (nums.length == 0) return -1; Arrays.sort(nums); return nums[nums.length/2]; } æ–¹æ³•3ï¼šæ‘©å°”æŠ•ç¥¨æ³•ï¼ˆæœ€ä½³æ–¹æ³•ï¼‰ æ€è·¯ï¼š æ‘©å°”æŠ•ç¥¨æ³•é€šè¿‡ç»´æŠ¤ä¸€ä¸ªâ€œå€™é€‰äººâ€å’Œâ€œè®¡æ•°å™¨â€æ¥ç¡®å®šå¤šæ•°å…ƒç´ ï¼š éå†æ•°ç»„æ—¶ï¼Œå¦‚æœå½“å‰è®¡æ•°å™¨ä¸º0ï¼Œåˆ™å°†å½“å‰å…ƒç´ è®¾ä¸ºå€™é€‰äººï¼Œå¹¶å°†è®¡æ•°å™¨è®¾ç½®ä¸º1ã€‚ å¦‚æœå½“å‰å…ƒç´ ç­‰äºå€™é€‰äººï¼Œè®¡æ•°å™¨åŠ 1ï¼›å¦åˆ™ï¼Œè®¡æ•°å™¨å‡1ã€‚ æœ€åå‰©ä¸‹çš„å€™é€‰äººå³ä¸ºå¤šæ•°å…ƒç´ ã€‚ å¤æ‚åº¦ï¼š æ—¶é—´å¤æ‚åº¦ï¼šO(n)O(n)O(n)ï¼Œåªéœ€ä¸€æ¬¡éå†ã€‚ ç©ºé—´å¤æ‚åº¦ï¼šO(1)O(1)O(1)ã€‚ Pythonå®ç°ï¼š class Solution { public: int majorityElement(vector& nums) { int cand = nums[0], cnt = 0; for (int num : nums) { if (cnt == 0) cand = num; cnt += (cand == num) ? 1 : -1; } return cand; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/189/":{"url":"codes/189/","title":"189. Rotate Array","keywords":"","body":"Rotate Array Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Follow up: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] å°±æ˜¯æ ¹æ®kçš„ä¸ªæ•°ï¼Œæ¯ä¸ªelementå‘åç§»åŠ¨kä½ï¼Œè¶…å‡ºarrayçš„è¯åœ¨arrayçš„å¼€å¤´ç»§ç»­ã€‚ åˆšå¼€å§‹è¯•äº†å¥½å‡ ç§æ–¹æ³•ï¼Œä½†æ˜¯éƒ½ä¸æ˜¯ç‰¹åˆ«ç†æƒ³ï¼Œçœ‹äº†ä¸€ä¸‹discussionï¼Œå­¦åˆ°äº†ã€‚è¿™ä¸ªç¿»è½¬é“¾è¡¨å®é™…æ˜¯æœ‰è§„å¾‹çš„ï¼Œå…ˆæŠŠæ•´ä¸ªarray reverseä¸€ä¸‹ï¼Œç„¶åå†æŠŠ0-kreverseï¼Œç„¶åæŠŠk-endreverseä¸€ä¸‹å°±å¯ä»¥å¾—åˆ°æœ€ç»ˆçš„ç»“æœã€‚ã€‚ã€‚å¾ˆç¥å¥‡çš„è§„å¾‹ã€‚ã€‚ã€‚ import java.util.Arrays; /** * è¿™ä¸ªæƒ³æ³•æ˜¯åœ¨leetcodeé‚£è¾¹çœ‹åˆ°çš„ï¼Œå…¶å·¥ä½œåŸç†å°±æ˜¯å…ˆreverseä¸€ä¸‹ * ç„¶ååœ¨å¯¹å‰kä¸ªè¿›è¡Œreverseï¼Œç„¶åå¯¹k-lenå†reverse * è¿™æ ·å°±èƒ½å¾—åˆ°ç»“æœäº† */ public class RotateArray { public void rotate(int[] nums, int k) { if (nums.length powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/202/":{"url":"codes/202/","title":"202. Happy Number","keywords":"","body":"Happy Number Happy Number Write an algorithm to determine if a number n is \"happy\". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Return True if n is a happy number, and False if not. Example: Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 è¾“å…¥ä¸€ä¸ªæ•°å­—ï¼Œç„¶åæŠŠæ•°å­—åˆ†å¼€ï¼Œç„¶åå¹³æ–¹ç›¸åŠ ã€‚æ¯”å¦‚19 = 1^2 + 9^2å¾—å‡ºçš„æ•°å­—å†ç»§ç»­è¿›è¡Œä¸€æ ·çš„æ“ä½œï¼Œä¸€ç›´ç®€åŒ–åˆ°è¯¥æ•°å­—åˆ°ä¸ªä½æ•°ï¼Œå¦‚æœè¯¥æ•°å­—ç­‰äº1æˆ–è€…7çš„æ—¶å€™ï¼Œå°±å¯ä»¥return trueï¼Œå¦åˆ™çš„è¯å°±return false import java.util.LinkedList; import java.util.List; public class HappyNumber { public boolean isHappy(int n) { if (n == 1) return true; int sum = n; List list = new LinkedList<>(); while (true) { list = split(sum); sum = 0; for (Integer i : list) { sum += Math.pow(i, 2); } if (sum == 1 || sum == 7) { return true; } if (sum split(int n) { List list = new LinkedList<>(); while (n != 0) { list.add(n % 10); n = n / 10; } return list; } public static void main(String[] args) { HappyNumber hp = new HappyNumber(); System.out.println(hp.isHappy(19)); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/205/":{"url":"codes/205/","title":"205. Isomorphic Strings","keywords":"","body":"205. Isomorphic Strings Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Example 1: Input: s = \"egg\", t = \"add\" Output: true Explanation: The strings s and t can be made identical by: Mapping 'e' to 'a'. Mapping 'g' to 'd'. Example 2: Input: s = \"foo\", t = \"bar\" Output: false Explanation: The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'. Example 3: Input: s = \"paper\", t = \"title\" Output: true Constraints: 1 t.length == s.length s and t consist of any valid ascii character. Solution æ²¡å•¥å¤ªå¤šæŠ€å·§ï¼Œç›´æ¥hashmapã€‚ class Solution { public: bool isIsomorphic(string s, string t) { if (s.size() != t.size()) return false; auto maps = vector(128, -1); auto maped = vector(128, 0); for (int i = 0; i (s[i]); int t_ = static_cast(t[i]); if (maps[s_] == -1) { if (maped[t_]) return false; maps[s_] = t_; maped[t_] = 1; } else { if (maps[s_] != t_) return false; } } return true; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/206/":{"url":"codes/206/","title":"206. Reverse Linked List","keywords":"","body":"Reverse Linked List Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL ç¿»è½¬é“¾è¡¨å¯ä»¥å¾ªç¯å®ç°ï¼Œä¹Ÿå¯ä»¥ç”¨é€’å½’å®ç°ã€‚ public ListNode reverseList(ListNode head) { if (head == null) return null; ListNode curr = head; ListNode next = head.next; ListNode temp = null; curr.next = null; while (next != null) { temp = next.next; next.next = curr; curr = next; next = temp; } return curr; } ç„¶åé€’å½’çš„è¯å°±åˆšå¼€å§‹çœ‹å¯èƒ½ä¸æ˜¯ç‰¹åˆ«å¥½ç†è§£çš„ã€‚æ€»æ„Ÿè§‰é‡åˆ°é€’å½’å°±æœ‰ç‚¹æ‡µé€¼çš„æ„Ÿè§‰ã€‚ã€‚ã€‚ public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/207/":{"url":"codes/207/","title":"207. Course Schedule","keywords":"","body":"207. Course Schedule There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false. Example 1: Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2: Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Solution å¯ä»¥é€šè¿‡bfsæ¥åˆ¤æ–­æ˜¯å¦æœ‰ç¯å°±è¡Œäº†ï¼Œä½†bfsåˆ¤æ–­çš„è¯å°±æ˜¯toposortäº†ã€‚ class Solution { public: bool canFinish(int numCourses, vector>& prerequisites) { if (prerequisites.empty()) return true; int marked = 0; auto in_degree = vector(numCourses, 0); auto dg = vector>(numCourses); for (auto const& pre : prerequisites) { dg[pre[1]].push_back(pre[0]); in_degree[pre[0]] += 1; } queue q; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/209/":{"url":"codes/209/","title":"209. Minimum Size Subarray Sum","keywords":"","body":"209. Minimum Size Subarray Sum Minimum Size Subarray Sum: Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example: Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Brute Force The basic approach is to use two loops to solve that. The time complexity of this approach is $O(N^2)$. It will cause time limit exceeded. class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -> int: length = 9999 for i in range(0, len(nums)): res = nums[i] if res >= target: length = 1 continue for j in range(i + 1, len(nums)): res += nums[j] if res >= target: length = min(length, j - i + 1) break return length if length != 9999 else 0 Advance Approach To solve this issue, we can use Sliding Window to solve this issue. This method is similar to the double pointer. The index the left index of this array. When the sum between i and index is greater or equal to the target, then advance i and index to find other positions that sum is greater or equal to the target. The basic idea of sliding windows is shown in the Figure. class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -> int: index = 0 res = 0 min_len = 99999999 for i in range(0, len(nums)): res += nums[i] while res >= target: length = i - index + 1 min_len = min(length, min_len) res -= nums[index] index += 1 return min_len if min_len != 99999999 else 0 powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/215/":{"url":"codes/215/","title":"215. Kth Largest Element in an Array","keywords":"","body":"215. Kth Largest Element in an Array Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting? Example 1: Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Example 2: Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints: 1 -104 Solution æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨priority queueæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯æ•ˆç‡ä¸æ˜¯å¾ˆé«˜ã€‚å¯ä»¥è€ƒè™‘ä½¿ç”¨QuickSelectç®—æ³•ã€‚ç­‰çœ‹å®Œæ¥æ›´æ–°è¿™ä¸ªç®—æ³•ã€‚ class Solution { public: int findKthLargest(vector& nums, int k) { auto cmp = [](const int& a, const int& b) { return a , decltype(cmp)> pq(cmp); for (int const& num : nums) pq.push(num); int val = 0; while (!pq.empty()) { k --; if(k == 0) { val = pq.top(); break; } pq.pop(); } return val; } }; S2 å¦å¤–ä¸€ç§æ–¹æ³•å°±æ˜¯é€šè¿‡dfsæ¥å®ç°çš„ï¼Œå…¶å®ä¹Ÿä¸éš¾ï¼Œå°±åªéœ€è¦ä»è¾¹ç¼˜çš„ç‚¹å‡ºå‘ï¼Œç„¶ååˆ¤æ–­æ˜¯ä¸æ˜¯Oå¦‚æœæ˜¯åˆ™è¿›è¡Œdfséå†æ‰¾åˆ°æ‰€æœ‰ä¸å‘ç”Ÿæ”¹å˜çš„Oã€‚ class Solution { public: void dfs(int i, int j, int rows, int cols, vector>& board, vector>& maps) { stack> stack; stack.emplace(i, j); while (!stack.empty()) { auto it = stack.top(); stack.pop(); int x = it.first, y = it.second; maps[x][y] = true; if (x - 1 >= 0 && board[x - 1][y] == 'O' && !maps[x-1][y]) stack.emplace(x-1, y); if (x + 1 = 0 && board[x][y - 1] == 'O' && !maps[x][y-1]) stack.emplace(x, y-1); if (y + 1 >& board) { auto maps = vector>(board.size()); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/216/":{"url":"codes/216/","title":"216. Combination Sum III","keywords":"","body":"216. Combination Sum III Combination Sum III: Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. For example: Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. This question is pretty similar with the previous one, just add one more constrain (sum = n). class Solution: def combinationSum3(self, k: int, n: int) -> List[List[int]]: def combine(k, n, index, path, result): if len(path) == k: if sum(path) == n: result.append([i for i in path]) return path for i in range(index, 10): path.append(i) combine(k, n, i + 1, path, result) path.pop() return result return combine(k, n, 1, [], []) powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/217/":{"url":"codes/217/","title":"217. Contains Duplicate","keywords":"","body":"Contains Duplicate Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true è¿™ä¸ªé¢˜ç”¨ç®€å•çš„HashMapåšå°±è¡Œï¼Œæˆ–è€…ç”¨hashsetï¼Œæˆ‘è¿™ç”¨çš„æ˜¯hashsetã€‚ import java.util.Arrays; import java.util.HashSet; public class ContainsDuplicate { public boolean containsDuplicate(int[] nums) { HashSet hashSet = new HashSet(); for (int num : nums) { hashSet.add(num); } return nums.length != hashSet.size(); } public static void main(String[] args) { int[] nums = new int[]{1,2,3, 1}; ContainsDuplicate cd = new ContainsDuplicate(); System.out.println(cd.containsDuplicate(nums)); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/219/":{"url":"codes/219/","title":"219. Contains Duplicate II","keywords":"","body":"219. Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: Input: nums = [1,2,3,1], k = 3 Output: true Example 2: Input: nums = [1,0,1,1], k = 1 Output: true Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false æœ¬æ¥æƒ³çš„æ˜¯ç›´æ¥ç”¨forå¾ªç¯ï¼Œæ ¹æ®å½“å‰æ•°å­—ç„¶åå‘åèµ°kä½ï¼Œçœ‹kä½ä»¥å†…æœ‰æ²¡æœ‰å’Œnums[i]ç›¸åŒçš„æ•°å­—ï¼Œä½†æ˜¯è²Œä¼¼bugæœ‰ç‚¹å¤šï¼Œæ”¾å¼ƒäº†ã€‚ã€‚æ”¹ç”¨HashMapäº†ï¼Œkeyå­˜nums[i]ï¼Œvalueå­˜ç›¸å¯¹åº”çš„indexã€‚å¦‚æœHashMapå·²ç»æœ‰è¯¥keyåˆ™å¯ä»¥è®¡ç®—HashMapé‡Œé¢å­˜çš„indexå’Œå½“å‰içš„å·®å€¼ï¼Œå¦‚æœå°äºç­‰äºKå°±å¯ä»¥ç›´æ¥è¿”å›äº†ã€‚ import java.util.HashMap; import java.util.Map; public class ContainsDuplicateII { // æ”¾å¼ƒäº†æˆ‘ä½¿ç”¨hashmapæ¥å†™å¥½å§ã€‚ã€‚ã€‚ public boolean containsNearbyDuplicate(int[] nums, int k) { Map map = new HashMap<>(); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/224/":{"url":"codes/224/","title":"224. Basic Calculator","keywords":"","body":"224. Basic Calculator Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Input: s = \"1 + 1\" Output: 2 Example 2: Input: s = \" 2-1 + 2 \" Output: 3 Example 3: Input: s = \"(1+(4+5+2)-3)+(6+8)\" Output: 23 Constraints: 1 s consists of digits, '+', '-', '(', ')', and ' '. s represents a valid expression. '+' is not used as a unary operation (i.e., \"+1\" and \"+(2 + 3)\" is invalid). '-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid). There will be no two consecutive operators in the input. Every number and running calculation will fit in a signed 32-bit integer. Solution ç”¨stackæ¥è§£å†³ï¼Œæ ¸å¿ƒåœ¨äºæ¯æ¬¡è¿ç®—æ‹¬å·é‡Œé¢çš„æ•°æ®ï¼Œåœ¨è¿ç®—æ‹¬å·é‡Œå†…å®¹çš„æ—¶å€™å…ˆæŠŠä¹‹å‰çš„æ•°æ®éƒ½æ”¾è¿›stacké‡Œé¢ï¼Œè®¡ç®—å®Œæ‹¬å·é‡Œçš„å†…å®¹ä¹‹åæŠŠä¹‹å‰çš„è¿ç®—ç»“æœæ‹¿å‡ºæ¥è¿›è¡Œè®¡ç®—ã€‚æœ‰ç‚¹åƒé€’å½’çš„æ€æƒ³ã€‚æƒ³åˆ°ç”¨stackäº†ï¼Œä½†æ˜¯ç®—æ³•æ€è·¯æ²¡é‚£ä¹ˆç»†è‡´ï¼Œéœ€è¦å¤šå†™ class Solution { public: int calculate(string s) { auto stack = std::stack(); int op = 1; int val = 0; int num = 0; for (char const& x : s) { if (x == ' ') continue; if (isdigit(x)) { num = num * 10 + (x - '0'); } else if (x == '+') { val += op * num; op = 1; num = 0; } else if (x == '-') { val += op * num; op = -1; num = 0; } else if (x == '(') { stack.push(val); stack.push(op); val = 0; op = 1; num = 0; } else if (x == ')') { val += op * num; val *= stack.top(); stack.pop(); val += stack.top(); stack.pop(); num = 0; } } val += op * num; return val; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/227/":{"url":"codes/227/","title":"227. Basic Calculator II","keywords":"","body":"227. Basic Calculator II Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Input: s = \"3+2*2\" Output: 7 Example 2: Input: s = \" 3/2 \" Output: 1 Example 3: Input: s = \" 3+5 / 2 \" Output: 5 Solution åšä¸€ä¸ªä¼˜å…ˆçº§è¿ç®—å°±è¡Œã€‚å…ˆç®—*å’Œ/ã€‚ Baseline class Solution { public: int calculate(string s) { auto vals = vector(); string tmp = \"\"; char last = ' '; for (char const& x : s) { if (x == ' ') continue; if (isdigit(x)) { tmp += x; } else { if (last == '-') { vals.push_back( 0 - stoi(tmp)); } else { vals.push_back(stoi(tmp)); } if (last == '*' || last == '/') { int idx = vals.size() - 1; int val = last == '*' ? vals[idx] * vals[idx - 1] : vals[idx-1] / vals[idx]; vals.pop_back(); vals.pop_back(); vals.push_back(val); } tmp = \"\"; last = x; } } if (last == '-') { vals.push_back( 0 - stoi(tmp)); } else { vals.push_back(stoi(tmp)); } if (last == '*' || last == '/') { int idx = vals.size() - 1; int val = last == '*' ? vals[idx] * vals[idx - 1] : vals[idx-1] / vals[idx]; vals.pop_back(); vals.pop_back(); vals.push_back(val); } int res = 0; for (int const & val : vals) res += val; return res; } }; Adv class Solution { public: int calculate(string s) { vector vals; int num = 0; char lastOp = '+'; for (size_t i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/229/":{"url":"codes/229/","title":"229. Majority Element II","keywords":"","body":"229. Majority Element II Given an integer array of size n, find all elements that appear more than âŒŠ n/3 âŒ‹ times. Example 1: Input: nums = [3,2,3] Output: [3] Example 2: Input: nums = [1] Output: [1] Example 3: Input: nums = [1,2] Output: [1,2] Constraints: 1 -109 Follow up: Could you solve the problem in linear time and in O(1) space? Solution S1 ä½¿ç”¨hashmapèƒ½è½»æ¾è§£å†³ï¼Œæˆ–è€…sortéƒ½è¡Œï¼Œä½†æ˜¯ç©ºé—´å¤æ‚åº¦å’Œæ—¶é—´å¤æ‚åº¦ä¸è¾¾æ ‡ã€‚ class Solution { public: vector majorityElement(vector& nums) { if (nums.size() (); auto res = vector(); for (int const& num : nums) { maps[num] += 1; } auto marked = unordered_map(); for (int const& num : nums) { if (marked[num]) continue; marked[num] = true; if (maps[num] > int(nums.size() / 3)) res.push_back(num); } return res; } }; S2 å‰é¢æœ‰ä¸€ä¸ªç±»ä¼¼çš„é¢˜ï¼Œå¯ä»¥ä½¿ç”¨Boyer-Moore æŠ•ç¥¨ç®—æ³• é—®é¢˜ç†è§£ï¼š æ‰¾åˆ°æ‰€æœ‰å‡ºç°æ¬¡æ•°è¶…è¿‡ âŒŠn / 3âŒ‹ çš„å…ƒç´ ã€‚ æ³¨æ„æœ€å¤šå¯èƒ½æœ‰ ä¸¤ä¸ªå€™é€‰å…ƒç´  æ»¡è¶³æ¡ä»¶ã€‚ æ ¸å¿ƒæ€æƒ³ï¼š æ‰©å±• Boyer-Moore æŠ•ç¥¨ç®—æ³•ï¼Œå¯ä»¥ç”¨äºå¯»æ‰¾ ä¸¤ä¸ªå€™é€‰çš„ä¼—æ•°ã€‚ é€šè¿‡ä¸¤è½®éå†ï¼š ç¬¬ä¸€è½®ï¼š æ‰¾åˆ°æœ€å¤šä¸¤ä¸ªå€™é€‰çš„ä¼—æ•°ã€‚ ç¬¬äºŒè½®ï¼š éªŒè¯å€™é€‰çš„ä¼—æ•°æ˜¯å¦çœŸçš„æ»¡è¶³å‡ºç°æ¬¡æ•°è¶…è¿‡ âŒŠn / 3âŒ‹ã€‚ ç®—æ³•æ­¥éª¤ï¼š ç¬¬ä¸€è½®ï¼šå¯»æ‰¾å€™é€‰è€… ç”¨ä¸¤ä¸ªå˜é‡ candidate1 å’Œ candidate2 è®°å½•å€™é€‰ä¼—æ•°ã€‚ ç”¨ä¸¤ä¸ªè®¡æ•°å™¨ count1 å’Œ count2 è®°å½•å„è‡ªçš„è®¡æ•°ã€‚ éå†æ•°ç»„ï¼š å¦‚æœå½“å‰å…ƒç´ ç­‰äº candidate1ï¼Œå¢åŠ  count1ã€‚ å¦‚æœå½“å‰å…ƒç´ ç­‰äº candidate2ï¼Œå¢åŠ  count2ã€‚ å¦‚æœ count1 ä¸º 0ï¼Œå°†å½“å‰å…ƒç´ ä½œä¸º candidate1ï¼Œå¹¶å°† count1 è®¾ç½®ä¸º 1ã€‚ å¦‚æœ count2 ä¸º 0ï¼Œå°†å½“å‰å…ƒç´ ä½œä¸º candidate2ï¼Œå¹¶å°† count2 è®¾ç½®ä¸º 1ã€‚ å¦åˆ™ï¼ŒåŒæ—¶å‡å°‘ count1 å’Œ count2ã€‚ ç¬¬äºŒè½®ï¼šéªŒè¯å€™é€‰è€… ç”¨ä¸€æ¬¡éå†ç»Ÿè®¡ candidate1 å’Œ candidate2 çš„å®é™…å‡ºç°æ¬¡æ•°ã€‚ æ£€æŸ¥å®ƒä»¬æ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼ˆè¶…è¿‡ âŒŠn / 3âŒ‹ æ¬¡ï¼‰ã€‚ class Solution { public: vector majorityElement(vector& nums) { if (nums.size() (); for (int const& num : nums) { if (num == cand1) cc1 ++; if (num == cand2) cc2 ++; } if (cc1 > int(nums.size() / 3)) res.push_back(cand1); if (cc2 > int (nums.size() / 3)) res.push_back(cand2); return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/232/":{"url":"codes/232/","title":"232. Implement Queue using Stacks","keywords":"","body":"232. Implement Queue using Stacks Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations. Example 1: Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false Constraints: 1 At most 100 calls will be made to push, pop, peek, and empty. All the calls to pop and peek are valid. Solution Queueçš„åŸç†æ˜¯å…ˆè¿›å…ˆå‡ºï¼ŒStackçš„åŸç†æ˜¯å…ˆè¿›åå‡ºã€‚æ‰€ä»¥queue.top()å°±æ˜¯stackæœ€åº•å±‚çš„å…ƒç´ ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªstackæ¥å®Œæˆè¯¥ä»»åŠ¡ã€‚ class MyQueue { private: stack s1, s2; public: MyQueue() { s1 = stack(); s2 = stack(); } void push(int x) { s1.push(x); } int pop() { while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } int val = s2.top(); s2.pop(); while (!s2.empty()) { s1.push(s2.top()); s2.pop(); } return val; } int peek() { while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } int val = s2.top(); while (!s2.empty()) { s1.push(s2.top()); s2.pop(); } return val; } bool empty() { return s1.empty() && s2.empty(); } }; powered by GitbookFile Modify: 2024-11-27 17:06:18 "},"codes/234/":{"url":"codes/234/","title":"234. Palindrome Linked List","keywords":"","body":"Palindrome Linked List Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space? æ€è·¯ï¼š æœ¬æ¥æƒ³çš„æ˜¯ç”¨é€’å½’çš„æ–¹æ³•ç®—ä¸€ä¸‹å’Œï¼Œå¦‚æœæ˜¯å›æ–‡çš„è¯ç»“æœåº”è¯¥æ˜¯ä¸€æ ·çš„ï¼Œæƒ³æ³•å¾ˆç¾å¥½ï¼Œç°å®å¾ˆæ®‹é…·ã€‚ã€‚ã€‚LeetCodeå®˜æ–¹åº”è¯¥ä¹Ÿè€ƒè™‘åˆ°è¿™ä¸ªé—®é¢˜äº†ï¼Œå¦‚æœç®—sumçš„è¯ä¼šå¯¼è‡´æ•´å‹æº¢å‡ºçš„é—®é¢˜ã€‚ã€‚ã€‚ã€‚ä¸è¿‡ä¹Ÿç®—æ˜¯ä¸€ä¸ªæ€è·¯å§ã€‚o(â•¥ï¹â•¥)o public boolean isPalindrome(ListNode head) { if (head == null) return false; if (head.next == null) return true; long [] nums = new long[]{0, 0}; recur(head,nums); return nums[0] == nums[1]; } public void recur(ListNode curr, long[] nums) { if (curr == null) return ; nums[0] = nums[0]*10 + curr.val; recur(curr.next, nums); nums[1] = nums[1]*10 + curr.val; } æœ€è¿‘é‡åˆ°çš„é¢˜ä¸æ˜¯é€’å½’å°±æ˜¯åŠ¨æ€è§„åˆ’ã€‚ã€‚ã€‚çœ‹æ¥è¿™å—æœ‰ç‚¹è–„å¼±ï¼Œæœ‰æ—¶é—´è¦å¤šç»ƒä¹ ä¸€ä¸‹ã€‚ã€‚çœ‹äº†discussioné‡Œé¢ï¼Œæœ‰ä¸ªå¤§ç¥å†™çš„ä¹Ÿæ˜¯é€’å½’çš„æ–¹æ³•ï¼Œç±»ä¼¼äºå…ˆæŠŠç¬¬ä¸€ä¸ªæŒ‡é’ˆèµ°åˆ°ç»“å°¾ï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆæŒ‡å‘headï¼Œç„¶åå¯¹æ¯”æ˜¯ä¸æ˜¯ä¸€æ ·ã€‚æ„Ÿè§‰å¾ˆç‰›é€¼ã€‚ã€‚ä¸è¿‡é€’å½’è²Œä¼¼èŠ±è´¹æ—¶é—´æœ‰ç‚¹ä¹…ã€‚ boolean flag = true; public boolean isPalindrome(ListNode head) { recur(head, head); return flag; } public ListNode recur(ListNode p1, ListNode p2) { if (p1 == null) return p2; ListNode node = recur(p1.next, p2); if (node.val != p1.val) flag = false; return node.next; } Ps: è¿˜æœ‰ä¸€ç§å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•ã€‚ã€‚å°±æ˜¯èµ°åˆ°ä¸­é—´ï¼Œç„¶åæŠŠä¸¤æ¡é“¾è¡¨åˆ†å¼€å¯¹æ¯”å°±è¡Œäº†ï¼Œä½†æ˜¯æ„Ÿè§‰æœ‰ç‚¹éº»çƒ¦ï¼Œè¿˜æ˜¯ä¸å†™äº†ã€‚ã€‚ã€‚ powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/238/":{"url":"codes/238/","title":"238. Product of Array Except Self","keywords":"","body":"238. Product of Array Except Self Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) Solution è¿™ä¸ªé—®é¢˜ç»™å‡ºçš„æç¤º prefix å’Œ suffix ï¼Œé‚£ä¹ˆæ ¹æ®è¿™ä¸ªæç¤ºæˆ‘ä»¬å¯ä»¥å¾—çŸ¥è¿™ä¸ªé¢˜æ˜¯éœ€è¦å‰åéå†çš„ç®—ã€‚å¹¶ä¸”è¯¥é—®é¢˜è¦æ±‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(n) ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡å–å·¦å³ä¸¤è¾¹éå†çš„æ–¹æ³•ã€‚ æ ¹æ®è¿™ä¸ªé—®é¢˜æœ¬èº«çš„è¦æ±‚ï¼Œç®—å‡ºè¯¥æ•°ç»„æ‰€æœ‰æ•°å­—çš„ä¹˜ç§¯ï¼Œä½†æ˜¯ä¸åŒ…å«å½“å‰æ•°å­—ã€‚é¦–å…ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ prefix ä»å·¦åˆ°å³éå†ä¸€ä¸‹ï¼š nums: 1 2 3 4 pre: 1 1 2 6 æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ä»å·¦åˆ°å³éå†çš„è¯ï¼Œ nums ä¸­æ¯ä¸ªç´¢å¼•å¯¹åº”çš„æ•°æ®æ˜¯å‰é¢å‡ ä¸ªæ•°å­—çš„ä¹˜ç§¯ï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å¯ä»¥å¾—çŸ¥ä»å·¦åˆ°å³çš„ä¹˜ç§¯æ˜¯å¤šå°‘äº†ã€‚ä»å³å¾€å·¦çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦ç”¨å½“å‰æ•°å­—ä¹˜ä»¥ä¸Šä¸€è½®çš„ç»“æœï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¾—åˆ°æœ€åç»“æœäº†ã€‚ prefix è®°å½•çš„æ˜¯ä»å·¦åˆ°å³çš„ä¹˜ç§¯ï¼Œ sufix è®°å½•çš„æ˜¯ä»å³åˆ°å·¦çš„ä¹˜ç§¯ï¼ˆä¸åŒ…å«è‡ªèº«ï¼‰ã€‚ class Solution { public: vector productExceptSelf(vector& nums) { auto ans = vector(nums.size(), 1); int prefix = 1; for (int i = 0; i = 0; i -- ) { ans[i] = suffix * ans[i]; suffix *= nums[i]; } return ans; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/242/":{"url":"codes/242/","title":"242. Valid Anagram","keywords":"","body":"242. Valid Anagram Given two strings s and t, return true if t is an anagram of s, and false otherwise. Input: s = \"anagram\", t = \"nagaram\" Output: true Input: s = \"rat\", t = \"car\" Output: false Brute Force This issue can be solved by using two loop. But the time complexity is $O(N)$. In addition, it also can be done through sort algorithm, to check whether same. But it is too complex. Here we did not code for this approache. Advance Approach We can use hashmap to record that how many times they appeared in the string. Therefore, the time complexity is $O(N)$. class Solution: def isAnagram(self, s: str, t: str) -> bool: if len(s) != len(t): return False data = {} for i in s: if i not in data: data[i] = 1 else: data[i] += 1 for i in t: if i not in data: return False else: if data[i] == 0: return False else: data[i] -= 1 for key, val in data.items(): if data[key] != 0: return False return True powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/268/":{"url":"codes/268/","title":"268. Missing Number","keywords":"","body":"268. Missing Number Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: n == nums.length 1 0 All the numbers of nums are unique. Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity? Solution ç”¨hashmapå°±èƒ½è§£å†³ã€‚ä½†ç©ºé—´å¤æ‚åº¦æ˜¯ O(n) ã€‚å¦‚æœæƒ³è¦åœ¨ O(1) æ˜¯çš„ç©ºé—´å¤æ‚åº¦ä¸­å®Œæˆï¼Œå¯ä»¥é€šè¿‡æ±‚å’Œçš„æ–¹å¼æ¥è§£å†³ã€‚ class Solution { public: int missingNumber(vector& nums) { int r_sum = 0; int a_sum = 0; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/283/":{"url":"codes/283/","title":"283. Move Zeroes","keywords":"","body":"Move Zeroes Move Zeroes Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. ä¸€å¼€å§‹çœ‹åˆ°è¿™ä¸ªæƒ³äº†ä¸€ä¸‹åŒæŒ‡é’ˆï¼Œä¸€ä¸ªä»å¤´å¼€å§‹ä¸€ä¸ªä»å°¾éƒ¨å¼€å§‹ï¼Œè¿™æ ·è™½ç„¶å¯ä»¥æŠŠ0éƒ½æ”¾åˆ°åé¢ï¼Œä½†æ˜¯è¿™æ ·å°±ä¸æ˜¯é¡ºåºæ¥çš„äº†ã€‚ã€‚ã€‚çœ‹äº†ä¸€ä¸‹å¤§ä½¬æ€è·¯ï¼Œä¹Ÿæ˜¯åŒæŒ‡é’ˆï¼ˆæ–¹æ³•æ€è·¯æ²¡é”™å¯¹å§ï¼‰ï¼Œåªä¸è¿‡è¿™ä¸ªåŒæŒ‡é’ˆéƒ½æ˜¯ä»å¤´å¼€å§‹çš„ã€‚å…ˆè®¾ç½®ä¸€ä¸ª0çš„æŒ‡é’ˆzero=-1å› ä¸ºæˆ‘ä»¬ä¸€å¼€å§‹ä¸çŸ¥é“0çš„ä½ç½®åœ¨é‚£ï¼Œç„¶åå¼€å§‹å¾ªç¯ï¼Œå¦‚æœè¯¥æ•°å­—ä¸º0å¯ä»¥å¯¹zeroè¿›è¡Œèµ‹å€¼äº†ï¼ˆzero == -1ï¼‰ï¼Œå½“zero != -1è¯´æ˜ä¹‹å‰å·²ç»æœ‰äº†0çš„æ•°å­—ã€‚ç„¶åå¦‚æœè¯¥æ•°å­—ä¸ç­‰äº0çš„æ—¶å€™è¡¨ç¤ºå¯ä»¥å¯¹ä¹‹å‰çš„zeroçš„indexè¿›è¡Œæ›¿æ¢ï¼Œå‰ææ˜¯zero != -1ï¼Œç„¶ååˆ¤æ–­zeroå’Œiçš„ä½ç½®ï¼Œå¦‚æœiæ˜¯zeroçš„nextè¯´æ˜æ˜¯åªæœ‰ä¸€ä¸ªzeroï¼Œä¸ç„¶çš„è¯å°±ä»£è¡¨zeroåé¢è¿˜æ˜¯ä¸€ä¸ª0çš„æ•°å­—ï¼Œæ‰€ä»¥è¿™æ—¶å€™zero++å°±è¡Œã€‚ public void moveZeroes(int[] nums) { int zero = -1; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/287/":{"url":"codes/287/","title":"287. Find the Duplicate Number","keywords":"","body":"287. Find the Duplicate Number Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space. Example 1: Input: nums = [1,3,4,2,2] Output: 2 Example 2: Input: nums = [3,1,3,4,2] Output: 3 Example 3: Input: nums = [3,3,3,3,3] Output: 3 Constraints: 1 nums.length == n + 1 1 All the integers in nums appear only once except for precisely one integer which appears two or more times. Follow up: How can we prove that at least one duplicate number must exist in nums? Can you solve the problem in linear runtime complexity? Solution S1. å¯ä»¥ä½¿ç”¨ hashmap çš„æ€è·¯æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè§£å†³æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œä½†æ˜¯ä¸æ»¡è¶³ O(1) spaceçš„è¦æ±‚ã€‚ class Solution { public: int findDuplicate(vector& nums) { auto maps = unordered_map(); for (int const& num : nums) { maps[num] += 1; if (maps[num] > 1) return num; } return -1; } }; S2. ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆçš„æ–¹æ³•æ¥è§£å†³ï¼Œå› ä¸ºé¢˜ç›®ä¸­çš„è¦æ±‚å…¶å®å·²ç»å£°æ˜äº†ï¼Œæ•°å­—ä¸ä¼šè¶…è¿‡æ•°ç»„é•¿åº¦ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆçš„æ€è·¯æ¥æ‰¾åˆ°cycleã€‚ class Solution { public: int findDuplicate(vector& nums) { int slow = nums[0]; int fast = nums[0]; // Phase 1: Detect cycle do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = nums[0]; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; // The duplicate number } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/303/":{"url":"codes/303/","title":"303. Range Sum Query - Immutable","keywords":"","body":"303. Range Sum Query - Immutable Given an integer array nums, handle multiple queries of the following type: Calculate the sum of the elements of nums between indices left and right inclusive where left . Implement the NumArray class: NumArray(int[] nums) Initializes the object with the integer array nums. int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]). Example 1: Input [\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] Output [null, 1, -1, -3] Explanation NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1 numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1 numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3 Constraints: 1 -105 0 At most 104 calls will be made to sumRange. Solution ä¸€å¼€å§‹æƒ³æ³•æ˜¯é€šè¿‡vals[right] - vals[left]çš„æ–¹å¼è®¡ç®—å‡ºæ¥ç»“æœã€‚ä½†æ˜¯æˆ‘å¿½ç•¥äº†åº”è¯¥ä¿ç•™å½“å‰val[left]çš„å€¼ã€‚æ‰€ä»¥ç›´æ¥vals[right] - vals[left - 1]å°±è¡Œã€‚ Note: ä½¿ç”¨prefixè§£å†³ class NumArray { private: vector vals; public: NumArray(vector& nums) { vals.resize(nums.size()); vals[0] = nums[0]; for (int i = 1; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/344/":{"url":"codes/344/","title":"344. Reverse String","keywords":"","body":"344. Reverse String Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. Example 1: Input: [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] æ„Ÿè§‰æ²¡æœ‰ä»€ä¹ˆæŠ€æœ¯å«é‡ï¼Œå°±ç›´æ¥reverseå°±è¡Œã€‚ import java.util.Arrays; public class ReverseString { public void reverseString(char[] s) { int left = 0; int right = s.length - 1; while (left powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/347/":{"url":"codes/347/","title":"347. Top K Frequent Elements","keywords":"","body":"347. Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 â‰¤ k â‰¤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. It's guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique. You can return the answer in any order. ç”¨HashMapå¯ä»¥è§£å†³ï¼Œä½†æ˜¯å› ä¸ºJavaå¯¹HashMapæœ‰ç‚¹ç‚¹ä¸å¤ªå‹å–„ï¼Œæˆ‘æ”¹æˆPythonäº†ï¼Œå› ä¸ºå¯ä»¥è‡ªå®šä¹‰sort å­—å…¸ï¼Œè¿™æ ·å¯ä»¥æ ¹æ®ç»“æœæ’åºäº†ã€‚ã€‚ã€‚ class Solution: def topKFrequent(self, nums, k): frequence = {} for value in nums: if value in frequence: frequence[value] += 1 else: frequence[value] = 1 frequence = sorted(frequence.items(), key=lambda x: x[1], reverse=True) index = 0 res = [] for t in frequence: index += 1 res.append(t[0]) if index == k: break return res powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/350/":{"url":"codes/350/","title":"350. Intersection of Two Arrays II","keywords":"","body":"Intersection of Two Arrays II Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. è¿™ä¸ªé¢˜å°±ç¨å¾®ç®€å•ä¸€ç‚¹äº†ï¼Œå¯ä»¥ç”¨HashMapæ¥è®°å½•num1çš„å…ƒç´ ï¼Œvalueæ¥å­˜æ•°å­—å‡ºç°çš„æ¬¡æ•°ã€‚è¿™æ ·åœ¨éå†num2çš„æ—¶å€™å°±å¯ä»¥ç›´æ¥åˆ¤æ–­äº†ã€‚ã€‚ã€‚åˆšå¼€å§‹æƒ³åˆ°è¿‡arrayçš„ç”¨æ³•ï¼Œä½†æ˜¯å› ä¸ºkeyæ˜¯å•ä¸€çš„ï¼Œé»˜é»˜è¢«æˆ‘æ”¾å¼ƒäº†ï¼ˆæˆ‘å°±æ˜¯å‚»é€¼ã€‚ã€‚ã€‚ï¼‰ï¼Œçœ‹äº†ä¸€ä¸‹discussionæç„¶å¤§æ‚Ÿã€‚ã€‚ã€‚ import javax.swing.*; import java.util.*; /** * Input: nums1 = [1,2,2,1], nums2 = [2,2] * Output: [2,2] * æ²¡å•¥æ€è·¯ï¼Œ å‚»é€¼äº†ï¼Œæƒ³ç€å¯ä»¥ç”¨hashmapä½†æ˜¯ï¼Œæƒ³åˆ°hashmapçš„keyåªèƒ½å­˜ä¸€ä¸ªvalue * ä½†æ˜¯valueå¯ä»¥è¡¨ç¤ºæ•°é‡å•Š * å‚»é€¼ * */ public class Intersection { public int[] intersect(int[] nums1, int[] nums2) { HashMap maps = new HashMap<>(); ArrayList res = new ArrayList(); for (Integer num : nums1) { if (maps.containsKey(num)) { maps.put(num, maps.get(num) + 1); } else { maps.put(num, 1); } } for (Integer num : nums2) { if (maps.containsKey(num)) { res.add(num); if (maps.get(num) == 1) maps.remove(num); else maps.put(num, maps.get(num) - 1); } } int[] result = new int[res.size()]; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/380/":{"url":"codes/380/","title":"380. Insert Delete GetRandom O(1)","keywords":"","body":"380. Insert Delete GetRandom O(1) Implement the RandomizedSet class: RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity. Example 1: Input [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2] Explanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Constraints: -231 At most 2 * ``105 calls will be made to insert, remove, and getRandom. There will be at least one element in the data structure when getRandom is called. Solution é€šè¿‡ä½¿ç”¨hashmapå’Œvectoræ¥å®ç°ï¼Œhashmapæ¥è®°å½•æ•°å­—åœ¨vectorä¸­indexçš„ä½ç½®ã€‚å½“éœ€è¦removeçš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæœ€åè¯¥æ•°å­—æ”¾åˆ°vectorçš„æœ«å°¾ï¼Œç„¶ååˆ é™¤æ‰æœ€åä¸€ä¸ªæ•°å­—ï¼Œè¿™æ ·çš„è¯å°±åªéœ€è¦O(1)çš„å¤æ‚åº¦ã€‚removeçš„æ—¶å€™åªéœ€è¦æ›´æ–°indexä½ç½®å°±è¡Œã€‚ class RandomizedSet { private: unordered_map maps; vector vec; std::mt19937 gen; public: RandomizedSet() : gen(std::random_device{}()) {} bool insert(int val) { if (maps.count(val)) return false; maps[val] = vec.size(); vec.push_back(val); return true; } bool remove(int val) { auto it = maps.find(val); if (it == maps.end()) return false; int idx = it->second; int last = vec.back(); vec[idx] = last; maps[last] = idx; vec.pop_back(); maps.erase(it); return true; } int getRandom() { std::uniform_int_distribution<> dis(0, vec.size() - 1); return vec[dis(gen)]; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/387/":{"url":"codes/387/","title":"387. First Unique Character in a String","keywords":"","body":"387. First Unique Character in a String Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1. Examples: s = \"leetcode\" return 0. s = \"loveleetcode\", return 2. ä½¿ç”¨äº†HashMapçš„æ–¹æ³•ï¼Œå½“å­—ç¬¦åªå‡ºç°ä¸€æ¬¡å°±è®¾ç½®keyä¸ºå½“å‰charï¼Œvalueè®¾ç½®ä¸ºindexï¼Œå¦‚æœå‡ºç°è¶…è¿‡ä¸€æ¬¡ï¼Œå°±æ ‡è®°valueæ˜¯MAXã€‚ç­›é€‰HashMapé‡Œé¢valueä¸æ˜¯MAXï¼Œå¹¶ä¸”è¿”å›å°±è¡Œäº†ã€‚ import java.util.Collections; import java.util.HashMap; public class FirstUnique { public int firstUniqChar(String s) { HashMap map = new HashMap<>(); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/389/":{"url":"codes/389/","title":"389. Find the Difference","keywords":"","body":"389. Find the Difference You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t. Example 1: Input: s = \"abcd\", t = \"abcde\" Output: \"e\" Explanation: 'e' is the letter that was added. Example 2: Input: s = \"\", t = \"y\" Output: \"y\" Constraints: 0 t.length == s.length + 1 s and t consist of lowercase English letters. Solution é—®å°±æ˜¯hashmapã€‚ class Solution: def findTheDifference(self, s: str, t: str) -> str: maps1 = {} maps2 = {} for x in s: if x not in maps1: maps1[x] = 1 else: maps1[x] += 1 for x in t: if x not in maps1: return x if x not in maps2: maps2[x] = 1 else: maps2[x] += 1 for x in s: if maps1[x] != maps2[x]: return x return None powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/448/":{"url":"codes/448/","title":"448. Find All Numbers Disappeared in an Array","keywords":"","body":"Find All Numbers Disappeared in an Array Find All Numbers Disappeared in an Array Given an array of integers where 1 â‰¤ a[i] â‰¤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1] Output: [5,6] é¢˜è§£ï¼šæ•°ç»„é•¿åº¦1-nï¼Œè¦åˆ¤æ–­æ•°ç»„é‡Œé¢å‡ºç°çš„æ•°å­—æ˜¯ä¸æ˜¯åœ¨1-nä¹‹é—´ï¼Œå¦‚æœå°‘äº†å“ªä¸ªæ•°å­—å°±ç»™è¡¥ä¸Šã€‚ æ¯”å¦‚ï¼š[2,2]æ•°ç»„é•¿åº¦1-2ï¼Œé‚£ä¹ˆæ”¹æ•°ç»„å°‘äº†1ã€‚ solution 1ï¼š åˆšå¼€å§‹è€ƒè™‘çš„æ˜¯å…ˆsortä¸€ä¸‹ï¼Œç„¶ååˆ¤æ–­indexåœ¨0ï¼Œæœ«å°¾å’Œä¸­é—´çš„æƒ…å†µè¿›è¡Œè¡¥å…¨ï¼Œä½†æ˜¯è²Œä¼¼æœ‰ç‚¹æµªè´¹æ—¶é—´äº†ã€‚ã€‚æ‰€ä»¥æ—¶é—´å¤æ‚åº¦æœ‰ç‚¹é«˜$O(nlog_{n} + n)$ã€‚ä¸è¿‡ä¹Ÿç®—æ˜¯ä¸€ç§æ–¹æ³•å¯¹å§ã€‚ã€‚ã€‚o(â•¥ï¹â•¥)o public List findDisappearedNumbers(int[] nums) { List dis = new LinkedList<>(); if (nums.length == 0) return dis; Arrays.sort(nums); int num = nums[0]; while (num > 1) { num --; dis.add(num); } num = nums[0]; for (int i = 1; i solution 2ï¼š çœ‹äº†ä¸€ä¸‹discussionæ„Ÿè§‰ä»–ä»¬å†™çš„æ–¹æ³•å±Œçˆ†äº†ã€‚ã€‚ã€‚å› ä¸ºæ•°ç»„é‡Œé¢çš„æ•°å­—æ˜¯åœ¨æ•°ç»„é•¿åº¦1-nä¹‹å†…çš„ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥åšä¸€ä¸ªæŒ‡ç¤ºå™¨çš„æ ¼å¼ï¼ŒæŠŠæ•°ç»„é‡Œé¢æ¯ä¸ªæ•°å­—æ‰€å¯¹åº”çš„åæ ‡å˜æˆè´Ÿæ•°ï¼Œç„¶åå†å¯»æ‰¾ä¸€ä¸ªarrayé‡Œé¢å“ªäº›æ˜¯è´Ÿæ•°ã€‚å¾ˆæ¬¢å–œã€‚ã€‚ public List findDisappearedNumbers(int[] nums) { List dis = new LinkedList<>(); if (nums.length == 0) return dis; for (int i = 0; i 0) { nums[index] = -nums[index]; } } for (int i = 0; i 0) dis.add(i + 1); return dis; } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/496/":{"url":"codes/496/","title":"496. Next Greater Element I","keywords":"","body":"496. Next Greater Element I The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 , find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1. Return an array ans of length nums1.length such that ans[i] is the next greater element as described above. Example 1: Input: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. - 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. - 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3. - 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1. Constraints: 1 0 All integers in nums1 and nums2 are unique. All the integers of nums1 also appear in nums2. Follow up: Could you find an O(nums1.length + nums2.length) solution? Solution å’Œä¸Šé¢é‚£ä¸ªé¢˜æ€è·¯å·®ä¸å¤šï¼Œåªæ˜¯æ¯ä¸ªelementéƒ½æ˜¯uniqueçš„ï¼Œæ‰€ä»¥å¯ä»¥é¢å¤–ä½¿ç”¨hashmapæ¥æ–¹ä¾¿è¿ç®—ã€‚ class Solution { public: vector nextGreaterElement(vector& nums1, vector& nums2) { auto stack = vector(); auto maps = unordered_map(); auto res = vector(nums1.size(), -1); if (nums2.size() == 0) return res; stack.push_back(nums2[0]); maps[nums2[0]] = -1; for (int i = 1; i nums2[i]) break; maps[val] = nums2[i]; stack.pop_back(); } stack.push_back(nums2[i]); } for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/515/":{"url":"codes/515/","title":"515. Find Largest Value in Each Tree Row","keywords":"","body":"515. Find Largest Value in Each Tree Row Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed). Example 1: Input: root = [1,3,2,5,3,null,9] Output: [1,3,9] Example 2: Input: root = [1,2,3] Output: [1,3] Constraints: The number of nodes in the tree will be in the range [0, 104]. -231 Solution bfséå†ä¸€éå°±è¡Œ class Solution { public: vector largestValues(TreeNode* root) { auto res = vector(); if (root == NULL) return res; auto currs = vector(); auto nexts = vector(); currs.push_back(root); while (!currs.empty()) { int max_val = INT_MIN; for (auto const& n : currs) { if (n->val > max_val) max_val = n->val; if (n->left != NULL) nexts.push_back(n->left); if (n->right != NULL) nexts.push_back(n->right); } currs = nexts; nexts.clear(); res.push_back(max_val); } return res; } }; powered by GitbookFile Modify: 2025-01-12 17:50:50 "},"codes/645/":{"url":"codes/645/","title":"645. Set Mismatch","keywords":"","body":"645. Set Mismatch You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: Input: nums = [1,2,2,4] Output: [2,3] Example 2: Input: nums = [1,1] Output: [1,2] Constraints: 2 1 Solution hashmap çš„è§£å†³æ€è·¯ class Solution { public: vector findErrorNums(vector& nums) { auto res = vector(); int r_sum = nums.size() * (nums.size() + 1) / 2; auto maps = unordered_map(); for (int const& num : nums) { maps[num] += 1; if (maps[num] > 1) res.push_back(num); if (maps[num] == 1) { r_sum -= num; } } res.push_back(r_sum); return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/704/":{"url":"codes/704/","title":"704. Binary Search","keywords":"","body":"704. Binary Search Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1. Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 æ ‡å‡†çš„äºŒåˆ†æŸ¥æ‰¾æ³•ï¼ˆåªèƒ½ç”¨åœ¨æ’è¿‡åºçš„listé‡Œé¢ï¼‰ã€‚æœ‰ä¸€ä¸ªç®—æ³•è®²è§£ï¼š public class BinarySearch { public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left target) right = mid - 1; else left = mid + 1; } return -1; } public static void main(String[] args) { int[] nums = new int[] {-1,0,3,5,9,12}; BinarySearch bs = new BinarySearch(); int res = bs.search(nums, 9); System.out.println(res); } } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/739/":{"url":"codes/739/","title":"739. Daily Temperatures","keywords":"","body":"739. Daily Temperatures Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] Example 3: Input: temperatures = [30,60,90] Output: [1,1,0] Constraints: 1 30 Solution Temperature: [73, 74, 75, 71, 69, 72, 76, 73] stack = [] res = [0, 0, 0, 0, 0, 0, 0, 0] 1. index = 0 stack = [(0, 73)] 2. index = 1 74 > 73, pop (0, 73) and set res[0] = index - 0 stack = [(1, 74)] res = [1, 0, 0, 0, 0, 0, 0, 0] 3. index = 2 75 > 74, pop (1, 74) and set res[1] = index - 1 stack = [(2, 75)] res = [1, 1, 0, 0, 0, 0, 0, 0] 4. index = 3 71 72 pop (5, 72) and (2, 75), set res[5] = index - 5, and res[2] = index -2 stack = [] res = [1, 1, 4, 2, 1, 1, 0, 0] è¿™ä¸ªæ˜¯çœŸæ˜¯é¢è¯•é¢˜ï¼Œ21å¹´çš„æ—¶å€™é¢è¯•çš„æ—¶å€™é‡åˆ°äº†ã€‚å¯ä»¥é‡‡ç”¨ stack æ•°æ®ç»“æ„çš„è§£å†³æ–¹æ³•ã€‚å½“éå†å½“å‰æ¸©åº¦çš„æ—¶å€™å»åˆ¤æ–­ stack é‡Œé¢çš„å…ƒç´ æ˜¯å¦å°äºå½“å‰æ¸©åº¦ï¼Œå¦‚æœå°äºçš„è¯åˆ™ pop ï¼Œæœ€åç»“æŸå¾ªç¯çš„æ—¶å€™æŠŠå½“å‰æ¸©åº¦æ·»åŠ åˆ° stack ä¸­ï¼Œå› ä¸ºæ¯ä¸ªæ¸©åº¦éƒ½è¦æ‰¾åˆ°æ¯”å½“å‰å¤§çš„æ¸©åº¦ã€‚ class Solution { public: vector dailyTemperatures(vector& temperatures) { auto stack = std::vector>(); auto res = vector(temperatures.size(), 0); for (int i = 0; i val = stack.back(); if (val.first >= t) break; res[val.second] = i - val.second; stack.pop_back(); } stack.push_back(pair(t, i)); } return res; } }; æ¯æ¬¡éƒ½æœ‰ä¸åŒçš„æƒ³æ³•ï¼Œä½†æ˜¯æ€è·¯å’Œä»£ç è¶Šæ¥è¶Šç®€å•é«˜æ•ˆï¼Œè¿˜æ˜¯ç”¨stack class Solution { public: vector dailyTemperatures(vector& temperatures) { stack stack; auto res = vector(temperatures.size(), 0); for (int i = 0; i powered by GitbookFile Modify: 2025-01-20 19:13:06 "},"codes/804/":{"url":"codes/804/","title":"804. Unique Morse Code Words","keywords":"","body":"804. Unique Morse Code Words International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: 'a' maps to \".-\", 'b' maps to \"-...\", 'c' maps to \"-.-.\", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word. Return the number of different transformations among all words we have. Example 1: Input: words = [\"gin\",\"zen\",\"gig\",\"msg\"] Output: 2 Explanation: The transformation of each word is: \"gin\" -> \"--...-.\" \"zen\" -> \"--...-.\" \"gig\" -> \"--...--.\" \"msg\" -> \"--...--.\" There are 2 different transformations: \"--...-.\" and \"--...--.\". Example 2: Input: words = [\"a\"] Output: 1 Solution ç›´æ¥hashmapã€‚ class Solution: def uniqueMorseRepresentations(self, words: List[str]) -> int: maps = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] res = {} for word in words: tmp = \"\".join(maps[ord(x) - ord('a')] for x in word) res[tmp] = 1 return len(res) powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/1019/":{"url":"codes/1019/","title":"1019. Next Greater Node In Linked List","keywords":"","body":"1019. Next Greater Node In Linked List Next Greater Node In Linked List is a medium problem. We are given a linked list with head as the first node. Let's number the nodes in the list: node_1, node_2, node_3, ... etc. Each node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j > i, node_j.val > node_i.val, and j is the smallest possible choice. If such a j does not exist, the next larger value is 0. Return an array of integers answer, where answer[i] = next_larger(node_{i+1}). Note that in the example inputs (not outputs) below, arrays such as [2,1,5] represent the serialization of a linked list with a head node value of 2, second node value of 1, and third node value of 5. Approach This problem is pretty similar with Daily Temperatures which can be solved by applying stack. For this issue, we can use stack + hashmap to solve it with $O(n)$ time complexity. Init stack and the final result. result(hashmap) will recored the index as key and greater or 0 value as the value When the temp node value is greater then the top value of the stack, update the result value and pop the top value of stack. # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def nextLargerNodes(self, head: ListNode) -> List[int]: stack = [] result = {} temp = head index = 0 # stack store like (val, pos) while (temp != None): while len(stack) != 0 and temp.val > stack[len(stack) - 1][0]: result[stack[len(stack) - 1][1]] = temp.val stack.pop(len(stack) - 1) stack.append((temp.val, index)) result[index] = 0 index += 1 temp = temp.next return result.values() We can use the following data to give an example: Input: [2,1,5] Output: [5,5,0] In the following part, we will display the result and stack storage. 1. stack.push((2, 0)) stack = [(2, 0)], result = {0: 0} 2. stack.push((1, 1)), stack = [(2, 0), (1, 1)], result = {0: 0, 1: 0} 3. The node value is 5, greater than 1, then 1. top value of stack is (1, 1), then result[1] = node.val (5), stack pop (1, 1) 2. top value of stack is (2, 0), then result[0] = node.val (5), stack pop (2, 0) 3. End while loop, and insert the (5, 3) into stack and result. The final value in result is: result = { 0: 5, 1: 5, 2: 0 } powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/1282/":{"url":"codes/1282/","title":"1282. Group the People Given the Group Size They Belong To","keywords":"","body":"1282. Group the People Given the Group Size They Belong To There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1. You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3. Return a list of groups such that each person i is in a group of size groupSizes[i]. Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input. Example 1: Input: groupSizes = [3,3,3,3,3,1,3] Output: [[5],[0,1,2],[3,4,6]] Explanation: The first group is [5]. The size is 1, and groupSizes[5] = 1. The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3. The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3. Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]]. Example 2: Input: groupSizes = [2,1,3,3,3,2] Output: [[1],[0,5],[2,3,4]] Solution ç›´æ¥hashmapå°±è¡Œï¼š class Solution { public: vector> groupThePeople(vector& groupSizes) { auto maps = unordered_map>(); auto res = vector>(); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/1365/":{"url":"codes/1365/","title":"1365. How Many Numbers Are Smaller Than the Current Number","keywords":"","body":"1365. How Many Numbers Are Smaller Than the Current Number How Many Numbers Are Smaller Than the Current Number is an easy problem. Howerver, it is more interesting than other questions. Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] . Example 1: Input: nums = [8,1,2,2,3] Output: [4,0,1,1,3] Explanation: For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). For nums[1]=1 does not exist any smaller number than it. For nums[2]=2 there exist one smaller number than it (1). For nums[3]=2 there exist one smaller number than it (1). For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2). Approach Naive approach is brute force. Just use two nest loop can get the result. result = [] for i in range(0, len(nums)): num = 0 for j in range(i, len(nums)): if nums[i] > nums[j]: num += 1 result.append(num) The time complexity is O(n^2) powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/1455/":{"url":"codes/1455/","title":"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence","keywords":"","body":"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence. Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1. A prefix of a string s is any leading contiguous substring of s. Example 1: Input: sentence = \"i love eating burger\", searchWord = \"burg\" Output: 4 Explanation: \"burg\" is prefix of \"burger\" which is the 4th word in the sentence. Example 2: Input: sentence = \"this problem is an easy problem\", searchWord = \"pro\" Output: 2 Explanation: \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index. Example 3: Input: sentence = \"i am tired\", searchWord = \"you\" Output: -1 Explanation: \"you\" is not a prefix of any word in the sentence. Constraints: 1 1 sentence consists of lowercase English letters and spaces. searchWord consists of lowercase English letters. Solution ä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œæ³¨æ„ä¸‹è¾¹ç•Œæƒ…å†µå°±è¡Œã€‚pythonå¯ä»¥ç›´æ¥splitï¼Œä½†æ²¡å•¥æ„æ€ã€‚ class Solution { public: int isPrefixOfWord(string sentence, string searchWord) { int wordIndex = 0, wordCount = 0; bool isNewWord = true; for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/1646/":{"url":"codes/1646/","title":"1646. Get Maximum in Generated Array","keywords":"","body":"1646. Get Maximum in Generated Array You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way: nums[0] = 0 nums[1] = 1 nums[2 * i] = nums[i] when 2 nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 Return the maximum integer in the array nums. Example 1: Input: n = 7 Output: 3 Explanation: According to the given rules: nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3. Example 2: Input: n = 2 Output: 1 Explanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1. Example 3: Input: n = 3 Output: 2 Explanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2. Solution å¥½åƒä¸»è¦æ˜¯é¢˜æ„ä¸å¥½ç†è§£ã€‚ ä½ éœ€è¦ç”Ÿæˆä¸€ä¸ªæ•°ç»„ numsï¼Œå…¶ä¸­ï¼š nums[0]=0 nums[1]=1(å¦‚æœ n >= 1ï¼‰ã€‚ å¯¹äº 2 ï¼Œæ ¹æ®ä»¥ä¸‹è§„åˆ™è®¡ç®—ï¼š å¦‚æœ i æ˜¯å¶æ•°ï¼šnums[i]=nums[i/2]ã€‚ å¦‚æœ iæ˜¯å¥‡æ•°ï¼šnums[i]=nums[i/2]+nums[i/2+1]ã€‚ æœ€åï¼Œè¿”å›ç”Ÿæˆçš„æ•°ç»„ä¸­æœ€å¤§çš„å€¼ã€‚ class Solution { public: int getMaximumGenerated(int n) { if (n == 0) return 0; if (n == 1) return 1; auto nums = vector(); nums.push_back(0); nums.push_back(1); int max_val = 1; for (int i = 2; i val ? max_val : val; } return max_val; } }; ç©ºé—´å¤æ‚åº¦è¿˜èƒ½è¿›ä¸€æ­¥ä¼˜åŒ–ã€‚ powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/2109/":{"url":"codes/2109/","title":"2109. Adding Spaces to a String","keywords":"","body":"2109. Adding Spaces to a String You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index. For example, given s = \"EnjoyYourCoffee\" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain \"Enjoy **Y**our **C**offee\". Return the modified string after the spaces have been added. Example 1: Input: s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15] Output: \"Leetcode Helps Me Learn\" Explanation: The indices 8, 13, and 15 correspond to the underlined characters in \"LeetcodeHelpsMeLearn\". We then place spaces before those characters. Example 2: Input: s = \"icodeinpython\", spaces = [1,5,7,9] Output: \"i code in py thon\" Explanation: The indices 1, 5, 7, and 9 correspond to the underlined characters in \"icodeinpython\". We then place spaces before those characters. Example 3: Input: s = \"spacing\", spaces = [0,1,2,3,4,5,6] Output: \" s p a c i n g\" Explanation: We are also able to place spaces before the first character of the string. Constraints: 1 s consists only of lowercase and uppercase English letters. 1 0 All the values of spaces are strictly increasing. Solution éš¾åº¦ä¸å¤§ï¼Œç®€å•çš„æ“ä½œã€‚ class Solution { public: string addSpaces(string s, vector& spaces) { string result; int spaceIdx = 0, strIdx = 0; while (strIdx powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/2325/":{"url":"codes/2325/","title":"2325. Decode the Message","keywords":"","body":"2325. Decode the Message You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows: Use the first appearance of all 26 lowercase English letters in key as the order of the substitution table. Align the substitution table with the regular English alphabet. Each letter in message is then substituted using the table. Spaces ' ' are transformed to themselves. For example, given key = \"**hap**p**y** **bo**y\" (actual key would have at least one instance of each letter in the alphabet), we have the partial substitution table of ('h' -> 'a', 'a' -> 'b', 'p' -> 'c', 'y' -> 'd', 'b' -> 'e', 'o' -> 'f'). Return the decoded message. Solution æ²¡å•¥å¤ªå¤§éš¾åº¦ï¼Œhashmapã€‚ class Solution { public: string decodeMessage(string key, string message) { auto maps = unordered_map(); char x = 'a'; for (char const& k : key) { if (k == ' ') continue; if (maps.find(k) != maps.end()) continue; maps[k] = x; x += 1; } string res = \"\"; for (char const & m : message) { res += m == ' ' ? m : maps[m]; } return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/2593/":{"url":"codes/2593/","title":"2593. Find Score of an Array After Marking All Elements","keywords":"","body":"2593. Find Score of an Array After Marking All Elements You are given an array nums consisting of positive integers. Starting with score = 0, apply the following algorithm: Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index. Add the value of the chosen integer to score. Mark the chosen element and its two adjacent elements if they exist. Repeat until all the array elements are marked. Return the score you get after applying the above algorithm. Example 1: Input: nums = [2,1,3,4,5,2] Output: 7 Explanation: We mark the elements as follows: - 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2]. - 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2]. - 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2]. Our score is 1 + 2 + 4 = 7. Example 2: Input: nums = [2,3,5,1,3,2] Output: 5 Explanation: We mark the elements as follows: - 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2]. - 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2]. - 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2]. Our score is 1 + 2 + 2 = 5. Solution ä½¿ç”¨priority queueçš„æ€è·¯å°±è¡Œï¼Œæœ€å°çš„æ•°å­—æ”¾åœ¨æœ€å‰é¢ã€‚pqå­˜çš„æ•°æ®åŒ…å«æ•°å­—å’Œå¯¹åº”çš„indexå°±è¡Œã€‚ S1 class Solution { public: long long findScore(vector& nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; auto marked = vector(nums.size(), false); auto pq = std::vector>(); for (int i = 0; i & a, const std::pair& b) { return a.first > b.first || (a.first == b.first && a.second > b.second); }); long long res = 0; while (!pq.empty()) { auto it = pq.back(); pq.pop_back(); if (marked[it.second]) continue; // visited marked[it.second] = true; if (it.second == 0) { marked[it.second + 1] = true; } else if (it.second == nums.size() - 1) { marked[it.second - 1] = true; } else { marked[it.second - 1] = true; marked[it.second + 1] = true; } res += it.first; } return res; } }; S2 class Compare { public: bool operator()(pair below, pair above) { if (below.first > above.first) { return true; } else if (below.first == above.first && below.second > above.second) { return true; } return false; } }; class Solution { public: long long findScore(vector& nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; auto marked = vector(nums.size(), false); auto pq = priority_queue, vector>, Compare>(); for (int i = 0; i powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/2396/":{"url":"codes/2396/","title":"2396. Strictly Palindromic Number","keywords":"","body":"2396. Strictly Palindromic Number An integer n is strictly palindromic if, for every base b between 2 and n - 2 (inclusive), the string representation of the integer n in base b is palindromic. Given an integer n, return true if n is strictly palindromic and false otherwise. A string is palindromic if it reads the same forward and backward. Example 1: Input: n = 9 Output: false Explanation: In base 2: 9 = 1001 (base 2), which is palindromic. In base 3: 9 = 100 (base 3), which is not palindromic. Therefore, 9 is not strictly palindromic so we return false. Note that in bases 4, 5, 6, and 7, n = 9 is also not palindromic. Example 2: Input: n = 4 Output: false Explanation: We only consider base 2: 4 = 100 (base 2), which is not palindromic. Therefore, we return false. Constraints: 4 Solution éå†ä¸€ä¸‹ç„¶åç”¨åŒæŒ‡é’ˆå°±è¡Œ class Solution { public: bool isStrictlyPalindromic(int n) { if (n == 0) return false; for (int b = 2; b (); int x = n; while (x > 0) { vals.push_back(x % b); x /= b; } int s = 0, e = vals.size() - 1; while (s powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/2418/":{"url":"codes/2418/","title":"2418. Sort the People","keywords":"","body":"2418. Sort the People You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n. For each index i, names[i] and heights[i] denote the name and height of the ith person. Return names sorted in descending order by the people's heights. Example 1: Input: names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170] Output: [\"Mary\",\"Emma\",\"John\"] Explanation: Mary is the tallest, followed by Emma and John. Example 2: Input: names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150] Output: [\"Bob\",\"Alice\",\"Bob\"] Explanation: The first Bob is the tallest, followed by Alice and the second Bob. Solution ç”¨priority queueå°±èƒ½è§£å†³ï¼Œéš¾åº¦ä¸å¤§ class Solution { public: vector sortPeople(vector& names, vector& heights) { auto cmp = [](const pair &a, const pair &b) { return a.second , vector>, decltype(cmp)> pq(cmp); for (int i = 0; i (); while (!pq.empty()) { ans.push_back(pq.top().first); pq.pop(); } return ans; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "},"codes/3152/":{"url":"codes/3152/","title":"3152. Special Array II","keywords":"","body":"3152. Special Array II An array is considered special if every pair of its adjacent elements contains two numbers with different parity. You are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that subarray nums[fromi..toi] is special or not. Return an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special. Example 1: Input: nums = [3,4,1,2,6], queries = [[0,4]] Output: [false] Explanation: The subarray is [3,4,1,2,6]. 2 and 6 are both even. Example 2: Input: nums = [4,3,1,6], queries = [[0,2],[2,3]] Output: [false,true] Explanation: The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to this query is false. The subarray is [1,6]. There is only one pair: (1,6) and it contains numbers with different parity. So the answer to this query is true. Constraints: 1 1 1 queries[i].length == 2 0 Solution S1 ç›´æ¥æš´åŠ›æœç´¢queryçš„èŒƒå›´åŒºé—´ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰bugï¼Œå¦‚æœæœ‰bugå°±æ ‡è®°é”™è¯¯ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•æ—¶é—´ä¼šè¶…å‡ºé¢„æœŸã€‚ class Solution { public: vector isArraySpecial(vector& nums, vector>& queries) { auto res = vector(queries.size()); int idx = 0; for (auto const& query : queries) { int s = query[0]; int e = query[1]; bool is_odd = nums[s] % 2 == 0 ? false : true; bool r = true; for (s = s + 1; s S2 æˆ‘é€šè¿‡è®°å½•numsä¸­æ¯ä¸ªå‘ç”Ÿé”™è¯¯çš„é¦–åœ°å€ï¼Œç„¶åqueryçš„æ—¶å€™åˆ¤æ–­è¯¥åŒºé—´æ˜¯å¦åŒ…å«è¯¥é”™è¯¯åœ°å€ï¼Œå¦‚æœåŒ…å«åˆ™falseã€‚ä½†æ˜¯è¿™ç§æ–¹æ³•æ•ˆç‡ä¹Ÿä¸æ˜¯æœ€é«˜çš„ class Solution { public: vector isArraySpecial(vector& nums, vector>& queries) { auto err = vector(); if (nums.size() > 1) { for (int i = 1; i (queries.size(), true); for (int i = 0; i S3 GPTç»™çš„æœ€ä¼˜è§£ï¼Œç¬¬ä¸€æ­¥æ˜¯ç±»ä¼¼çš„ï¼Œå…ˆå»ºç«‹ä¸€ä¸ªæ•°ç»„æ¥è®°å½•æ˜¯å¦bugï¼Œå¦‚æœbugåˆ™æ ‡è®°1ã€‚ç¬¬äºŒéƒ¨æ˜¯é€šè¿‡å»ºç«‹prefixçš„æ–¹å¼ï¼Œæ¥è®°å½•å½“0-å½“å‰æ•°å­—ä¸­æœ‰å¤šå°‘ä¸ªbugã€‚è¿™æ ·queryçš„æ—¶å€™åªè¦éœ€è¦åˆ¤æ–­query[0]åˆ°query[1]ä¸­åŒ…å«å¤šå°‘ä¸ªbugå°±è¡Œã€‚å¦‚æœæ˜¯0åˆ™è¡¨ç¤ºè¿™ä¸ªæ•°ç»„æ˜¯validã€‚ class Solution { public: vector isArraySpecial(vector& nums, vector>& queries) { int n = nums.size(); std::vector isError(n, 0); // Mark errors for (int i = 1; i prefixSum(n + 1, 0); for (int i = 0; i res; for (const auto& query : queries) { int s = query[0], e = query[1]; // Check if there's any error in the range [s, e) res.push_back(prefixSum[e] - prefixSum[s] == 0); } return res; } }; powered by GitbookFile Modify: 2024-12-25 18:18:40 "}}